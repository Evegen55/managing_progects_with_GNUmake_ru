%%-------------------------------------------------------------------
%% Command enviromnent
%%-------------------------------------------------------------------
\section{Команды и окружение}
\label{sec:command_environment}

Команды, выполняемые \GNUmake{}, наследуют окружение процесса
\GNUmake{}. Это окружение включает текущий каталог, файловые
дескрипторы и переменные окружения, передаваемые \GNUmake{}.

Когда создаётся дочерний процесс командного интерпретатора, \GNUmake{}
добавляется в окружение несколько переменных:

{\footnotesize
\begin{verbatim}
MAKEFLAGS
MFLAGS
MAKELEVEL
\end{verbatim}
}

Переменная \variable{MAKEFLAGS} включает опции командной строки,
переданные \GNUmake{}. Переменная \variable{MFLAGS} дублирует
содержимое \variable{MAKEFLAGS} и существует по историческим причинам.
Переменная \variable{MAKELEVEL} содержит число вложенных вызовов
\GNUmake{}. Таким образом, когда \GNUmake{} рекурсивно вызывает
\GNUmake{}, переменная \variable{MAKELEVEL} увеличивается на единицу.
Подпроцесс родительского процесса \GNUmake{} будет иметь переменную
\variable{MAKELEVEL}, значением которой будет единица. Все эти
переменные обычно используются для управления рекурсивным \GNUmake{}.
Мы обсудим эту тему в разделе <<\nameref{sec:recursive_make}>>
главы~\ref{chap:managing_large_proj}.

Конечно, пользователь может передать в окружение дочернего процесса
любую переменную по своему усмотрению, используя директиву
\index{Директивы!export@\directive{export}}
\directive{export}.

Текущий рабочий каталог исполняемой команды совпадает с рабочим
каталогом родителького процесса \GNUmake{}. Обычно это тот же каталог,
из которого была вызвана программа \GNUmake{}, однако его можно
заменить при помощи опции \command{--directory=\emph{каталог}} (или
\command{-C}). Заметим, что спецификация \Makefile{}'а при помощи
опции \command{-{}-fi\-le} не изменяет рабочий каталог, только
устанавливает \Makefile{}, который нужно прочитать.

Каждый подпроцесс, порождаемый \GNUmake{}, наследует три стандартных
файловых дескриптора: \filename{stdin}, \filename{stdout} и
\filename{stderr}. Здесь нет ничего особенного, за исключением одного
следствия: сценарий сборки может считывать данные из стандартного
потока ввода. Как только сценарий считает все данные из потока,
оставшиеся команды выполняются в обычном порядке. Однако ожидается,
что \Makefile{}'ы должны работать корректно без этого типа
взаимодействия. Пользователь часто расчитывает на возможность просто
запустить \GNUmake{} и далее не принимать никакого участия в процессе
сборки, проверив лишь результаты по завершению. И, конечно, сложно
придумать полезное применение чтению стандартного потока ввода в
контексте автоматизированных сборок, основанных на использовании
\utility{cron}.

Общей ошибкой является случайное чтение стандартного потока ввода:

{\footnotesize
\begin{verbatim}
$(DATA_FILE): $(RAW_DATA)
    grep pattern $(RAW_DATA_FILES) > $@
\end{verbatim}
}

Здесь входные файлы для \utility{grep} хранятся в переменной (при
использовании которой произошла опечатка). Если вместо значения
переменной подставится пустая строка, \utility{grep} останется только
читать данные со стандартного потока ввода, без каких либо объяснений
причины <<зависания>> \GNUmake{}. Простым способом избежать такой
проблемы является включение в команду дополнительного файла устройства
\filename{/dev/null}:

{\footnotesize
\begin{verbatim}
$(DATA_FILE): $(RAW_DATA)
    grep pattern $(RAW_DATA_FILES) /dev/null > $@
\end{verbatim}
}

Такая команда никогда не примет попытки чтения стандартного потока
ввода. Естественно, отладка \Makefile{}'ов также помогает избежать
неприятностей.
