%%--------------------------------------------------------------------
%% Command-line limits
%%--------------------------------------------------------------------
\section{Ограничения командной строки}
\label{sec:command_line_limits}

Во время работы с крупными проектами вы можете столкнуться с
ограничениями на длину команд, которые \GNUmake{} пытается выполнить.
Ограничения на длину командной строки варьируются в зависимости от
операционной системы. Red Hat 9 GNU/Linux позволяет выполнять команды
длиной не более 128 Кб, а Windows XP ограничивает длину 32 Кб.
Сообщения об ошибке также варьируются. Если вы вызовите команду
\utility{ls} со слишком большим списком параметров, в Cygwin под
Windows, то получите следующее сообщение:

{\footnotesize
\begin{verbatim}
C:\usr\cygwin\bin\bash: /usr/bin/ls: Invalid argument
\end{verbatim}
}

На Red Hat 9 сообщение выглядит иначе:

{\footnotesize
\begin{verbatim}
/bin/ls: argument list too long
\end{verbatim}
}

Даже 32 Кб выглядит как довольно большой объём данных для командной
строки, однако когда ваш проект содержит 3000 файлов и 100
подкаталогов, и вы хотите манипулировать ими всеми, это ограничение
может быть довольно существенным.

Существует два основных пути, которые ведут к неприятностям с
ограничениями на длину строки: вычисление базовых значений при помощи
инструментов командного интерпретатора или использование \GNUmake{}
для присваивания переменной значения очень большой длины. Предположим
для примера, что мы хотим скомпилировать все исходные файлы одной
командой:

{\footnotesize
\begin{verbatim}
ompile_all:
$(JAVAC) $(wildcard $(addsuffix /*.java,$(source_dirs)))
\end{verbatim}
}

Переменная \GNUmake{} \variable{source\_dirs} может содержать всего
несколько сотен слов, однако после добавления шаблона исходных файлов
\Java{} и применения функции \function{wildcard} этот список может
превысить предельную длину командной строки вашей системы. Кстати,
\GNUmake{} не имеет собственных ограничений на длину строки, позволяя
вам хранить столько данных, сколько может вместить виртуальная память.

Когда сталкиваешься с подобной ситуацией, возникает ощущение, что
играешь в старую игру <<Приключение>> (Adventure): <<Вы находитесь в
лабиринте из одинаковых извилистых коридоров>>. Например, вы можете
попробовать использовать \utility{xargs} для решения проблемы, так как
\utility{xargs} разделяет строки на части в соответствии с
ограничениями текущей системы:

{\footnotesize
\begin{verbatim}
compile_all:
    echo $(wildcard
           $(addsuffix /*.java,$(source_dirs))) | \
    xargs $(JAVAC)
\end{verbatim}
}

К сожалению, так мы просто переместили проблему ограничений из команды
\utility{javac} в команду \utility{echo}. Мы также не можем
использовать \utility{echo} или \utility{printf} для записи данных в
файл (предполагается, что компилятор может читать список файлов из
файла).

Нет, для решения этой проблемы нужно в первую очередь избежать
создания одного большого списка файлов. Вместо этого мы можем
просматривать по одному каталогу за раз, используя шаблоны командного
интерпретатора:

{\footnotesize
\begin{verbatim}
compile_all:
    for d in $(source_dirs); \
    do                       \
        $(JAVAC) $$d/*.java; \
    done
\end{verbatim}
}

Также можно использовать канал в \utility{xargs}, чтобы достигнуть
желаемого результата за меньшее количество вызовов компилятора:

{\footnotesize
\begin{verbatim}
compile_all:
    for d in $(source_dirs); \
    do                       \
        echo $$d/*.java;     \
    done |                   \
    xargs $(JAVAC)
\end{verbatim}
}

К сожалению, ни один из этих сценариев не обрабатывает должным образом
ошибки компиляции. Лучшим подходом является сохранение полного списка
файлов и последующая передача его компилятору, если, конечно,
компилятор поддерживает чтение аргументов из файла. Компилятор \Java{}
поддерживает эту возможность:

{\footnotesize
\begin{verbatim}
compile_all: $(FILE_LIST)
    $(JAVA) @$<

.INTERMEDIATE: $(FILE_LIST)
$(FILE_LIST):
    for d in $(source_dirs); \
    do                       \
        echo $$d/*.java;     \
    done > $@

\end{verbatim}
}

Обратите внимание на тонкую ошибку в цикле \command{for}. Если
какой-либо из каталогов не содержит исходных файлов \Java{}, строка
\filename{*.java} будет включена в список файлов и компилятор \Java{}
выдаст сообщение об ошибке: <<File not found>> (файл не найден). Мы
можем приказать \utility{bash} подставлять пустые строки на место
шаблонов, которым не соответствует ни один файл, использовав опцию
\command{nullglob}:

{\footnotesize
\begin{verbatim}
compile_all: $(FILE_LIST)
    $(JAVA) @$<

.INTERMEDIATE: $(FILE_LIST)
$(FILE_LIST):
    shopt -s nullglob;       \
    for d in $(source_dirs); \
    do                       \
        echo $$d/*.java;     \
    done > $@
\end{verbatim}
}

Многим проектам приходится создавать список файлов. Ниже представлен
макрос, содержащий сценарий \utility{bash}, создающий список файлов.
Первым аргументом является корневой каталог, пути всех найденных
файлов будут указываться относительно этого каталога. Вторым
параметром является список каталогов, в которых нужно искать файлы,
соответствующие шаблону. Третий и четвёртый аргументы опциональны и
содержат расширения интересующих файлов.

{\footnotesize
\begin{verbatim}
# $(call collect-names,root-dir,dir-list,
#        suffix1-opt,suffix2-opt)
define collect-names
  echo Making $@ from directory list...             
  cd $1;                                              \
  shopt -s nullglob;                                  \
  for f in $(foreach file,$2,'$(file)'); do           \
    files=( $$f$(if $3,/*.{$3$(if $4,$(comma)$4)}) ); \
    if (( $${#files[@]} > 0 ));                       \
    then                                              \
      printf '"%s"\n' $${files[@]};                   \
    else :; fi;                                       \
  done
endef
\end{verbatim}
}

Так выглядит шаблонное правило создания списка файлов изображений:

{\footnotesize
\begin{verbatim}
%.images:
    @$(call collect-names,$(SOURCE_DIR),$^,gif,jpeg) > $@
\end{verbatim}
}

Вычисление макроса скрыто с помощью модификатора \command{@},
поскольку сценарий достаточно велик, а причину для копирования и
вставки полученного кода найти трудно. Список каталогов указан в
реквизитах. После смены текущего каталога сценарий включает опцию
\texttt{nullglob}. Остаток макроса~--- цикл \emph{for}, осуществляющий
проход по всем каталогам, которые нужно обработать. Первое выражение
поиска файлов~--- это список слов, переданный в качестве второго
параметра (\variable{\${}2}). Сценарий экранирует слова в списке
файлов с помощью апострофа, так как они могут содержать символы,
имеющие для командного интерпретатора специальный смысл. В частности,
имена файлов в некоторых языках программирования (например, \Java{})
могут содержать символы доллара:

{\footnotesize
\begin{verbatim}
for f in $(foreach file,$2,'$(file)'); do
\end{verbatim}
}

Мы производим поиск файлов в каталоге, заполняя массив
\variable{files} результатами вычислений подстановок. Если полученный
массив содержит элементы, мы используем \function{printf} для того,
чтобы напечатать каждое слово на новой строке. Использование массива
позволяет макросу правильно обрабатывать пути, содержащие
пробелы. Возможность наличия пробелов в путях~--- это ещё одна причина,
по которой аргумент \function{printf} окружён кавычками.

Список файлов создаётся при помощи следующей строки:

{\footnotesize
\begin{verbatim}
files=( $$f$(if $3,/*.{$3$(if $4,$(comma)$4)}) );
\end{verbatim}
}

Переменная \variable{\$\$f}~--- это каталог или файл, переданный
макросу в составе аргумента. Следующее выражение~--- это функция
\function{if}, проверяющая третий аргумент на непустоту. Это один из
путей, который можно использовать для реализации необязательных
аргументов. Если третий аргумент пуст, четвёртый также подразумевается
пустым. В этом случае файл, переданный пользователем, должен быть
включён в список как есть. Это позволяет макросу строить списки
обычных файлов, для которых использование шаблонов не подходит. Если
третий аргумент не пуст, функция \function{if} добавляет к корневому
каталогу строку \texttt{/*\{\$3\}}. Если передан четвёртый аргумент,
после \variable{\$3} происходит вставка \variable{\$4}. Обратите
внимание на то, как происходит вставка запятой в шаблон. Поместив
символ запятой в переменную \GNUmake{}, мы можем незаметно передать её
в выражение, явное использование запятой было бы воспринято как
отделение \emph{then} части от \emph{else} части функции
\function{if}. Определение переменной \variable{comma} очевидно:

{\footnotesize
\begin{verbatim}
comma = ,
\end{verbatim}
}
 
Все рассмотренные циклы \function{for} зависели от пределов длины
командной строки, поскольку использовали шаблонные выражения. Разница
в том, что результат применения шаблона для поиска файлов в одном
каталоге имеет гораздо меньше шансов превысить предел.

Что будет, если какая-то переменная \GNUmake{} содержит длинный список
файлов? Чтож, тогда мы столкнулись с настоящей неприятностью. Я нашёл
лишь два пути передать длинную переменную \GNUmake{} в интерпретатор.
Первый подход~--- передавать содержимое переменной по частям,
используя фильтры, основанные на применении функции
\function{wordlist}:

{\footnotesize
\begin{verbatim}
compile_all:
    $(JAVAC) $(wordlist 1, 499, $(all-source-files))
    $(JAVAC) $(wordlist 500, 999, $(all-source-files))
    $(JAVAC) $(wordlist 1000, 1499, $(all-source-files))
\end{verbatim}
}

Второй путь~--- использовать функцию \function{filter}, однако в этом
случае результаты менее предсказуемы, поскольку число отбираемых
фильтром файлов может зависеть от числа слов, соответствующему
каждому из выбранных шаблонов. В следующем примере используются
шаблоны, основанные на алфавитном порядке:

{\footnotesize
\begin{verbatim}
compile_all:
    $(JAVAC) $(filter a%, $(all-source-files))
    $(JAVAC) $(filter b%, $(all-source-files))
\end{verbatim}
}

Ваши шаблоны могут использовать специальные свойства имён файлов.

Обратите внимание на то, как сложно автоматизировать этот процесс. Мы
могли бы попробовать использовать алфавитный подход совместно с циклом
\function{foreach}:

{\footnotesize
\begin{verbatim}
compile_all:
    $(foreach l,a b c d e ...,                 \
      $(if $(filter $l%, $(all-source-files)), \
        $(JAVAC) $(filter $l%, $(all-source-files));))
\end{verbatim}
}

Однако такой подход не работает. \GNUmake{} превратит этот сценарий в
одну строку текста, что только усугубит проблемы с длиной команд.
Вместо этого можно использовать \function{eval}:

{\footnotesize
\begin{verbatim}
compile_all:
    $(foreach l,a b c d e ...,                 \
      $(if $(filter $l%, $(all-source-files)), \
        $(eval                                 \
          $(shell                              \
            $(JAVAC) $(filter $l%, $(all-source-files));))))
\end{verbatim}
}

Этот вариант будет работать правильно, потому что функция
\function{eval} выполняет команду \function{shell} незамедлительно, и
результатом её вычисления является пустая строка. Таким образом,
результатом вычисления функции \function{foreach} является также
пустая строка. Проблема заключается в том, что проверка ошибок в этом
контексте не происходит, поэтому ошибки компиляции не будут переданы
\GNUmake{} напрямую.

Подход, основанный на использовании \function{wordlist} значительно
хуже. Из-за ограниченных возможностей \GNUmake{} в области численных
операций, применить эту технику в цикле не получится. В общем,
сколь-нибудь удовлетворительных техник обращения с огромными списками
файлов практически не существует.
