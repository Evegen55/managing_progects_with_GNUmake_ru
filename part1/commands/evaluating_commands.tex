%%--------------------------------------------------------------------
%% Evaluating commands
%%--------------------------------------------------------------------
\section{Выполнение команд}
\label{sec:evaluating_commands}

Обработка командного сценария происходит в четыре этапа: чтение кода,
подстановка переменных, вычисление выражений \GNUmake{} и выполнение
команд. Давайте посмотрим, как все эти этапы применяются к сложному
сценарию. Рассмотрим следующий (немного надуманный) \Makefile{}.
Приложение компонуется, затем от полученного исполняемого файла
отделяется таблица символов, после чего он сжимается при помощи
компрессора исполняемых файлов \utility{upx}:

{\footnotesize
\begin{verbatim}
# $(call strip-program, file)
define strip-program
  strip $1
endef

complex_script:
    $(CC) $^ -o $@
  ifdef STRIP
    $(call strip-program, $@)
  endif
    $(if $(PACK), upx --best $@)
    $(warning Final size: $(shell ls -s $@))
\end{verbatim}
}

Вычисление командных сценариев откладывается до того момента, когда
оно действительно потребуется, однако директивы \directive{ifdef}
обрабатывается сразу после их обнаружения. Поэтому \GNUmake{}
считывает команды сценария, игнорируя их содержимое и сохраняя каждую
строку, пока не обнаружит строку \command{ifdef STRIP}. \GNUmake{}
выполняет тест, и если переменная \variable{STRIP} не определена,
\GNUmake{} считывает и отбрасывает весь текст сценария, пока не
натолкнётся на закрывающую директиву \directive{endif}. После этого
\GNUmake{} считывает и сохраняет оставшуюся часть сценария.

Когда приходит время выполнения сценария, \GNUmake{} сначала сканирует
команды на наличие конструкций \GNUmake{}, требующих подстановки. После
подстановки макросов каждая строка сценария начинается с символа
табуляции. Вычисление макросов \emph{перед} выполнением команд может
привести к неожиданным результатам. Последняя строка в нашем сценарии
некорректна. Функции \function{shell} и \function{warning} выполняются
\emph{до} компоновки приложения. Поэтому команда \utility{ls} будет
выполнена до того, как целевой файл будет собран. Это объясняет
<<неправильный>> порядок выполнения, который мы наблюдали в разделе
<<\nameref{sec:parsing_commands}>>.

Также заметим, что строка \command{ifdef STRIP} выполняется во время
чтения \Makefile{}'а, однако строка \command{\$(if...)} вычисляется
непосредственно перед выполнения сценария сборки цели
\target{complex\_script}. Использование функции \function{if}
допускает написание более гибких сценариев, поскольку предоставляет
больше возможностей для контроля определения переменных, однако такой
подход не очень хорошо приспособлен для управления большими блоками
текста.

Как показывает наш пример, всегда очень важно обращать внимание на то,
какая программа вычисляет выражение (т.е. \GNUmake{} или командный
интерпретатор), и когда именно это вычисление происходит:

{\footnotesize
\begin{verbatim}
$(LINK.c) $(shell find                              \
            $(if $(ALL),$(wildcard core ext*),core) \
              -name '*.o')
\end{verbatim}
}

Это запутанный командный сценарий компоновки множества объектных
файлов. Порядок вычисления операций таков (в скобках указана
программа, выполняющая соответствующую операцию):

\begin{enumerate}
\item Вычисление \variable{\$ALL} (\GNUmake{}).
\item Вычисление \function{if}  (\GNUmake{}).
\item Вычисление \function{wildcard} в предположении, что
  \variable{ALL} содержит непустое значение (\GNUmake{}).
\item Вычисление \function{shell} (\GNUmake{}).
\item Вычисление \utility{find} (\utility{sh}).
\item После завершения подстановок и вычисления конструкций
  \GNUmake{}, происходит выполнение команды компоновки
  (\utility{sh}).
\end{enumerate}
