%%--------------------------------------------------------------------
%% Build-in functions
%%--------------------------------------------------------------------
\section{Встроенные функции}
\label{sec:built_in_func}

\index{Функции!встроенные}
Как только вы начнёте использовать переменные для более сложных
манипуляций, нежели хранение констант, вы обнаружите потребность
манипулировать их содержимым. У вас есть такая возможность. GNU
\GNUmake{} имеет несколько десятков встроенных функций для работы с
переменными и их содержимым. Все функции попадают в одну из следующих
категорий: функции для анализа и подстановки строк; функции для
обработки имён файлов; функции управления выполнением; функции,
определяемые пользователем и вспомогательные функции.

Но сначала рассмотрим синтаксис обращения к функций. Вызов любой
функции имеет следующую форму:

{\footnotesize
\begin{alltt}
\$(\emph{имя-функции} \emph{аргумент\,\subi{1}} [, \emph{аргумент\,\subi{2}}, ...])
\end{alltt}
}

Сначала указывается \variable{\${}(}, затем следует имя функции, за
которым следуют аргументы. Начальный пробел у первого аргумента
вырезается, остальные аргументы подставляются со всеми начальными (и,
конечно, внутренними и оконечными) пробелами.  Аргументы функций
разделяются запятыми, таким образом, при вызове функции с одним
аргументом запятые не требуются, при вызове функции с двумя
аргументами используется одна запятая, и так далее. Многие функции
принимают один аргумент, интерпретируя его как последовательность
слов, разделённых пробелами. Для таких функций пробел считается
разделителем слов и попросту игнорируется, если таковым не является.

Мне нравится использовать пробелы. Они делают код более читабельным и
удобным для поддержки. Поэтому я буду использовать пробелы везде, где
это сойдёт мне с рук. Однако иногда пробелы в списке аргументов или
определении переменной могут мешать корректному выполнению кода.
Когда это случается, у вас не остаётся другого выбора, кроме как
убрать лишний пробел. Мы уже видели один пример, в котором лишний
пробел случайно попал в шаблон поиска программы \utility{grep}.  Мы
будем указывать, где пробелы могут вызвать проблемы, при разборе
конкретных примеров.

Многие функции \GNUmake{} принимают в качестве аргумента шаблон.
Этот шаблон следует тому же синтаксису, что и шаблоны, используемые в
шаблонных правилах (см. раздел <<\nameref{sec:pattern_rules}>>
главы~\ref{chap:rules}). Шаблон может содержать один символ
\command{\%{}} с некоторым суффиксом или префиксом (или и тем, и
другим). Символ \command{\%{}} соответствует нулю или более
произвольных символов. Шаблону может соответствовать только вся
строка, но не подмножество символов внутри строки.  Позже мы
проиллюстрируем это коротким примером. Символ \command{\%{}}
опционален и при желании его можно опустить.

%---------------------------------------------------------------------
% String functions
%---------------------------------------------------------------------
\subsection{Строковые функции}
\label{sec:str_func}

Б\'{о}льшая часть функций \GNUmake{} переводит текст из одной формы в
другую, однако в этом разделе мы рассмотрим только те из них, которые
предоставляют наиболее мощную функциональность по манипулированию
строками.

Одной из наиболее общих операций над строками в \GNUmake{} является
выделение подмножества файлов из списка. В командных сценариях
для этого обычно используется \utility{grep}. В \GNUmake{} мы
можем использовать функции \function{filter}, \function{filter-out}
и \function{findstring}.

\begin{description}
%---------------------------------------------------------------------
% filter
%---------------------------------------------------------------------
\item[\texttt{\$(filter \emph{шаблон}...,\emph{текст})}] \hfill \\
\index{Функции!встроенные!filter@\function{filter}}
Функция \function{filter} интерпретирует аргумент \ItalicMono{текст}
как последовательность слов, разделённых пробелами и возвращает список
тех из них, которые соответствуют \ItalicMono{шаблону}. Например, для
для сборки библиотеки пользовательского интерфейса, мы можем выбрать
все объектные файлы из подкаталога \filename{ui}. В следующем примере
мы извлечём из списка всех имён фалов проекта имена, начинающиеся с
\filename{ui/} и заканчивающиеся \filename{.o}. Символ \texttt{\%{}}
соответствует любому числу символов между префиксом и суффиксом:

{\footnotesize
\begin{verbatim}
$(ui_library): $(filter ui/%.o,$(objects))
    $(AR) $(ARFLAGS) $@ $^
\end{verbatim}
}

Функция \function{filter} может принимать несколько шаблонов,
разделённых пробелами. Как уже упоминалось ранее, для того, чтобы
некоторое слово было включено в выходной список, оно должно
соответствовать шаблону целиком. Рассмотрим следующий пример:

{\footnotesize
\begin{verbatim}
words := he the hen other the%

get-the:
    @echo he matches:   $(filter he,   $(words))
    @echo %he matches:  $(filter %he,  $(words))
    @echo he% matches:  $(filter he%,  $(words))
    @echo %he% matches: $(filter %he%, $(words))
\end{verbatim}
}

Когда мы запустим \GNUmake{}, вывод будет следующим:

{\footnotesize
\begin{alltt}
\$ \textbf{make}

he matches: he
\%he matches: he the
he\% matches: he hen
\%he\% matches: the\%
\end{alltt}
}

Как видите, первый шаблону соответствует только слово \command{he},
так как на выход \function{filter} попадают только слова,
соответствующие шаблону целиком. Остальным шаблонам соответствует
слово \command{he} и слова, содержащие \command{he} в нужной позиции.

Шаблон может содержать только один метасимвол \command{\%{}}.
Дополнительные символы \command{\%} воспринимаются как литералы.

Может показаться странным, что функция \function{filter} не может
находить подстроки внутри слова или принимать более одного
метасимвола.  Во многих случаях вам будет не хватать подобной
функциональности.  Однако вы можете реализовать нечто похожее с
помощью циклов и условных операторов. Позже мы рассмотрим, как это
можно сделать.

%---------------------------------------------------------------------
% filter-out
%---------------------------------------------------------------------
\item[\texttt{\$(filter-out \emph{шаблон}...,\emph{текст})}] \hfill \\
\index{Функции!встроенные!filter-out@\function{filter-out}}
Функция \function{filter-out} осуществляет действие, обратное действию
функции \function{filter}, отбирая слова, не соответствующие шаблону.
В следующем примере мы отсеим все заголовочные файлы \Clang{}:

{\footnotesize
\begin{verbatim}
all_source := count_words.c counter.c lexer.l \
              counter.h lexer.h
to_compile := $(filter-out %.h, $(all_source))
\end{verbatim}
}

%---------------------------------------------------------------------
% findstring
%---------------------------------------------------------------------
\item[\texttt{\$(findstring \emph{строка},\emph{текст})}] \hfill \\
\index{Функции!встроенные!findstring@\function{findstring}}
Эта функция ищет вхождение \ItalicMono{строки} в \ItalicMono{тексте}.
Если вхождение обнаружено, функция возвращает \ItalicMono{строку},
иначе возвращается пустая строка.

Поначалу может показаться, что эта функция подобна функциональности
поиска подстрок программы \utility{grep} (ранее мы выдвигали на эту
роль функцию \function{filter}), но это не так. Первое и самое важное
отличие заключается в том, что \function{findstring} возвращает только
искомую подстроку, а не всё слово, в которое эта подстрока входит.
Вторым отличием является отсутствие возможности использования
метасимвола \command{\%} (если поместить этот символ в
\ItalicMono{строку}, он будет восприниматься как литерал).

Наиболее часто эта функция используется совместно с функцией
\function{if}, обсуждаемой дальше в этой главе. Однако есть одна
ситуация, в которой функция \function{findstring} полезна сама по
себе.

Предположим, что у нас есть несколько деревьев каталогов в файловой
системе, имеющих сходную структуру, например, каталоги исходного кода
приложения, исходного кода исполняющей среды, бинарных файлов с
таблицей символов и бинарных файлов, скомпилированных с флагами
оптимизации.  Скорее всего, в ваших сценариях вам потребуется
узнавать, внутри какого именно дерева вы находитесь (не получая при
этом относительный путь от корневого каталога проекта).  Вот набросок
кода для получения этой информации:

{\footnotesize
\begin{verbatim}
find-tree:
    # PWD = $(PWD)
    # $(findstring /test/book/admin,$(PWD))
    # $(findstring /test/book/bin,$(PWD))
    # $(findstring /test/book/dblite_0.5,$(PWD))
    # $(findstring /test/book/examples,$(PWD))
    # $(findstring /test/book/out,$(PWD))
    # $(findstring /test/book/text,$(PWD))
\end{verbatim}
}

Каждая строка начинается с символа табуляции и символа комментария
\utility{shell}, поэтому <<выполняется>> в отдельном дочернем процессе
командного интерпретатора, как и обычные команды. Командный
интерпретатор <<Bourne Again Shell>>, \utility{bash}, и многие
родственные ему интерпретаторы просто проигнорируют эти строки. Это
более распространённый способ распечатки результатов вычисления
конструкций \GNUmake{}, чем использование команды \command{@echo}. Вы
можете добиться того же эффекта, если будете использовать более
переносимый оператор командного интерпретатора \command{:}, однако
оператор \command{:} осуществляет перенаправление потоков. Таким
образом, команда, содержащая подстроку \command{> слово}, в качестве
побочного эффекта создаст файл \command{слово}. После запуска
предыдущего примера мы получим следующий вывод:

{\footnotesize
\begin{alltt}
\${} \textbf{make}
\begin{verbatim}
# PWD = /test/book/out/ch03-findstring-1
# 
# 
# 
# 
# /test/book/out
#
\end{verbatim}
\end{alltt}
}

Как вы можете видеть, каждый тест переменной \variable{\${}(PWD)}
возвращал пустую строку, пока не встретился нужный каталог. Как уже
было замечено, этот код лишь демонстрирует возможности
\function{findstring} и может быть использован для определения
текущего дерева каталогов.
\end{description}

Существует две функции для поиска и замены строк:

\begin{description}
%---------------------------------------------------------------------
% subst
%---------------------------------------------------------------------
\item[\texttt{\${}(subst \emph{строка-поиска},\emph{строка-замены},\emph{текст})}] \hfill \\
\index{Функции!встроенные!subst@\function{subst}}
Это функция для простого (не содержащего шаблонов) поиска и замены.
Одно из наиболее частых применений этой функции~--- замена суффиксов в
списке имён файлов:

{\footnotesize
\begin{verbatim}
sources := count_words.c counter.c lexer.c
objects := $(subst .c,.o,$(sources))
\end{verbatim}
}

В предыдущем примере все вхождения строки <<\filename{.c}>> в значении
переменной \variable{\${}(sources)} будут заменены строкой
<<\filename{.o}>>, или, более \'{о}бщно, все вхождения
\ItalicMono{строки-поиска} будут заменены \ItalicMono{строкой-замены}.

Эта функция также является примером ситуации, когда пробелы в списке
аргументов функции имеют значение. Обратите внимание, что после
запятых нет пробелов. Если бы мы написали такой код:

{\footnotesize
\begin{verbatim}
sources := count\_words.c counter.c lexer.c
objects := $(subst .c, .o, $(sources))
\end{verbatim}
}

{\flushleft (обратите внимание на пробелы после запятых), то значением
переменной \variable{\${}(objects)} стала бы следующая строка:}

{\footnotesize
\begin{verbatim}
count_words .o counter .o lexer .o
\end{verbatim}
}

Это не совсем то, что мы хотим. Проблема заключается в том, что пробел
перед аргументом \command{.o} является частью
\ItalicMono{строки-замены}, и поэтому попадает в результирующий текст.
Пробел перед аргументом \command{.c} не вызовет проблем, потому что
\GNUmake{} пропускает пробелы перед первым аргументом. Пробел перед
\variable{\${}(sources)} также не вызовет проблемы, поскольку
переменная \variable{\${}(objects)} скорее всего будет использоваться
как простой аргумент командной строки.  Однако я стараюсь никогда не
смешивать различные стили расстановки пробелов при вызове функций,
даже если это приводит к корректным результатам:

{\footnotesize
\begin{verbatim}
# Пожалуй, не самая удачная расстановка пробелов.
objects := $(subst .c,.o, $(source))
\end{verbatim}
}

Заметим, что \function{subst} не понимает имён файлов или их
суффиксов, только последовательности символов. Если какой-то файл с
исходным кодом содержит внутри имени подстроку \command{.c}, то она
будет заменена.  Например, имя файла \filename{car.cdr.c} будет
преобразовано в \filename{car.odr.o}. Вполне вероятно, что это не то,
что вы ожидали.

В разделе <<\nameref{sec:auto_dep_gen}>> главы~\ref{chap:rules} мы
обсуждали составление зависимостей. Последний пример \Makefile{}'а
этого раздела использовал \function{subst} следующим образом:

{\footnotesize
\begin{verbatim}
VPATH = src include
CPPFLAGS = -I include
SOURCES = count_words.c \
          lexer.c       \
          counter.c
count_words: counter.o lexer.o -lfl
count_words.o: counter.h
counter.o: counter.h lexer.h
lexer.o: lexer.h
include $(subst .c,.d,$(SOURCES))

%.d: %.c
    $(CC) -M $(CPPFLAGS) $< > $@.$$$$;                  \
    sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
    rm -f $@.$$$$
\end{verbatim}
}

Функция \function{subst} использована для преобразования списка файлов
с исходным кодом в список файлов зависимостей. Поскольку файлы
зависимостей появляются в качестве директивы \directive{include}, они
рассматриваются как реквизиты и создаются при помощи шаблонного
правила \target{\%{}.d}.

%---------------------------------------------------------------------
% patsubst
%---------------------------------------------------------------------
\item[\texttt{\${}(patsubst \emph{шаблон-поиска},\emph{шаблон-замены},\emph{текст})}] \hfill \\
\index{Функции!встроенные!patsubst@\function{patsubst}}
Эта функция отличается от предыдущей тем, что допускает использование
шаблонов для поиска и замены символов. Шаблон, как обычно, может
содержать один и только один метасимвол \verb|%|. Метасимвол \verb|%|
в \ItalicMono{строке-замены} заменяется соответствующим текстом. Важно
помнить, что \ItalicMono{текст} должен полностью соответствовать
\ItalicMono{шаблону-поиска}. Например, следующий пример удалит только
последний (не каждый) слэш в \ItalicMono{тексте}:

{\footnotesize
\begin{verbatim}
strip-trailing-slash = $(patsubst %/,%,$(directory-path))
\end{verbatim}
}

\index{Подстановочная ссылка}
Использование \newword{подстановочной ссылки (substitution reference)}
является переносимым способом осуществления такой замены. Синтаксис
использования подстановочной ссылки таков:

{\footnotesize
\begin{alltt}
\${}(\emph{имя-переменной}:\emph{шаблон-поиска}=\emph{шаблон-замены})
\end{alltt}
}

\ItalicMono{Шаблон-поиска} может быть простой строкой, в этом случае
он заменяется на \ItalicMono{шаблон-замены} в конце каждого слова, то
есть когда за ним следует пробел или конец значения переменной.
\ItalicMono{Шаблон-поиска} может также содержать символ \command{\%},
в этом случае поиск и замена осуществляется по тем же правилам, что и
для функции \function{patsubst}. Я нахожу этот синтаксис более трудным
для чтения и восприятия по сравнению с \function{patsubst}.
\end{description}

Как мы уже видели, переменные часто состоят из списка слов. Ниже
представлены функции для выбора слов из списка, подсчёта длины списка
и т.д. Как и в случае остальных функций \GNUmake{}, слова в списке
разделяются пробелами.

\begin{description}
%---------------------------------------------------------------------
% words
%---------------------------------------------------------------------
\item[\texttt{\${}(words \emph{список})}] \hfill \\
\index{Функции!встроенные!words@\function{words}}
Функция, возвращающая число слов в \ItalicMono{списке}.

{\footnotesize
\begin{verbatim}
CURRENT_PATH := $(subst /, ,$(HOME))
words:
    @echo Мой домашний каталог содержит \
	$(words $(CURRENT_PATH)) подкаталогов.
\end{verbatim}
}

Эта функция имеет множество применений, однако для того, чтобы
эффективно её использовать, нам нужно изучить ещё несколько функций.

%---------------------------------------------------------------------
% word 
%---------------------------------------------------------------------
\item[\texttt{\${}(word \emph{n},\emph{список})}] \hfill \\
\index{Функции!встроенные!words@\function{words}}
Эта функция возвращает слово, находящееся в \ItalicMono{списке} под
номером \ItalicMono{n}, первое слово списка имеет номер 1. Если
\ItalicMono{n} больше числа слов в \ItalicMono{тексте}, функция
возвращает пустую строку.

{\footnotesize
\begin{verbatim}
version_list  := $(subst ., ,$(MAKE_VERSION))
minor_version := $(word 2, $(version_list))
\end{verbatim}
}

Переменная \variable{MAKE\_VERSION} является стандартной переменной
(см. раздел <<\nameref{sec:std_make_vars}>> главы~\ref{chap:vars}). Вы
можете получить последнее слово в списке следующим образом:

{\footnotesize
\begin{verbatim}
current := $(word $(words $(MAKEFILE_LIST)),\
                          $(MAKEFILE_LIST))
\end{verbatim}
}

Такая конструкция вернёт последний прочитанный \Makefile{}.

%---------------------------------------------------------------------
% firstword
%---------------------------------------------------------------------
\item[\texttt{\${}(firstword \emph{список})}] \hfill \\
\index{Функции!встроенные!firstword@\function{firstword}}
Эта функция возвращает первое слово в \ItalicMono{списке}.
Её действие эквивалентно вызову \texttt{\${}(word 1,\emph{список})}.

{\footnotesize
\begin{verbatim}
version_list  := $(subst ., ,$(MAKE_VERSION))
major_version := $(firstword $(version_list))
\end{verbatim}
}

%---------------------------------------------------------------------
% lastword 
%---------------------------------------------------------------------
\item[\texttt{\${}(lastword \emph{список})}] \hfill \\
\index{Функции!встроенные!lastword@\function{lastword}}
Эта функция, доступная в версиях GNU \GNUmake{} 3.81 и выше,
представляет дополнение к функции \function{firstword}. Она возвращает
последнее слово в \ItalicMono{списке}, что функционально эквивалентно
следующему выражению:

{\footnotesize
\begin{alltt}
\${}(word \${}(words \emph{список}),\emph{список})
\end{alltt}
}

%---------------------------------------------------------------------
% wordlist
%---------------------------------------------------------------------
\item[\texttt{\${}(wordlist \emph{номер-начала},\emph{номер-конца},\emph{список})}] \hfill \\
\index{Функции!встроенные!wordlist@\function{wordlist}}
Эта функция возвращает слова, имеющие в \ItalicMono{списке} номера с
\ItalicMono{номер-начала} по \ItalicMono{номер-конца} включительно.
Как и в функции \function{word}, первое слово имеет номер 1. Если
\ItalicMono{номер-начала} больше числа слов в \ItalicMono{списке}, то
функция вернёт пустую строку. Если \ItalicMono{номер-конца} больше
числа слов в \ItalicMono{списке}, функция вернёт всё слова начиная с
\ItalicMono{номера-начала}.

{\footnotesize
\begin{verbatim}
# $(call uid_gid, user-name)
uid_gid = $(wordlist 3, 4,   \
            $(subst :, ,     \
              $(shell grep "^$1:" /etc/passwd)))
\end{verbatim}
}
\end{description}

%---------------------------------------------------------------------
% Important miscellaneous functions
%---------------------------------------------------------------------
\subsection{Некоторые важные функции}
\label{sec:imp_misc_func}

Перед тем, как мы рассмотрим функции для работы с именами файлов,
следует ввести две чрезвычайно полезные функции: \function{sort} и
\function{shell}.

\begin{description}
%---------------------------------------------------------------------
% sort
%---------------------------------------------------------------------
\item[\texttt{\${}(sort \emph{список})}] \hfill \\
\index{Функции!встроенные!sort@\function{sort}}
Эта функция сортирует слова в \ItalicMono{списке}, удаляя дубликаты.
Результирующий список содержит уникальные слова из \ItalicMono{списка}
в лексикографическом порядке, разделённые одним пробелом. В дополнение
функция \function{sort} удаляет начальные и конечные пробелы.

{\footnotesize
\begin{alltt}
\${} \textbf{make -f- <<< 'x:;@echo =\${}(sort d b s d t )='}
=b d s t=
\end{alltt}
}

Функция \function{sort}, разумеется, реализована непосредственно
\GNUmake{} и потому не поддерживает опций стандартной утилиты
\utility{sort}. Эта функция оперирует лишь своим аргументом, обычно
это переменная или результат выполнения другой функции.

%---------------------------------------------------------------------
% shell
%---------------------------------------------------------------------
\item[\texttt{\${}(shell \emph{команда})}] \hfill \\
\index{Функции!встроенные!shell@\function{shell}}
Функция \function{shell} принимает на вход один аргумент, который
подвергается вычислению (как аргументы всех функций) и передаётся в
дочерний процесс командного интерпретатора для выполнения.
стандартный вывод команды считывается и возвращается в качестве
значения функции. Последовательности символов новой строки заменяются
одним пробелом, начальные и конечные символы новой строки удаляются.
Данные из стандартного потока ошибок не возвращаются, так же как и код
возврата команды.

{\footnotesize
\begin{verbatim}
stdout := $(shell echo normal message)
stderr := $(shell echo error message 1>&2)
shell-value:
    # $(stdout)
    # $(stderr)
\end{verbatim}
}

Как вы можете видеть, сообщения из стандартного потока ошибок попадают
на терминал, и потому не включаются в вывод функции \function{shell}:

{\footnotesize
\begin{alltt}
\${} \textbf{make}
error message
# normal message
#
\end{alltt}
}

Ниже приведён пример использования этой функции для создания набора
каталогов:

{\footnotesize
\begin{verbatim}
REQUIRED_DIRS = ...
_MKDIRS := $(shell for d in $(REQUIRED_DIRS);  \
             do                                \
                 [[ -d $$d ]] || mkdir -p $$d; \
             done)
\end{verbatim}
}

Часто \Makefile{} можно сделать проще, если все каталоги, в которые
\GNUmake{} осуществляет запись файлов, гарантированно существуют до
выполнения первой команды. Предыдущая переменная содержит код,
создающий требуемые каталоги при помощи цикла \command{for} командного
интерпретатора \utility{bash}. Двойные квадратные скобки являются
стандартным синтаксисом \utility{bash}, они работают почти также, как
программа \utility{test}. Отличие заключается в том, что внутри
двойных квадратных скобок не осуществляется разделение на слова и
подстановка путей. Поэтому если имя файла содержит пробел, тест будет
выполнен успешно (причём имя переменной не придётся заключать в
кавычки). Поскольку мы поместили определение переменной
\variable{\_MKDIRS} в начале \Makefile{}'а, мы можем быть уверены в
том, что её вычисление произойдёт до того, как другие команды или
вычисления переменных обратятся к каталогам. Значение
\variable{\_MKDIRS} для нас не важно и никогда не будет
использоваться.

Поскольку функция \function{shell} может быть использована для запуска
произвольной внешней программы, вам следует использовать её осторожно.
В частности, вам следует учитывать различия между простыми и
рекурсивными переменными.

{\footnotesize
\begin{verbatim}
START_TIME  := $(shell date)
CURRENT_TIME = $(shell date)
\end{verbatim}
}

Определение переменной \variable{START\_TIME} приводит к выполнению
программы \utility{date}. Переменная \variable{CURRENT\_DATE} будет
выполнять \utility{date} каждый раз при необходимости использования
значения в \Makefile{}'е.
\end{description}

Теперь у нас достаточно инструментов для того, чтобы писать довольно
интересные функции. Ниже приведён пример функции, которая проверяет,
содержит ли её аргумент одинаковые слова.

{\footnotesize
\begin{verbatim}
# $(call has-duplicates, word-list)
has-duplicates = $(filter                \
                   $(words $1),          \
                   $(words $(sort $1)))
\end{verbatim}
}

Мы считаем слова в первоначальном списке и в списке, из которого были
удалены все дубликаты, а затем <<сравниваем>> эти два числа.
\GNUmake{} не содержит функций, принимающий числа в качестве
аргументов, все аргументы воспринимаются как строки. Поэтому для того,
чтобы сравнить два числа, мы должны сравнить их как строки. Наиболее
простым способом сделать это является применение функции
\function{filter}. Мы <<ищем>> одно число в другом. Функция
\function{has-duplicates} вернёт непустую строку только в том случае,
если её аргумент содержит одинаковые слово.

А вот простой способ создать файл с временн\'{о}й меткой в имени:

{\footnotesize
\begin{verbatim}
RELEASE_TAR := mpwm-$(shell date +%F).tar.gz
\end{verbatim}
}

Это выражение порождает следующую строку:

{\footnotesize
\begin{verbatim}
mpwm-2003-11-11.tar.gz
\end{verbatim}
}

Мы могли бы достигнуть того же эффекта, заставив \utility{date}
проделать немного больше работы:

{\footnotesize
\begin{verbatim}
RELEASE_TAR := $(shell date +mpwm-%F.tar.gz)
\end{verbatim}
}

Следующая функция может быть использована для получения полного имени
\Java{}-класса из относительного пути (возможно, начиная с каталога
\filename{com}).

{\footnotesize
\begin{verbatim}
\# $(call file-to-class-name, file-name)
file-to-class-name := $(subst /,.,$(patsubst %.java,%,$1))
\end{verbatim}
}

Этот же эффект может быть достигнут при помощи следующего кода:

{\footnotesize
\begin{verbatim}
# $(call file-to-class-name, file-name)
file-to-class-name := $(subst /,.,$(subst .java,,$1))
\end{verbatim}
}

Мы можем использовать предыдущий пример для вызова классов \Java{}:

{\footnotesize
\begin{verbatim}
CALIBRATE_ELEVATOR := com/wonka/CalibrateElevator.java

calibrate:
    $(JAVA) $(call file-to-class-name,$(CALIBRATE_ELEVATOR))
\end{verbatim}
}

Если переменная \variable{\${}(sources)} содержит имена каталогов,
содержащих каталог \filename{com}, их можно убрать при помощи
следующей функции (корень дерева каталогов должен быть передан в
качестве первого аргумента\footnote{%
Существуют соглашения относительно структуры каталогов исходного кода
\Java{}: все классы должны быть объявлены в пакете, содержащем
доменное имя разработчика, записанное в обратном порядке (сначала
следуют домены более высокого уровня), а структура каталогов отражает
структуру пакетов. Однако довольно часто можно встретить подобную
структуру каталогов: \filename{root-dir/com/company-name/dir} (прим.
автора).}):

{\footnotesize
\begin{verbatim}
# $(call file-to-class-name, root-dir, file-name)
file-to-class-name := $(subst /,.,                 \
                        $(subst .java,,            \
                          $(subst $1/,,$2)))
\end{verbatim}
}

Функции, подобные этой, обычно легче понять, если читать их изнутри.
Начиная с внутреннего вызова \function{subst}, функция удаляет строку
\texttt{\${}1/}, затем удаляет строку \command{.java} и, наконец,
заменяет все слэши точками.

%---------------------------------------------------------------------
% Filename functions
%---------------------------------------------------------------------
\subsection{Функции для работы с файлами}
\label{sec:file_func}

Создатели \Makefile{}'ов тратят значительную часть времени на
осуществление обработки файлов. Поэтому неудивительно, что \GNUmake{}
содержит так много функций для облегчения этой задачи.

\begin{description}
%---------------------------------------------------------------------
% wildcard
%---------------------------------------------------------------------
\item[\texttt{\${}(wildcard \emph{шаблон} ...)}] \hfill \\
\index{Функции!встроенные!wildcard@\function{wildcard}}
Шаблоны были рассмотрены в главе~\ref{chap:rules} в контексте целей,
реквизитов и командных сценариев. Но что, если мы хотим получить эту
функциональность в другом контексте, например, в контексте определения
переменной? Конечно, мы могли бы использовать функцию \function{shell}
для подстановки шаблона с помощью дочернего процесса командного
интерпретатора, однако это будет очень неэффективным решением, если
подобная операция будет осуществляться достаточно часто.
Альтернативным подходом является использование функции
\function{wildcard}:

{\footnotesize
\begin{verbatim}
sources := $(wildcard *.c *.h)
\end{verbatim}
}

Функция \function{wildcard} принимает список шаблонов в качестве
аргумента и производит поиск файлов, соответствующих хотя бы одному
шаблону\footnote{%
Руководство пользователя GNU \GNUmake{} 3.80 почему-то умалчивает о
возможности использования нескольких шаблонов (прим. автора).}.
Если не обнаруживается файлов, соответствующих хотя-бы одному
шаблону, функция возвращает пустую строку. Как и в случае целей и
реквизитов, в шаблонах могут использоваться стандартные метасимволы
\command{\~}, \command{*}, \command{?}, \command{[...]},
\command{[\^\,...]}.

Другим применением функции \function{wildcard} является проверка
существования файлов в условных выражениях. Довольно часто встречается
использование \function{wildcard} с аргументом, не содержащим
метасимволов, совместно с функцией \function{if}. Например, в
следующем отрывке переменная \variable{dot-emacs-exists} будет
содержать непустое значение только в том случае, если домашний каталог
текущего пользователя содержит файл \filename{.emacs}:

{\footnotesize
\begin{verbatim}
dot-emacs-exists := $(wildcard ~/.emacs)
\end{verbatim}
}

%---------------------------------------------------------------------
% dir
%---------------------------------------------------------------------
\item[\texttt{\${}(dir \emph{список} ...)}] \hfill \\
\index{Функции!встроенные!dir@\function{dir}}
Функция \function{dir} возвращает каталог для каждого файла из
\ItalicMono{списка}. Следующее выражение вернёт все каталоги,
содержащие исходные файлы \Clang{}:

{\footnotesize
\begin{verbatim}
source-dirs = $(sort                             \
                $(dir                            \
                  $(shell find . -name '*.c')))
\end{verbatim}
}

Программа \utility{find} вернёт список всех файлов с исходным кодом,
функция \function{dirs} отсечёт имя файла, оставив лишь название
соответствующего каталога, а функция \function{sort} удалит
повторяющиеся каталоги. Заметим, что переменная \variable{source-dirs}
объявлена как простая для избежания повторного вызова \utility{find}
при каждом обращении к ней (предполагается, что файлы с исходным кодом
не будут спонтанно появляться и исчезать во время выполнения
\Makefile{}'а).  Ниже приведён пример функции, требующей рекурсивной
переменной:

{\footnotesize
\begin{verbatim}
# $(call source-dirs, dir-list)
source-dirs = $(sort                             \
                $(dir                            \
                  $(shell find $1 -name '*.c')))
\end{verbatim}
}

Эта версия принимает в качестве аргумента список каталогов для поиска
с пробелом в качестве разделителя. Первым аргументом программы
\utility{find} является список каталогов для поиска. Окончания списка
каталогов распознаётся благодаря символу тире, содержащемуся в
названии следующего аргумента\footnote{ Это одна из возможностей
\utility{find}, о которых я не знал в течении десятилетий! (прим.
автора)}.

%---------------------------------------------------------------------
% notdir
%---------------------------------------------------------------------
\item[\texttt{\${}(notdir \emph{список} ...)}] \hfill \\
\index{Функции!встроенные!notdir@\function{notdir}}
Функция \function{notdir} возвращает имена файлов для заданного списка
путей. Ниже приведён пример вычисления имени \Java{}-класса по
названию файла с его исходным кодом:

{\footnotesize
\begin{verbatim}
# $(call get-java-class-name, file-name)
get-java-class-name = $(notdir $(subst .java,,$1))
\end{verbatim}
}

Существует много примеров совместного применения функций
\function{dir} и \function{notdir} для получения желаемого результата.
Предположим, что некоторый командный сценарий должен выполняться в том
же каталоге, что и файл, создаваемый этим сценарием.

{\footnotesize
\begin{verbatim}
$(OUT)/myfile.out: $(SRC)/source1.in $(SRC)/source2.in
    cd $(dir $@); \
    generate-myfile $^ > $(notdir $@)
\end{verbatim}
}

\index{Переменные!автоматические!\${}"@@\variable{\$"@}}
Автоматическая переменная \variable{\${}@}, представляющая имя цели,
может подвергаться декомпозиции для получения имени каталога цели и
названия файла цели по-отдельности. Если \variable{OUT} содержит
абсолютный путь, вовсе не обязательно использовать функцию
\function{notdir}, однако её применение сделает вывод \GNUmake{} более
удобным для чтения.

Ещё одним способом декомпозиции имени файла является использование
\index{Переменные!автоматические!\${}("@D)@\variable{\$("@D)}}
\index{Переменные!автоматические!\${}("@F)@\variable{\$("@F)}}
переменных \variable{\${}(@D)} и \variable{\${}(@F)}, рассмотренных в
разделе <<\nameref{sec:automatic_vars}>> главы~\ref{chap:rules}.

%---------------------------------------------------------------------
% suffix
%---------------------------------------------------------------------
\item[\texttt{\${}(suffix \emph{список} ...)}] \hfill \\
\index{Функции!встроенные!suffix@\function{suffix}}
Функция \function{suffix} возвращает суффикс (расширение) каждого
файла в \ItalicMono{списке}. Ниже приведён пример функции,
проверяющей, все ли слова в списке имеют одинаковый суффикс:

{\footnotesize
\begin{verbatim}
# $(call same-suffix, file-list)
same-suffix = $(filter 1,$(words $(sort $(suffix $1))))
\end{verbatim}
}

Наиболее часто функция \function{suffix} применяется в условных
выражениях совместно с функцией \function{findstring}.

%---------------------------------------------------------------------
% basename
%---------------------------------------------------------------------
\item[\texttt{\${}(basename \emph{список} ...)}] \hfill \\
\index{Функции!встроенные!basename@\function{basename}}
Функция \function{basename} является дополнением к \function{suffix}.
Она возвращает имя файла без суффикса, оставляя нетронутыми любые
начальные компоненты имени файла. Вот пример альтернативной реализации
функций \function{file-to-class} и \function{get-java-class-name} с
использованием функции \function{basename}:

{\footnotesize
\begin{verbatim}
# $(call file-to-class-name, root-directory, file-name)
file-to-class-name := $(subst /,.,           \
                        $(basename           \
                          $(subst $1/,,$2)))

# $(call get-java-class-name, file-name)
get-java-class-name = $(notdir $(basename $1))
\end{verbatim}
}

%---------------------------------------------------------------------
% addsuffix
%---------------------------------------------------------------------
\item[\texttt{\${}(addsuffix \emph{суффикс},\emph{список} ...)}] \hfill \\
\index{Функции!встроенные!addsuffix@\function{addsuffix}}
Функция \function{addsuffix} добавляет заданный \ItalicMono{суффикс} к
имени каждого файла в \ItalicMono{списке}. В качестве
\ItalicMono{суффикса} может выступать произвольная строка. Ниже
приведён пример функции для поиска всех файлов из \variable{PATH},
соответствующих заданному шаблону:

{\footnotesize
\begin{verbatim}
# $(call find-program, filter-pattern)
find-program = \
    $(filter $1,                   \
      $(wildcard                   \
        $(addsuffix /*,            \
          $(sort                   \
            $(subst :, ,           \
              $(subst ::,:.:,      \
                $(patsubst :%,.:%, \
                  $(patsubst %:,%:.,$(PATH)))))))))

find:
    @echo $(words $(call find-program, %))
\end{verbatim}
}

Три внутренних подстановки осуществляются для корректной работы в
особых случаях. Пустой компонент \variable{PATH} может быть
использован для обозначения текущего каталога. Для нормализации этого
синтаксиса мы ищем пустые компоненты \variable{PATH} в конце строки, в
начале строки и внутри строки (именно в таком порядке). Все найденные
компоненты заменяются символом <<.>>. Затем разделитель компонент
\variable{PATH} заменяется пробелом. Функция \function{sort}
используется для удаления повторяющихся компонентов. После этого к
каждому слову в полученном списке добавляется суффикс \command{/*},
затем вызывается функция \function{wildcard}, осуществляющая поиск
всех файлов, соответствующих шаблону. Наконец, функция
\function{filter} отбирает только те файлы, которые соответствуют
заданному шаблону.

Хотя может показаться, что эта функция будет выполняться очень
медленно (и может быть действительно так на многих системах), на моём
1.9GHz P4 с 512MB оперативной памяти эта функция выполняется за 0,20
секунды и находит 4335 программ. Можно повысить производительность,
переместив аргумент \texttt{\${}1} внутрь вызова \function{wildcard}.
Следующая версия устраняет необходимость вызова \function{filter} и
вызывает \function{addsuffix} с аргументом, переданным вызывающей
функцией:

{\footnotesize
\begin{verbatim}
# $(call find-program,wildcard-pattern)
find-program =
    $(wildcard                   \
      $(sort                     \
        $(addsuffix /$1,         \
          $(subst :, ,           \
            $(subst ::,:.:,      \
              $(patsubst :%,.:%, \
                $(patsubst %:,%:.,$(PATH))))))))

find:
    @echo $(words $(call find-program,*))
\end{verbatim}
}

Этот вариант выполняется за 0,17 секунды. Он работает быстрее потому,
что функция \function{wildcard} больше не возвращает все файлы
каталогов только для того, чтобы затем отсеить их с помощью
\function{filter}.  Подобный пример можно встретить в руководстве
пользователя GNU \GNUmake{}.  Заметим, что первая версия использует
шаблоны в стиле \function{filter} (содержащие только метасимвол
\command{\%}), а вторая~--- шаблоны в стиле \function{wildcard}
(\command{\~}, \command{*}, \command{?}, \command{[...]} и
\command{[\^\,...]}).

%---------------------------------------------------------------------
% addprefix
%---------------------------------------------------------------------
\item[\texttt{\${}(addprefix \emph{префикс},\emph{список} ...)}] \hfill \\
\index{Функции!встроенные!addprefix@\function{addprefix}}
Функция \function{addprefix} является дополнением к функции
\function{addsuffix}. Ниже приведён пример функции, проверяющей набор
файлов на существование и ненулевую длину:

{\footnotesize
\begin{verbatim}
# $(call valid-files, file-list)
valid-files = test -s . $(addprefix -a -s ,$1)
\end{verbatim}
}

Функция \function{valid-files} отличается от большинства рассмотренных
тем, что её значение должно быть выполнено в командном интерпретаторе.
Для осуществления проверки используется программа \utility{test} с
ключом \command{-s} (истина, если файл существует и не пуст).
Поскольку для корректной работы программы \utility{test} имена файлов
должны быть разделены ключом \command{-a}, мы используем
\function{addprefix} для добавления этого ключа к каждому имени файла
в списке. В начале цепочки используется каталог \filename{.}, для него
условие существования и непустоты всегда является истинным.

%---------------------------------------------------------------------
% join
%---------------------------------------------------------------------
\item[\texttt{\${}(join \emph{список-префиксов},\emph{список-суффиксов})}] \hfill \\
\index{Функции!встроенные!join@\function{join}}
Функция \function{join} является дополнением к функциям \function{dir}
и \function{notdir}. Она принимает в качестве аргументов два списка и
производит конкатенацию первого элемента из
\ItalicMono{списка-префиксов} с первым элементом из
\ItalicMono{списка-суффиксов}, второго элемента из
\ItalicMono{списка-префиксов} со вторым элементом из
\ItalicMono{списка-суффиксов} и так далее. Эта функция может
использоваться для реконструкции списков, декомпозированных при помощи
функций \function{dir} и \function{notdir}.

%---------------------------------------------------------------------
% abspath
%---------------------------------------------------------------------
\item[\texttt{\${}(abspath \emph{список}...)}] \hfill \\
\index{Функции!встроенные!abspath@\function{abspath}}
Для каждого файла из \ItalicMono{списка} возвращает абсолютный путь,
не содержащий компонентов \filename{.} и \filename{..}, а также
повторяющихся разделителей (\filename{/}). Заметим, что в отличие от
функции \function{realpath}, \function{abspath} не производит
разрешения символических ссылок и не требует существования файлов.
Для проверки существования файлов используйте функцию
\function{wildcard}.

Эта функция доступна в версиях GNU \GNUmake{} 3.81 и выше.

%---------------------------------------------------------------------
% realpath
%---------------------------------------------------------------------
\item[\texttt{\${}(realpath \emph{список}...)}] \hfill \\
\index{Функции!встроенные!realpath@\function{realpath}}
Функция \function{realpath} подобна функции \function{abspath} c тем
отличием, что осуществляет разрешение символических ссылок и проверку
существования файлов и каталогов.

Эта функция доступна в версиях GNU \GNUmake{} 3.81 и выше.
\end{description}

%---------------------------------------------------------------------
% Flow control functions
%---------------------------------------------------------------------
\subsection{Функции управления выполнением}
\label{sec:flow_ctrl_func}

Поскольку многие из рассмотренных нами функций разработаны для
выполнения операций над списками, они прекрасно выполняют свою работу
без необходимости применения циклов. Однако без настоящих операторов
цикла и условного выполнения макроязык \GNUmake{} был бы очень
ограничен.  К счастью, \GNUmake{} предоставляет возможность
использовать оба этих оператора. Я также добавил в этот раздел функцию
\function{error}, являющуюся довольно экстремальной формой управления
выполнением.

\begin{description}
%---------------------------------------------------------------------
% if
%---------------------------------------------------------------------
\item[\texttt{\${}(if \emph{условие},\emph{then-часть},\emph{else-часть})}] \hfill \\
\index{Функции!встроенные!if@\function{if}}
Функция \function{if} (не путайте с директивами условной обработки
\directive{ifeq}, \directive{ifneq}, \directive{ifdef} и
\directive{ifndef}, рассмотренными в главе~\ref{chap:vars}) выбирает
одну из двух подстановок в зависимости от <<значения>> условного
выражения.  Значение \ItalicMono{условия} считается истинным, если оно
содержит хотя бы один символ (например, пробел). В этом случае
подставляется \ItalicMono{then-часть}. В противном случае, если
значение \ItalicMono{условия} является пустой строкой, подставляется
\ItalicMono{else-часть}\footnote{ В главе~\ref{chap:vars} мы обсуждали
разницу между макроязыками и обычными языками программирования.
Макроязыки трансформируют исходный код в текст с помощью определения и
подстановки макросов. Это различие станет яснее, когда мы увидим, как
работает функция \function{if}. (прим. автора)}.

Ниже приведёт простой способ узнать, исполняется ли ваш \Makefile{}
из-под Windows. Проверим, есть ли в окружении переменная
\variable{COMSPEC}, определённая только в Windows:

{\footnotesize
\begin{verbatim}
PATH_SEP := $(if $(COMSPEC),;,:)
\end{verbatim}
}

\GNUmake{} проверяет \ItalicMono{условие}, предварительно убрав
начальные и конечные пробелы и вычислив выражение. Если результатом
вычисления будет непустая строка, \ItalicMono{условие} считается
истинным. В итоге \variable{PATH\_SEP} содержит правильный разделитель
путей в переменной \variable{PATH}, независимо от того, выполняется ли
ваш \Makefile{} в Windows или \UNIX{}.

В одной из предыдущих глав мы упоминали возможность проверки версии
\GNUmake{} с помощью последних возможностей \GNUmake{} (например,
\function{eval}). Функции \function{if} и \function{filter} также
часто используются вместе для проверки значения строк:

{\footnotesize
\begin{verbatim}
$(if $(filter $(MAKE_VERSION),3.80),,\
  $(error Этот makefile требует GNU make версии 3.80.))
\end{verbatim}
}

Теперь по мере выхода новых версий GNU \GNUmake{}, выражение может
быть расширено для поддержки большего числа версий.

{\footnotesize
\begin{verbatim}
$(if $(filter $(MAKE_VERSION),3.80 3.81 3.90 3.92),,\
  $(error Этот makefile требует одну из следующих версий \
    GNU make ....))
\end{verbatim}
}

Эта техника имеет свои недостатки: придётся изменять код после каждой
установки свежей версии \GNUmake{}. С другой стороны, это происходит
не так уж часто (например, версия 3.80 была выпущена в октябре 2002
года, а версию 3.81 пришлось ждать вплоть до апреля 2006 года).
Предыдущий тест может быть помещён в самое начало \Makefile{}'а,
поскольку \function{if} либо вычислится как пустая строка, либо
вызовет функцию \function{error}, завершив выполнение \GNUmake{}.

%-------------------------------------------------------------------
% error
%-------------------------------------------------------------------
\item[\texttt{\${}(error \emph{сообщение})}] \hfill \\
\index{Функции!встроенные!error@\function{error}}
Функция \function{error} предназначена для вывода сообщений о
фатальных ошибках. После того, как эта функция напечатает
\ItalicMono{сообщение}, \GNUmake{} завершит свою работу с кодом
возврата 2. Вывод предваряется указанием имени текущего \Makefile{}'а
и номером текущей строки.  Ниже приведена реализация общей конструкции
программирования \index{Функции!assert@\function{assert}}
\newword{assert} для \GNUmake{}:

{\footnotesize
\begin{verbatim}
# $(call assert,condition,message)
define assert
  $(if $1,,$(error Assertion failed: $2))
endef

# $(call assert-file-exists,wildcard-pattern)
define assert-file-exists
  $(call assert,$(wildcard $1),$1 does not exist)
endef

# $(call assert-not-null,make-variable)
define assert-not-null
  $(call assert,$($1),The variable "$1" is null)
endef

error-exit:
    $(call assert-not-null,NON_EXISTENT)
\end{verbatim}
}

Первая функция, \function{assert}, просто проверяет свой первый
аргумент на пустоту и выводит пользовательское сообщение об ошибке,
если тестируемое значение является пустой строкой. Вторая функция
основывается на первой и проверяет с помощью функции
\function{wildcard} существование файла. Отметим, что аргумент может
содержать любое число шаблонов.

Третья функция очень полезна и основывается на \newword{вычисляемых
именах переменных}. Переменная \GNUmake{} может содержать что угодно,
даже имя другой переменной \GNUmake{}.  Однако если одна переменная
содержит имя второй переменной, как вы сможете получить доступ к
значению второй переменной? Можно просто вычислить переменную дважды:

{\footnotesize
\begin{verbatim}
NO_SPACE_MSG := No space left on device.
NO_FILE_MSG  := File not found.
...
STATUS_MSG   := NO_SPACE_MSG

$(error $($(STATUS_MSG)))
\end{verbatim}
}

Пример выглядит немного надуманным, однако он достаточно прост и
прекрасно иллюстрирует основную идею. Переменная
\variable{STATUS\_MSG} может принимать одно из нескольких сообщений об
ошибках путём сохранения имени переменной, содержащей это сообщение.
Когда приходит время вывести сообщение об ошибке, сначала вычисляется
\variable{STATUS\_MSG} для доступа к имени переменной, содержащей
сообщение об ошибке, \texttt{\${}(STATUS\_MSG)}, затем полученное имя
подвергается повторному вычислению для получения текста сообщения,
\texttt{\${}(\${}(STATUS\_MSG))}. В нашей функции
\function{assert-not-null} мы предполагали, что аргументом функции
является имя переменной. После первого вычисления аргумента,
\texttt{\${}1}, мы получаем имя переменной, которое сразу же
подвергаем повторному вычислению, \texttt{\${}(\${}1)}, для
определения значения этой переменной. Если значение не определено, мы
можем использовать имя переменной, \variable{\${}1}, для вывода
сообщения об ошибке:

{\footnotesize
\begin{alltt}
\${} \textbf{make}
Makefile:14: *** Assertion failed: The variable \textbackslash{}
"NON\_EXISTENT" is null. Stop.
\end{alltt}
}

Существует также функция \function{warning} (см. раздел
<<\nameref{sec:misc_func}>> далее в этой главе), которая выводит
сообщение в том же формате, что и функция \function{error}, но не
прерывает выполнения \GNUmake{}.

%---------------------------------------------------------------------
% foreach
%---------------------------------------------------------------------
\item[\texttt{\${}(foreach \emph{переменная},\emph{список},\emph{тело})}] \hfill \\
\index{Функции!встроенные!foreach@\function{foreach}}
Функция \function{foreach} предоставляет возможность вычислять
выражения в цикле. Заметим, что это отличается от повторного
вычисления функции от разных аргументов (хотя это также может быть
осуществлено с помощью этой функции). Например:

{\footnotesize
\begin{alltt}
letters := \${}(foreach letter,a b c d,\${}(letter))
show-words:
    \#{} letters has \${}(words \${}(letters)) words: '\${}(letters)'

\${} \textbf{make}
\#{} letters has 4 words: 'a b c d'
\end{alltt}
}

Когда выполняется этот цикл, переменной цикла \variable{letter}
последовательно присваиваются значения \textit{a b c d}, а тело цикла,
\variable{\${}(letter)}, вычисляется один раз для каждого значения.
Вычисленный текст аккумулируется в строке, каждое значение тела
отделяется от предыдущего пробелами.

Ниже приведена функция для проверки того, был ли определен набор
переменных:

{\footnotesize
\begin{verbatim}
VARIABLE_LIST := SOURCES OBJECTS HOME
$(foreach i,$(VARIABLE_LIST), \
  $(if $($i),,                \
    $(shell echo $i has no value > /dev/stderr)))
\end{verbatim}
}

Использование псевдофайла \filename{/dev/stderr} требует, чтобы
переменная окружения \variable{SHELL} имела значение \utility{bash}.
Этот цикл присваивает переменной \variable{i} поочерёдно каждое слово
из переменной \variable{VARIABLE\_LIST}. Условное выражение внутри
\function{if} сначала вычисляет \variable{\${}i} для получения имени
переменной, а затем находит значение \variable{\${}(\${}i)} для
проверки значения этой переменной на пустоту. Если вычисленная строка
не пуста, \ItalicMono{then-часть} ничего не делает; в противном случае
\ItalicMono{else-часть} выводит предупреждение. Заметим, что если мы
не перенаправим вывод \utility{echo}, вывод команды \function{shell}
будет подставлен в \Makefile{}, вызвав синтаксическую ошибку.
Результатом вычисления цикла \function{foreach} является пустая
строка.

Как и было обещано, ниже представлена функция для соединения в список
всех слов, содержащих заданную подстроку:

{\footnotesize
\begin{verbatim}
# $(call grep-string, search-string, word-list)
define grep-string
  $(strip                         \
    $(foreach w, $2,              \
      $(if $(findstring $1, $w),  \
        $w)))
endef

words := count_words.c counter.c lexer.l lexer.h counter.h

find-words:
    @echo $(call grep-string,un,$(words))
\end{verbatim}
}

К сожалению, эта функция не понимает шаблоны, однако нахождение
простых подстрок вполне ей под силу:

{\footnotesize
\begin{alltt}
\${} \textbf{make}
count\_words.c counter.c counter.h
\end{alltt}
}

%---------------------------------------------------------------------
% and
%---------------------------------------------------------------------
\item[\texttt{\${}(and \emph{условие}\subi{1}[,...\emph{условие}\subi{n}])}] \hfill \\
\index{Функции!встроенные!and@\function{and}}
Функция \function{and} представляет операцию \command{AND}. Она
производит вычисление всех своих аргументов по порядку. Если
результатом вычисления одного из аргументов является пустая строка,
процесс вычисления останавливается и функция возвращает пустую строку.
Если ни один из аргументов не порождает пустую строку, возвращается
результат вычисления последнего аргумента.

Эта функция доступна в GNU \GNUmake{}  версии 3.81 и выше.

%---------------------------------------------------------------------
% or
%---------------------------------------------------------------------
\item[\texttt{\${}(or \emph{условие}\subi{1}[,...\emph{условие}\subi{n}])}] \hfill \\
\index{Функции!встроенные!or@\function{or}}
Функция \function{or} представляет операцию \texttt{OR}. Она производит
вычисление своих аргументов по порядку. Если результатом вычисления
хотя бы одного из аргументов является непустая строка, это строка
возвращается в качестве значения функции и дальнейшее вычисление не
производится. Иначе возвращается пустая строка.

Эта функция доступна в GNU \GNUmake{}  версии 3.81 и выше.

\end{description}

%---------------------------------------------------------------------
% Style note concerning variables and parantheses
%---------------------------------------------------------------------
\subsubsection*{Замечание о скобках в переменных}

Как у же было замечено, если имя переменной \GNUmake{} состоит из
одного символа, то его не обязательно заключать в скобки. Например,
все основные автоматические переменные состоят из одного символа.
Написание автоматических переменных без скобок встречается
повсеместно, даже в руководстве по GNU \GNUmake{}. Однако практически
все остальные переменные, даже состоящие из одного символа, в
руководстве по GNU \GNUmake{} заключаются в скобки.  Это подчёркивает
особую природу переменных \GNUmake{}, поскольку практически во всех
языках программирования, в которых для работы с переменными
используется символ доллара (таких как командные интерпретаторы,
\utility{perl}, \utility{awk} и \utility{yacc}), применение скобок не
требуется. Одна из самых распространённых ошибок программирования на
\GNUmake{}~--- пропущенные скобки. Вот пример использования функции
\function{foreach}, содержащий ошибку:

{\footnotesize
\begin{verbatim}
INCLUDE_DIRS := ...
INCLUDES     := $(foreach i,$INCLUDE_DIRS,-I $i)
# INCLUDES теперь имеет значение "-I NCLUDE_DIRS"
\end{verbatim}
}

Однако я нахожу, что читать макросы гораздо легче, если использовать
переменные из одного символа и опускать ненужные скобки. Например, я
считаю, что функцию \function{has-duplicates} легче прочитать, если не
использовать лишние скобки:

{\footnotesize
\begin{verbatim}
# $(call has-duplicates, word-list)
has-duplicates = $(filter          \
                   $(words $1)     \
                     $(words $(sort $1))))
\end{verbatim}
}

Сравните с таким вариантом:

{\footnotesize
\begin{verbatim}
# $(call has-duplicates, word-list)
has-duplicates = $(filter          \
                   $(words $(1))   \
                     $(words $(sort $(1)))))
\end{verbatim}
}

Однако функция \function{kill-program} лишь выигрывает от применения
дополнительных скобок, поскольку они помогают отличить переменные
\GNUmake{} от переменных командного интерпретатора или переменных
других программ:

{\footnotesize
\begin{verbatim}
PS        := ps
PS_FIELDS := "9 47 100"
PS_FLAGS  := -W
define kill-program
  @$(PS) $(PS_FLAGS) |                              \
  $(AWK) 'BEGIN { FIELDWIDTHS = $(PS_FIELDS) }      \
          /$(1)/{                                   \
              print "Killing " $$3;                 \
              system( "$(KILL) $(KILLFLAGS) " $$1 ) \
          }'
endef
\end{verbatim}
}

Строка поиска содержит первый аргумент макроса, \variable{\${}(1)}.
Выражения \variable{\${}\${}3} и \variable{\${}\${}1} относятся к
переменным \utility{awk}.

Я опускаю скобки только в том случае, если это сделает код более
удобным для чтения. Обычно это касается параметров макросов и
переменных цикла \function{foreach}. Вы должны использовать тот стиль,
который наиболее подходит в вашей ситуации. Если у вас есть малейшие
сомнения относительно удобства сопровождения вашего \Makefile{}'а,
следуйте руководству пользователя GNU \GNUmake{} и заключайте
переменные в круглые скобки. Помните, программа \GNUmake{} создана для
решения проблем, связанных с поддержкой программного обеспечения. Если
вы будете иметь это в виду во время написания своих \Makefile{}'ов, вы
сможете избежать многих неприятностей.

%---------------------------------------------------------------------
% Important miscellaneous functions
%---------------------------------------------------------------------
\subsection{Различные вспомогательные функции}
\label{sec:misc_func}

Наконец, мы рассмотрим несколько полезных (но не очень важных) функций
для манипулирования строками. Скорее всего, вы будете использовать их
довольно часто, но не так часто, как \function{foreach} или
\function{call}.

\begin{description}
%---------------------------------------------------------------------
% strip
%---------------------------------------------------------------------
\item[\texttt{\${}(strip \emph{текст})}] \hfill \\
\index{Функции!встроенные!strip@\function{strip}}
Функция \function{strip} удаляет из \ItalicMono{текста} все начальные
и конечные пробелы, а также заменяет все повторяющиеся внутренние
пробелы одним. Наиболее часто эта функция используется для обработки
переменных, использующихся в условных выражениях.

Я часто использую эту функцию для удаления нежелательных пробелов из
определений переменных и макросов. Я использовал многострочное
форматирование, однако использование функции \function{strip} для
обёртки аргументов \variable{\${}1}, \variable{\${}2} и т.д. является
неплохой идеей, особенно если вызываемая функция чувствительна к
начальным пробелам. Часто программисты, не знающие тонкостей
\GNUmake{}, добавляют пробел после запятой в списке аргументов функции
\function{call}.

%---------------------------------------------------------------------
% origin
%---------------------------------------------------------------------
\item[\texttt{\${}(origin \emph{имя-переменной})}] \hfill \\
\index{Функции!встроенные!origin@\function{origin}}
Функция \function{origin} возвращает строку, описывающую происхождение
переменной. Это может быть очень полезно, чтобы принять решение о том,
как использовать значение переменной. Например, вы можете захотеть
проигнорировать значение переменной, если она получена из окружения, и
использовать её, если она была определена в командной строке.  В
качестве конкретного примера приведём функцию
\function{assert-defined}, определяющую, определена ли переменная:

{\footnotesize
\begin{verbatim}
# $(call assert-defined,variable-name)
define assert-defined
  $(call assert,                          \
    $(filter-out undefined,$(origin $1)), \
    Переменная '$1' не определена)
endef
\end{verbatim}
}

Функция \function{origin} может возвращать одно из следующих значений:
\begin{itemize}
%---------------------------------------------------------------------
\item \texttt{undefined} \hfill \\
Переменная никогда не была определена.

%---------------------------------------------------------------------
\item \texttt{default} \hfill \\
Переменная определена в стандартной базе данных \GNUmake{}. Если вы
измените значение такой переменной, \function{origin} вернёт
происхождение самого последнего определения.

%---------------------------------------------------------------------
\item \texttt{environment} \hfill \\
Переменная была определена в окружнии (и опция
\command{-{}-environment\hyp{}overrides} не была включена).

%---------------------------------------------------------------------
\item \texttt{environment override} \hfill \\
Переменная была определена в окружнии (и опция
\command{-{}-environment\hyp{}overrides} была включена).

%---------------------------------------------------------------------
\item \texttt{file} \hfill \\
Переменная была определена в \Makefile{}'е.

%---------------------------------------------------------------------
\item \texttt{file} \hfill \\
Переменная была определена в командной строке.

%---------------------------------------------------------------------
\item \texttt{override} \hfill \\
Для определения переменной была использована директива
\directive{override}.
%---------------------------------------------------------------------

\item \texttt{automatic} \hfill \\ Переменная является автоматической
переменной \GNUmake{}.
%---------------------------------------------------------------------
\end{itemize}

%---------------------------------------------------------------------
% warning
%---------------------------------------------------------------------
\item[\texttt{\${}(warning \emph{сообщение})}] \hfill \\
\index{Функции!встроенные!warning@\function{warning}}
Функция \function{warning} похожа на функцию \function{error}, но не
вызывает завершение выполнения \GNUmake{}.  Вывод
\ItalicMono{сообщения} предваряется именем текущего \Makefile{}'а и
номером текущей строки. Функция \function{warning} возвращает пустую
строку, и потому может использоваться практически везде:

{\footnotesize
\begin{verbatim}
$(if $(wildcard $(JAVAC)),,                           \
  $(warning Переменная, определяющая компилятор java, \
            JAVAC ($(JAVAC)), не определена должным   \
            образом.))
\end{verbatim}
}

%---------------------------------------------------------------------
% info
%---------------------------------------------------------------------
\item[\texttt{\${}(info \emph{сообщение})}] \hfill \\
\index{Функции!встроенные!info@\function{info}}
Функция \function{info} выводит \ItalicMono{сообщение} на стандартный
поток вывода, не предваряя его именем \Makefile{}'а или номером
строки. Результатом вычисления этой функции является пустая строка.

Эта функция доступна в GNU \GNUmake{} версии 3.81 и выше.

%---------------------------------------------------------------------
% value
%---------------------------------------------------------------------
\item[\texttt{\${}(value \emph{имя-переменной})}] \hfill \\
\index{Функции!встроенные!value@\function{value}}
Функция \function{value} предоставляет способ использовать значение
переменной, \emph{не вычисляя} его. Заметим, что откат уже
произведённых вычислений не может быть осуществлён. Например, если вы
определяете простую переменную (не рекурсивную), её значение
вычисляется в момент определения. В этом случае функция
\function{value} вернёт тот же результат, что и обычное вычисление
переменной.

%---------------------------------------------------------------------
% flavor
%---------------------------------------------------------------------
\item[\texttt{\${}(flavor \emph{имя-переменной})}] \hfill \\
\index{Функции!встроенные!flavor@\function{flavor}}
Функция \function{flavor}, в отличие от многих других функций, не
оперирует значением переменной, а возвращает некоторую информацию о
переменной. Значением этой функции является строка, определяющая тип
переменной, имя которой передано в качестве аргумента:

\begin{itemize}
\item \texttt{undefined} \hfill \\
Переменная не определена.
\item \texttt{recursive} \hfill \\
Переменная является рекурсивно-вычисляемой.
\item \texttt{simple} \hfill \\
Переменная является простой.
\end{itemize}

Эта функция доступна в GNU \GNUmake{} версии 3.81 и выше.
\end{description}
