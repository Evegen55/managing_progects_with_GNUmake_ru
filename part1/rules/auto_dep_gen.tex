%%--------------------------------------------------------------------
%% Automatic dependency generation
%%--------------------------------------------------------------------
\section{Автоматическое определение зависимостей}
\label{sec:auto_dep_gen}
Когда мы изменили нашу программу подсчёта слов так, чтобы часть
объявлений была описана в заголовочных файлах, мы, сами того не
замечая, добавили новую проблему. Мы описали зависимости между
объектными и заголовочными файлами в наш \Makefile{} самостоятельно. В
нашем случае сделать это было нетрудно, но в реальных программах (а не
в игрушечных примерах) это может быть весьма утомительным и
порождающим ошибки процессом. На самом деле, в большинстве программ
указание зависимостей практически невозможно, поскольку заголовочные
файлы могут включать другие заголовочные файлы, образуя сложное дерево
включений.
\index{Заголовочный файл}
Например, в моей системе один заголовочный файл \filename{stdio.h}
(наиболее часто используемый заголовочный файл стандартной библиотеки
языка \Clang{}) в общем счёте включает 15 других заголовочных файлов.
Разрешение подобных зависимостей вручную является практически
безнадёжным занятием. Однако неудавшаяся компиляция ведёт к часам
потраченного на отладку времени или, что ещё хуже, к проблемам в уже
выпущенном программном обеспечении. Что же нам делать?

К счастью, компьютеры весьма хорошо справляются с задачами поиска и
нахождения соответствий шаблону. Давайте используем программу для
определения зависимостей между исходными файлами, и даже записи этих
зависимостей в соответствии со стандартным синтаксисом \GNUmake{}. Как
вы, возможно, уже догадались, такая программа уже существует, по крайней
мере, для исходных файлов на \Clang{}/\Cplusplus{}.
\index{gcc}
\index{Опции!компилятора}
Компилятор \utility{gcc}, как и многие другие компиляторы, имеет опцию
для чтения исходных файлов и составления зависимостей для \GNUmake{}.
Например, так мы можем определить зависимости для \filename{stdio.h}

\begin{alltt}
\footnotesize
\$ \textbf{echo "#include <stdio.h>" > stdio.c}
\$ \textbf{gcc -M stdio.c}
stdio.o: stdio.c /usr/include/stdio.h /usr/include/\_ansi.h \textbackslash{}
/usr/include/newlib.h /usr/include/sys/config.h \textbackslash{}
/usr/include/machine/ieeefp.h /usr/include/cygwin/config.h \textbackslash{}
/usr/lib/gcc-lib/i686-pc-cygwin/3.2/include/stddef.h \textbackslash{}
/usr/lib/gcc-lib/i686-pc-cygwin/3.2/include/stdarg.h \textbackslash{}
/usr/include/sys/reent.h /usr/include/sys/\_types.h \textbackslash{}
/usr/include/sys/types.h /usr/include/machine/types.h \textbackslash{}
/usr/include/sys/features.h /usr/include/cygwin/types.h \textbackslash{}
/usr/include/sys/sysmacros.h /usr/include/stdint.h \textbackslash{}
/usr/include/sys/stdio.h
\end{alltt}

<<Отлично,>>~--- скажете вы,~---<<Теперь мне придётся запускать gcc,
открывать текстовый редактор и вставлять результаты работы компилятора
с ключом \command{-M} в свой \Makefile{}. Какой ужас.>>. И вы были бы
правы, если бы это была вся правда. Существует два стандартных способа
включения автоматически составленных зависимостей в \Makefile{}.
Первый, он же самый старый, заключается в добавлении комментария
наподобие следующего:

{\footnotesize
\begin{verbatim}
# Далее следуют автоматически составленные зависимости:
# НЕ РЕДАКТИРОВАТЬ
\end{verbatim}
}

{\flushleft
в конец \Makefile{}'а и написании сценария командного интерпретатора
для автоматического обновления этого раздела. Это, безусловно, гораздо
лучше ручного обновления, но всё ещё довольно неудобно. Второй метод
заключается в добавлении директивы include. Б\'{о}льшая часть версий
\GNUmake{} поддерживает эту директиву, и, безусловно, GNU \GNUmake{} в
их числе. Идея заключается в спецификации цели, с которой
ассоциированы действия по запуску \utility{gcc} с ключом \command{-M},
сохранении результатов в файле зависимостей и повторный запуск
\GNUmake{} с включением составленного файла зависимостей в основной
\Makefile{}. До появления GNU \GNUmake{} это делалось правилом
следующего вида:
}

{\footnotesize
\begin{verbatim}
depend: count\_words.c lexer.c counter.c
    $(CC) -M $(CPPFLAGS) $^ > $@
include depend
\end{verbatim}
}

Сначала вы запускаете \GNUmake{} с целью составить файл зависимостей,
и только после этого производите повторный пуск для сборки программы.
На момент появления этой возможности она выглядела неплохо, однако
часто люди добавляли или удаляли зависимости из исходного кода, забыв
заново составить файл зависимостей. Это становилось причиной
неправильной компиляции со всеми вытекающими неприятностями. GNU
\GNUmake{} решил эту неприятную проблему с помощью мощной
функциональности и довольно простого алгоритма. Рассмотрим сначала
алгоритм. Если мы составим для каждого исходного файла собственный
файл зависимостей, скажем, файл с расширением \filename{.d}, и добавим
этот файл в качестве цели к соответствующему правилу, то сможем
сообщить \GNUmake{}, что \filename{.d} файл нуждается в обновлении
(наряду с объектным файлом) при изменении исходного файла:

{\footnotesize
\begin{verbatim}
counter.o counter.d: src/counter.c include/counter.h include/lexer.h
\end{verbatim}
}

Составление этого правила может быть завершено шаблонным правилом и
довольно неуклюжим сценарием (взятым прямо из руководства по GNU
\GNUmake{}) \footnote{Этот довольно выразительный сценарий, по моему
мнению, всё же требует некоторого объяснения. Сначала мы используем
компилятор \Clang{} с опцией \command{-M} для создания временного
файла, содержащего список зависимостей цели. Имя временного файла
получается из названия цели \command{\${}@} и добавочного уникального
числового суффикса \command{.\${}\${}\${}\${}}. В командном
интерпретаторе \utility{sh} переменная \command{\${}\${}} содержит
идентификатор текущего запущенного процесса командного интерпретатора.
Поскольку этот идентификатор является уникальным, имя нашего
временного файла также получается уникальным.  Затем мы используем
\utility{sed} для добавления файла с расширением \filename{.d} в
качестве цели правила. Выражение \utility{sed} состоит из шаблона
поиска
\command{\textbackslash{}(\${}\textbackslash{})\textbackslash{}1.o[
:]*} и подстановки \command{\textbackslash{}1.o \${}@ :}, разделённых
запятыми. Шаблон поиска состоит из основы имени цели \command{\${}*},
заключенной в группу регулярного выражения
\command{\textbackslash{}(\textbackslash{})}, за которой следует
суффикс \command{.o}. После имени цели могут следовать пробелы или
двоеточия (\command{[ :]*}). Подстановка восстанавливает
первоначальную цель с помощью ссылки на первую группу регулярного
выражения с добавлением суффикса (\command{\textbackslash{}1.o}) и
добавляет файл зависимостей в качестве второй цели правила
(\command{\${}@}).}:

{\footnotesize
\begin{verbatim}
%.d: %.c
    $(CC) -M $(CPPFLAGS) $< > $@.$$$$;                  \
    sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
    rm -f $@.$$$$
\end{verbatim}
}

Теперь рассмотрим вышеупомянутую функциональность. GNU \GNUmake{}
будет рассматривать каждый включаемый файл в качестве цели,
нуждающейся в обновлении.  Таким образом, когда мы будем упоминать
\filename{.d} файлы, \GNUmake{} автоматически попытается создать эти
файлы во время чтения \Makefile{}'а. Ниже представлен наш пример с
добавлением автоматического управления зависимостями:

{\footnotesize
\begin{verbatim}
VPATH    = src include
CPPFLAGS = -I include
SOURCES  = count_words.c \
           counter.c     \
           lexer.c 
count_words: counter.o lexer.o -lfl
count_words.o: counter.h
counter.o: counter.h lexer.h
lexer.o: lexer.h

include $(subst .c,.d,$(SOURCES))

%.d: %.c
    $(CC) -M $(CPPFLAGS) $< > $@.$$$$;                  \
    sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
    rm -f $@.$$$$
\end{verbatim}
}

Директива включения должна появляться только после записанных вручную
правил, чтобы не подменить цель по умолчанию целью из включаемого
\index{Директивы!include@\directive{include}}
файла. Директива \directive{include} принимает в качестве аргумента
список файлов (чьи имена могут включать шаблоны). В предыдущем примере
\index{Функции!встроенные!substr@\function{substr}}
мы использовали встроенную функцию \GNUmake{} \function{substr} для
трансформации списка исходных файлов в список файлов зависимостей (мы
рассмотрим \function{substr} более подробно в разделе
<<\nameref{sec:str_func}>> главы~\ref{chap:functions}). Пока просто
примите к сведению, что мы используем эту функцию для замены строки
\filename{.c} на строку \filename{.d} в каждом слове списка
\variable{\${}(SOURCES)}.

\index{Опции!just-print@\command{-{}-just-print (-n)}}
Если теперь мы запустим \GNUmake{} с опцией
\command{-{}-just\hyp{}print}, то получим следующее:

\begin{alltt}
\footnotesize
\$ \textbf{make --just-print}
Makefile:13: count\_words.d: No such file or directory
Makefile:13: lexer.d: No such file or directory
Makefile:13: counter.d: No such file or directory
\verb#gcc -M -I include src/counter.c > counter.d.$$;       \#
\verb#sed 's,\(counter\)\.o[ :]*,\1.o counter.d : ,g'       \#
\verb#< counter.d.$$ > counter.d;                           \#
rm -f counter.d.\$\$
flex -t src/lexer.l > lexer.c
\verb#gcc -M -I include lexer.c > lexer.d.$$;           \#
\verb#sed 's,\(lexer\)\.o[ :]*,\1.o lexer.d : ,g'       \#
\verb#< lexer.d.$$ > lexer.d;                           \#
rm -f lexer.d.\$\$
\verb#gcc -M -I include src/count_words.c > count_words.d.$$; \#
\verb#sed 's,\(count_words\)\.o[ :]*,\1.o count_words.d : ,g' \#
\verb#< count_words.d.$$ count_words.d;                       \#
rm -f count\_words.d.\$\$
rm lexer.c
gcc -I include -c -o count\_words.o src/count\_words.c
gcc -I include -c -o counter.o src/counter.c
gcc -I include -c -o lexer.o lexer.c
gcc count\_words.o counter.o lexer.o /lib/libfl.a -o count\_words
\end{alltt}

Сначала \GNUmake{} выводит несколько предупреждений, с виду
напоминающих ошибки. Не стоит волноваться, это всего лишь
предупреждения. \GNUmake{} производит поиск файлов, указанных в
директиве \index{Директивы!sinclude@\directive{-include}}
\directive{include}, не находит их, и перед началом поиска правила для
создания этих файлов выводит предупреждение \command{No such file or
directory}. Эти предупреждения могут быть подавлены при помощи символа
\command{-}, добавленного перед директивой \directive{include}.
Следующие строки демонстрируют вызов \utility{gcc} с опцией
\command{-M} и запуск команды \utility{sed}.  Обратите внимание на то,
что \GNUmake{} должен вызвать \utility{flex} для создания
\filename{lexer.c}, удаляемый перед началом сборки цели по умолчанию.

\index{Автоматическое определение зависимостей}
Теперь у вас есть представление об автоматическом определении
зависимостей. Эта тема содержит ещё много интересных вопросов,
например, построение зависимостей для других языков программирования,
или вывод зависимостей в виде дерева. Мы вернёмся к этим темам во
второй части книги.
