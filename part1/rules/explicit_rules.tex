%%--------------------------------------------------------------------
%% Explicit rules
%%--------------------------------------------------------------------
\section{Явные правила}
\label{sec:explicit_rules}

Чаще всего вам придётся писать именно явные правила, указывающие
некоторые файлы как цели и реквизиты. Правило может иметь более одной
цели. Это значит, что каждая из указанных целей имеет в точности то же
множество реквизитов, что и остальные цели. Если цели требуется
обновить, для каждой из них будет выполнен один и тот же сценарий. Вот
пример такого правила:

{\footnotesize
\begin{verbatim}
vpath.o variable.o: make.h config.h getopt.h gettext.h dep.h
\end{verbatim}
}

Это правило означает, что цели \filename{vpath.o} и
\filename{variable.o} зависят от одного и того же множества
заголовочных файлов. Оно имеет в точности тот же эффект, что и
следующая спецификация:

{\footnotesize
\begin{verbatim}
vpath.o: make.h config.h getopt.h gettext.h dep.h

variable.o: make.h config.h getopt.h gettext.h dep.h
\end{verbatim}
}

Обе цели собираются независимо. Если один из объектных файлов имеет
более раннюю дату модификации, чем один из указанных заголовочных
файлов, \GNUmake{} инициирует сборку и выполнит команды,
ассоциированные с правилом.

Правило не обязательно указывать полностью сразу. Каждый раз, когда
\GNUmake{} обнаруживает файл в качестве цели, он добавляет цель и
реквизиты в граф зависимостей. Если такая цель уже существовала в
графе, к записи о цели добавляются новые реквизиты. Одним из
элементарных применений этого свойства является разбиение длинной
строки на несколько более коротких для улучшения читабельности файла:

{\footnotesize
\begin{verbatim}
vpath.o: make.h config.h getopt.h gettext.h dep.h
vpath.o: filedef.h hash.h job.h commands.h variable.h vpath.h
\end{verbatim}
}

В наиболее сложных случаях список реквизитов может состоять из файлов, способы
обработки которых различны:

{\footnotesize
\begin{verbatim}
# Убедимся, что файл lexer.c существует до компиляции vpath.c
vpath.o: lexer.c

...

# Компилируем vpath.c с определёнными флагами
vpath.o: vpath.c
	$(COMPILE.c) $(RULE_FLAGS) $(OUTPUT_OPTION) $<

...

# Включаем файл зависимостей, составленный программой
include auto-generated-dependencies.d
\end{verbatim}
}

Первое правило декларирует, что цель \filename{vpath.o} должна быть
собрана заново при изменении файла \filename{lexer.c} (возможно,
генерация этого файла имеет некий побочный эффект). Правило также
может быть использовано для того, чтобы убедиться, что все реквизиты
существуют (или, в случае необходимости, обновлены) перед сборкой
цели. Нужно отметить двустороннюю сущность правил. При прямом чтении
правило означает, что, если файл \filename{lexer.c} изменился,
требуется выполнить действия по обновлению \filename{vpath.o}. При
чтении в обратном направлении правило означает, что если требуется
обновить \filename{vpath.o}, то нужно убедиться, что файл
\filename{lexer.c} существует. Это правило может быть помещено рядом с
остальными правилами, касающимися файла \filename{lexer.c}, чтобы
разработчики помнили об этой тонкой взаимосвязи. Далее, рассмотрим
правило компиляции \filename{vpath.o}. Сценарий сборки для этого
правила использует три переменных \GNUmake{}. Переменные будут
детально описаны позже, пока важно знать лишь то, что обращение к
переменной происходит с помощью знака доллара (\command{\$}), за
которым следует либо один символ, либо слово в круглых скобках.
Наконец, зависимости типа \filename{.o/.h} включаются из отдельного
файла, полученного при помощи внешней программы.

В качестве особого случая GNU \GNUmake{} поддерживает упрощённый
синтаксис для правил с одной командой.

{\footnotesize
\begin{alltt}
\emph{цель: ; команда}
\end{alltt}
}

На практике такие правила встречаются редко, однако всё же иногда они
могут быть полезны, особенно когда нужно сберечь место на экране
монитора или листе бумаги. 

%---------------------------------------------------------------------
% Wildcards
%---------------------------------------------------------------------
\subsection{Шаблоны}
Часто \Makefile'ы содержат огромное количество файлов. Для упрощения
работы с ними \GNUmake{} поддерживает шаблоны, идентичные шаблонам
командного интерпретатора \utility{Bourne shell}: \verb|~|, \verb|*|,
\verb|?|, \verb|[...]| и \verb|[^...]|.  Например, шаблону \verb|*.*|
соответствуют все файлы, содержащие в имени точку. Знак вопроса
означает один символ, а \verb|[...]|~--- класс символов. Для выбора
дополнения класса символов нужно использовать \verb|[^...]|. Знак
тильды (\verb|~|) может быть использован для обозначения домашнего
каталога текущего пользователя системы.  Если за тильдой следует имя
пользователя, будет подставлен домашний каталог указанного
пользователя. \GNUmake{} автоматически раскрывает шаблоны, когда они
встречаются в названиях целей, реквизитов или командных сценариях. В
другом контексте шаблоны могут быть раскрыты явным вызовом функции.
Шаблоны чрезвычайно полезны для написания более адаптивных
\Makefile{}'ов. Например, вместо того, чтобы явно перечислять все
файлы, входящие в состав исходного кода программы, вы можете
использовать шаблоны\footnote{В более серьёзных приложениях применение
шаблонов для выбора компилируемых файлов является плохой практикой,
поскольку может вызвать компоновку с посторонним опасным кодом. В
правилах удаления промежуточных файлов шаблоны могут быть фатальными
для проекта (прим. автора).}:

{\footnotesize
\begin{verbatim}
prog: *.c
	$(CC) -o $@ $^
\end{verbatim}
}

Однако очень важно быть осторожным с шаблонами, ими легко
злоупотребить. Рассмотрим пример:

{\footnotesize
\begin{verbatim}
*.o: constants.h
\end{verbatim}
}

Намерения очевидны: все объектные файлы зависят от заголовочного файла
\filename{constants.h}. Однако посмотрим, как раскроется шаблон в
каталоге, не содержащем объектных файлов:

{\footnotesize
\begin{verbatim}
: constants.h
\end{verbatim}
}

Это допустимое выражение \GNUmake{}, оно не вызовет ошибки, однако оно
также не выразит той зависимости, которую имел в виду пользователь.
Одним из корректных способов реализации этого правила является
использование шаблона для получения файлов с исходным кодом (которые,
как правило, присутствуют) и трансформация полученного списка в список
объектных файлов. Мы рассмотрим эту технику при обсуждении функций
в главе~{\ref{chap:functions}}.

Наконец, стоит отметить, что раскрытие шаблонов в тот момент, когда
они появляются в качестве целей или реквизитов, осуществляет
непосредственно \GNUmake{}. Однако раскрытие шаблонов в сценариях
происходит в дочернем процессе командного интерпретатора. Это может
быть важной деталью, поскольку \GNUmake{} раскрывает шаблоны во время
чтения \Makefile{}'а, а командный интерпретатор раскрывает их много
позже, во время непосредственного выполнения команд. Когда
производятся сложные манипуляции с файлами, результаты раскрытия
одинаковых шаблонов в разные моменты времени могут сильно отличаться.
Проблематичной может быть ситуация, когда некоторые файлы являются
результатом сборки, и \GNUmake{} не видит их во время обработки
\Makefile{}'а. К таким случаям нужно относится особенно осторожно.

%---------------------------------------------------------------------
% Phony targets
%---------------------------------------------------------------------
\subsection{Абстрактные цели}
\label{sec:phony_targets}
\index{Цели!абстрактные}
До этого момента все цели и реквизиты, рассматриваемые нами, были
файлами, которые нужно было создать или обновить. Хоть это и типичный
способ использования целей, часто бывает полезным представлять цель в
качестве метки для командного сценария. Например, ранее упоминалось,
что стандартной целью для многих \Makefile{}'ов является \target{all}.
Цели, не представляющие файлов, называют \newword{абстрактными целями}
(\newword{phony targets}). Ещё одной стандартной абстрактной целью
является \target{clean}:

{\footnotesize
\begin{verbatim}
clean:
    rm -f *.o lexer.c
\end{verbatim}
}

Абстрактные цели должны собираться всегда, потому что команды,
ассоциированные с правилом, не создают файл с именем цели.

Важно заметить, что \GNUmake{} не отличает абстрактных целей от
целей, являющимися файлами. Если по случайности файл с именем
абстрактной цели существует, \GNUmake{} будет ассоциировать этот файл
с абстрактной целью в графе зависимостей. Например, если в текущей
директории существует файл \filename{clean}, то запуск команды
\BoldMono{make clean} приведёт к появлению довольно неожиданного
сообщения:

{\footnotesize
\begin{alltt}
\$ \textbf{make clean}
make: `clean' is up to date.
\end{alltt}
}

Довольно часто абстрактные цели не имеют реквизитов; цель
\target{clean} всегда будет рассматриваться как не требующая
обновления, и ассоциированные с ней команды никогда не будут
выполнены.

Чтобы избежать этой проблемы, GNU \GNUmake{} имеет специальную цель,
\target{.PHONY}, позволяющую сообщить \GNUmake{}, что цель не является
настоящим файлом. Любая цель может быть объявлена как абстрактная с
путём включения её в список реквизитов цели \target{.PHONY}:

{\footnotesize
\begin{verbatim}
.PHONY: clean
clean: 
    rm -f *.o lexer.c
\end{verbatim}
}

Теперь \GNUmake{} всегда будет выполнять команды, ассоциированные с
целью \target{clean}, даже если файл с таким именем существует. В
добавок к пометке цели как требующей обновления, спецификация цели как
абстрактной сообщает \GNUmake{}, для этой цели не нужно использовать
стандартное правило получения файла цели из исходного кода. Это
позволяет \GNUmake{} провести оптимизацию обычного процесса поиска
правил для достижения более высокой производительности.

Довольно редко имеет смысл включать абстрактную цель в качестве
реквизита реального файла, поскольку это будет приводить к
безусловному обновлению цели. Указание же реквизитов абстрактных целей
довольно часто приносит пользу. Например, цель \target{all} имеет в
качестве реквизитов список программ, которые нужно собрать:

\begin{alltt}
.PHONY: all
all: bash bashbug
\end{alltt}

В предыдущем примере цель \target{all} собирает командный
интерпретатор \utility{bash} и инструмент отправки сообщений об
ошибках \utility{bashbug}.

Абстрактные цели могут рассматриваться как сценарии интерпретатора,
встроенные в \Makefile{}. Объявление абстрактной цели в качестве
реквизита другой цели вызовет запуск сценария, ассоциированного с
абстрактной целью, перед сборкой основной цели. Предположим, мы
ограничены в использовании дискового пространства, и хотим отобразить
количество доступного места на диске перед выполнением действий,
требующих значительных затрат дискового пространства. Одно из решений
демонстрирует следующий пример:

{\footnotesize
\begin{verbatim}
.PHONY: make-documentation
make-documentation:
    df -k . | awk 'NR == 2 { printf( "%d available\n", $$4 ) }'
    javadoc ...
\end{verbatim}
}

Проблема заключается в том, что нам может понадобиться указать
команды \utility{df} и \utility{awk} несколько раз для разных целей.
Это является проблемой с точки зрения поддержки, поскольку нам
придётся изменять каждое вхождение этих команд, если, например, в
другой системе формат выдачи данных утилиты \utility{df} отличается.
Поэтому более изящным решением является следующее:

{\footnotesize
\begin{verbatim}
.PHONY: make-documentation
make-documentation: df
    javadoc ...

.PHONY: df
df:
    df -k . | awk 'NR == 2 { printf( "%d available\n", \$\$4 ) }'
\end{verbatim}
}

Мы можем сообщить \GNUmake{} о необходимости вызова сценария,
ассоциированного с целью \utility{df}, перед созданием документации,
указав \utility{df} как реквизит цели \target{make-documentation}. Это
допустимо, поскольку \target{make-documentation} также является
абстрактной целью. Такой подход даёт нам ещё одно преимущество: теперь
мы можем легко использовать \utility{df} в других целях.

Существует много примеров удачного применения абстрактных целей.

Сообщения \GNUmake{} довольно трудны для чтения и отладки. На это есть
несколько причин: составление \Makefile{}'ов сверху\hyp{}вниз, в то
время как команды выполняются снизу\hyp{}вверх; кроме того, не
указывается, какая цель выполняется в данный момент. Чтобы исправить
ситуацию, полезно выводить сообщения о начале выполнения основных
целей. Абстрактные цели являются простым средством реализации этой
идеи. Ниже приведён отрывок из \Makefile{}'а командного интерпретатора
\utility{bash}:

{\footnotesize
\begin{verbatim}
$(Program): build_msg $(OBJECTS) $(BUILTINS_DEP) $(LIBDEP)
    $(RM) $@
    $(CC) $(LDFLAGS) -o $(Program) $(OBJECTS) $(LIBS)
    ls -l $(Program)
    size $(Program)

.PHONY: build_msg
build\_msg:
    @printf "#\n# Building $(Program)\n#\n"
\end{verbatim}
}

Поскольку \target{build\_msg} является абстрактной целью, сообщение
выводится непосредственно перед проверкой остальных реквизитов.  Если
бы сообщение о начале сборки было первой командой сценария сборки
\variable{\$(Program)}, то оно выводилось бы только после сборки всех
зависимых файлов. Также важно заметить, что, поскольку абстрактные цели
всегда помечены как требующие обновления, указание абстрактной цели
\target{build\_msg} в качестве реквизита \variable{\$(Program)}
вызовет безусловную сборку этой цели, даже если на самом деле
этого не требуется. В нашем случае это выглядит разумным, поскольку
основная работа заключается в компиляции исходных файлов в объектные,
а на финальном этапе будет производиться только компоновка.

Абстрактные цели также могут быть использованы для улучшения
<<пользовательского интерфейса>> \Makefile{}'а. Имена целей часто
содержат длинные стоки с путями к каталогам, дополнительные имена
компонентов (например, номера версий) и стандартные суффиксы. Это
может сделать указание имени нужной цели довольно неудобным занятием.
Этой проблемы можно избежать, добавив абстрактную цель указав в
качестве её реквизита имя нужной реальной цели.

Есть ряд абстрактных целей, являющихся более или менее стандартными.
Не смотря на то, что их имена являются лишь соглашением, эти цели
встречаются в большинстве \Makefile{}'ов. Список этих целей содержится
в Таблице~\ref{tab:std_phony_targets}.

\begin{table}
\begin{tabular}{|l|l|}
\hline
\textbf{Цель} & \textbf{Назначение}\\
\hline
\texttt{all} & Произвести сборку приложения.\\
\hline
\target{install} & Произвести установку собранного приложения.\\
\hline
\target{clean} & Удалить все бинарные файлы, полученные после сборки.\\
\hline
\target{distclean} & Удалить все файлы, не входящие в базовый дистрибутив.\\
\hline
\target{TAGS} & Создать таблицу тэгов для текстового редактора.\\
\hline
\target{info} & Создать файлы GNU info из файлов Texinfo.\\
\hline
\target{check} & Запустить все тесты, ассоциированные с приложением.\\
\hline
\end{tabular}
\caption{Стандартные абстрактные цели.}\label{tab:std_phony_targets}
\end{table}

Цель \target{TAGS} на самом деле не является абстрактной, поскольку
программы \utility{ctags} и \utility{etags} создают файл с именем
\filename{TAGS}. Эта цель включена в таблицу потому, что это
единственная стандартная реальная цель.

%---------------------------------------------------------------------
% Empty targets
%---------------------------------------------------------------------
\subsection{Пустые цели}
\index{Цели!пустые}
Пустые цели подобны абстрактным в том плане, что позволяют расширить
возможности \GNUmake{}. Абстрактные цели всегда требуют обновления и
вызывают сборку всех целей, \emph{зависимых} от абстрактной (т.е.
содержащих её в списке реквизитов). Предположим, однако, что у нас
есть команда, не ассоциированная с файлом, которую нужно выполнять
время от времени, причём зависимые цели не должны при этом
обновляться. Для этого мы можем воспользоваться целью, ассоциированной
с пустым файлом:

{\footnotesize
\begin{verbatim}
prog: size prog.o
    $(CC) $(LDFLAGS) -o $@ $^

size: prog.o
    size $^
    touch size
\end{verbatim}
}

Заметим, что правило \target{size} использует программу
\utility{touch} после своего завершения. Пустой файл используется
только для хранения времени последней модификации, и \GNUmake{} будет
выполнять правило \target{size} только в том случае, если файл
\filename{prog.o} подвергся изменению. Более того, спецификация
\target{size} как реквизита \filename{prog} будет вызывать обновление
\target{prog} только в том случае, если соответствующий объектный файл
изменялся.

\index{Переменные!автоматические!\${}?@\variable{\${}?}}
Пустые файлы бывают полезны в сочетании с автоматической переменной
\variable{\$?}. Мы обсудим автоматические переменные в разделе
<<\nameref{sec:automatic_vars}>>, но краткое описание этой переменной
здесь не повредит. Внутри сценария сборки каждого правила \GNUmake{}
определяет переменную \variable{\$?} как множество реквизитов, имеющих
более позднюю дату модификации, чем цель.  Вот пример правила,
печатающего имена всех файлов, изменившихся с момента последнего
выполнения команды \command{make print}:

{\footnotesize
\begin{verbatim}
print: *.[hc]
    lpr $?
    touch $@
\end{verbatim}
}
