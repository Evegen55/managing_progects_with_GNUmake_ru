%%--------------------------------------------------------------------
%% Implicit rules database
%%--------------------------------------------------------------------
\section{База данных неявных правил}
\label{sec:implicit_rule_db}

\index{База данных!неявных правил}
GNU \GNUmake{} 3.80 содержит примерно 90 встроенных неявных правил
(шаблонных и суффиксных), предназначенных для работы с исходными
файлами \Clang{}, \Cplusplus{}, Pascal, \FORTRAN{}, ratfor, Modula,
Texinfo, \TeX{} (включая инструменты \utility{tangle} и
\utility{weave}), Emacs Lisp, RCS и SCCS, а также правила для
поддержки программ, предназначенных для работы с этими языками:
\utility{cpp}, \utility{as}, \utility{yacc},  \utility{lex},
\utility{tangle}, \utility{weave} и инструменты для работы с
\utility{dvi}.

Если вы используете одну из этих программ, то, возможно, вас вполне
устроят возможности, предоставляемые встроенными правилами. Если же вы
используете некоторые не поддерживаемые языки наподобие \Java{} или
XML, вам придётся писать правила самим. Впрочем, обычно для добавления
поддержки языка достаточно написать всего несколько простых правил.

Чтобы увидеть встроенные правила \GNUmake{}, нужно запустить его с
\index{Опции!print-data-base@\command{-{}-print-data-base (-p)}}
опцией \command{-{}-print\hyp{}data\hyp{}base} (или просто
\command{-p}). Вывод составит около тысячи строк текста: после номера
версии и текста лицензии \GNUmake{} выведет на экран определения всех
переменных с описанием их <<происхождения>>. Например, переменные
могут быть взяты из окружения, являться стандартными или
автоматическими. После описания переменных последуют правила. Текущий
формат правил GNU \GNUmake{} выглядит следующим образом:

{\footnotesize
\begin{verbatim}
%: %.C
#  Команды для выполнения (встроенные):
    $(LINK.C) $^ $(LOADLIBES) $(LDLIBS) -o $@
\end{verbatim}
}

Комментарии к правилам, определённым в \Makefile{}, будут содержать
имя файла и номер строки, в которых эти правила определены:

{\footnotesize
\begin{verbatim}
%.html: %.xml
#  Команды для выполнения (из `Makefile', строка 168):
    $(XMLTO) $(XMLTO\_FLAGS) html-nochunks $<
\end{verbatim}
}

%---------------------------------------------------------------------
% Working with implicit rules
%---------------------------------------------------------------------
\subsection{Работа с неявными правилами}
Встроенные правила применяются каждый раз, когда рассматривается цель,
для которой не указан сценарий сборки. Таким образом, использовать
встроенные правила очень просто~--- достаточно не указывать команд при
добавлении цели в \Makefile{}. Это будет сигналом для \GNUmake{},
призывающим к поиску подходящего правила в базе данных встроенных
правил. Обычно это приводит к нужному результату, но в редких случаях
ваша среда разработки может породить некоторые проблемы.  Предположим,
у вас имеется смешанная среда разработки, состоящая из исходных файлов
C и Lisp. Если файлы \filename{editor.l} и \filename{editor.c}
находятся в одном каталоге (например, один из них является
низкоуровневой реализацией, к которой имеет доступ другой), \GNUmake{}
будет считать, что файл с исходным кодом на Lisp на самом деле
является файлом \utility{flex} (повторим, \utility{flex} использует
файлы с расширением \filename{.l}), а исходный файл \Clang{}~---
результат запуска \utility{flex}. Если файл \filename{editor.o}
является целью, а \filename{editor.l} модифицировался позднее
\filename{editor.c}, \GNUmake{} попытается обновить исходный файл
\Clang{} выводом команды \utility{flex}, заместив ваш исходный код.

Чтобы избежать этой проблемы, вы можете удалить из базы данных
правила, вызывающие \utility{flex}, следующим образом:

{\footnotesize
\begin{verbatim}
%.o: %.l
%.c: %.l
\end{verbatim}
}

Шаблонное правило без сценария сборки удаляет правило из базы данных
\GNUmake{}. На практике ситуации, подобные описанной, встречаются
крайне редко. Тем не менее, важно помнить, что правила из встроенной
базы данных могут взаимодействовать с вашими \Makefile{}'ами
неожиданным для вас образом.

Мы уже рассмотрели несколько примеров того, как \GNUmake{} выстраивает
цепочки правил для сборки цели. Такое поведение может порождать
довольно сложные конструкции. Когда \GNUmake{} рассматривает варианты
сборки цели, происходит поиск неявных правил, шаблону цели которых
соответствует имя текущей цели. Для каждого подходящего шаблона цели
\GNUmake{} осуществляет проверку соответствия реквизитов. Таким
образом, проверка реквизитов осуществляется \emph{сразу} после
нахождения подходящего шаблона цели. Если реквизиты найдены, правило
применяется. Для некоторых шаблонов цели может быть несколько
возможных видов реквизитов. Например, файлы с расширением
\filename{.o} можно получить из файлов с расширением \filename{.c},
\filename{.cc}, \filename{.cpp}, \filename{.p}, \filename{.f},
\filename{.r}, \filename{.s} и \filename{.mod}. Если исходные файлы не
обнаружены при переборе всех возможных вариантов, \GNUmake{}
произведёт повторный поиск правил, рассматривая исходные файлы в
качестве новых целей. Повторяя этот поиск рекурсивно, \GNUmake{}
выстроит цепь правил, позволяющих произвести сборку цели. Мы уже имели
возможность убедиться в этом на примере файла \filename{lexer.o}:
\GNUmake{} смог получить \filename{lexer.o} из \filename{lexer.l} даже
при отсутствующем файле \filename{lexer.c}, вызвав сначала правило
\filename{.l}$\,\,\rightarrow{}$\filename{.c}, а затем правило
\filename{.c}$\,\,\rightarrow{}$\filename{.o}.

Давайте рассмотрим одну из самых впечатляющих цепочек, которую
\GNUmake{} может породить с помощью встроенной базы данных правил.
Сначала создадим пустой исходный файл \utility{yacc} и зарегистрируем
его в системе контроля ревизий RCS командой \utility{ci}:

\begin{alltt}
\footnotesize
\$ \textbf{touch foo.y}
\$ \textbf{ci foo.y}
foo.y,v  <--  foo.y
.
initial revision: 1.1
done
\end{alltt}

Теперь попросим \GNUmake{} создать исполняемый файл \filename{foo}.
\index{Опции!just-print@\command{-{}-just-print (-n)}}
Опция \command{-{}-just\hyp{}print} (или просто \command{-n})
означает, что от \GNUmake{} требуется лишь описать, какие действия
будут выполнены.  Заметим, что у нас нет \Makefile{}'а и исходного
кода, только RCS-файл.

\begin{alltt}
\footnotesize
\$ \textbf{make -n foo}
co  foo.y,v foo.y
foo.y,v  -->  foo.y
revision 1.1
done
bison -y  foo.y
mv -f y.tab.c foo.c
gcc -c -o foo.o foo.c
gcc foo.o -o foo
rm foo.c foo.o foo.y
\end{alltt}

Следуя по цепочке неявных правил и реквизитов, \GNUmake{} определяет,
что сборка исполняемого файла \filename{foo} возможна при наличии
объектного файла \filename{foo.o}, который можно получить из исходного
файла \filename{foo.c}. В свою очередь, \filename{foo.c} может быть
получен из файла \filename{yacc} \filename{foo.y}, доступного при
извлечении его из файла RCS \filename{foo.y,v}, имеющегося в наличии.
Составив план действий, \GNUmake{} выполняет извлечение
\filename{foo.y} с помощью команды \utility{co}, преобразует его в
исходный файл \filename{foo.c} командой \utility{bison}, компилирует
полученный исходный файл C в объектный файл \filename{foo.o} вызовом
\utility{gcc} и производит компоновку для получения исполняемого файла
\filename{foo} повторным вызовом \utility{gcc}. Всё это происходит с
использованием лишь встроенной базы данных правил. Впечатляет.

Файлы, порождаемые применением цепочки правил, называются
\emph{промежуточными} и обрабатываются \GNUmake{} особым образом.
Во-первых, поскольку промежуточные файлы не специфицируются в качестве
целей (иначе они бы не были промежуточными), \GNUmake{} никогда не
удовлетвориться просто сборкой этого файла. Во-вторых, поскольку
\GNUmake{} создаёт эти файлы самостоятельно как побочные эффекты
сборки цели, такие файлы должны быть удалены перед завершением работы.
Вы можете убедиться в этом, посмотрев на последнюю строку предыдущего
примера.

%---------------------------------------------------------------------
% Rule structure
%---------------------------------------------------------------------
\subsection{Структура правил}
Встроенные правила имеют стандартную структуру, направленную на
предоставление возможности простой настройки этих правил.
Рассмотрим сначала общую структуру, затем обсудим тонкости настройки.
Ниже представлено уже знакомое правило компиляции исходного файла
\Clang{} в объектный файл:

{\footnotesize
\begin{verbatim}
%.o: %.c
    $(COMPILE.c) $(OUTPUT_OPTION) $<
\end{verbatim}
}

Настройка этого правила осуществляется за счёт переменных, используемых
им. Мы видим две переменные, однако переменная
\variable{\$(COMPILE.c)}, например, определена через другие переменные:

{\footnotesize
\begin{verbatim}
COMPILE.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET\_ARCH) -c
CC = gcc
OUTPUT_OPTION = -o $@
\end{verbatim}
}

Таким образом, замена компилятора языка \Clang{} может быть
произведена изменением значения переменной \variable{CC}. Другие
переменные используются для определения опций компиляции
(\variable{CFLAGS}), опций препроцессора (\variable{CPPFLAGS}) и
архитектурно\hyp{}зависимых опций (\variable{TARGET\_ARCH}).

Все переменные, использующиеся во встроенных правилах, нацелены на
максимально простую настройку правил. По этой причине очень важно
быть осторожным при определении значений этих переменных в вашем
\Makefile{}'е. Если вы будете определять переменные <<по наитию>>,
вы можете нарушить возможность настройки правил конечным
пользователем. Рассмотрим пример присваивания в \Makefile{}'е:

{\footnotesize
\begin{verbatim}
CPPFLAGS = -I project/include
\end{verbatim}
}

Если пользователь хочет самостоятельно определить значение переменной
в командной строке, он обычно поступает следующим образом:

\begin{alltt}
\footnotesize
\$ \textbf{make CPPFLAGS=-DDEBUG}
\end{alltt}

Однако такой вызов случайно удалит опцию \command{-I} (которая,
предположительно, необходима для компиляции) поскольку значения
переменных, определённые в командной строке, перекрывают все другие
присваивания этим переменным\footnote{Для более подробных сведений о
присваиваниях в командной строке следует обратиться к
разделу <<\nameref{sec:where_vars_come_from}>>.}. Таким образом,
ненадлежащее определение переменной \variable{CPPFLAGS} нарушило
возможность настройки, на наличие которой рассчитывает б\'{о}льшая
часть пользователей. Вместо использования простых присваиваний,
рассмотрим переопределение переменной компиляции с добавлением новых
переменных:

{\footnotesize
\begin{verbatim}
COMPILE.c = $(CC) $(CFLAGS) $(INCLUDES) $(CPPFLAGS) $(TARGET_ARCH) -c
INCLUDES = -I project/include
\end{verbatim}
}

Ещё одним выходом из ситуации является использование доопределения
переменных вместо присваивания, этот подход обсуждается в разделе
<<\nameref{sec:other_types_of_assign}>> главы~\ref{chap:vars}.

%---------------------------------------------------------------------
% Implicit rules for source control
%---------------------------------------------------------------------
\subsection{Неявные правила для управления ревизиями}
В \GNUmake{} реализована на уровне встроенных правил поддержка двух
\index{RCS} \index{SCCS}
систем контроля ревизий: RCS и SCCS. Складывается впечатление, что
искусство управления исходным кодом на текущем этапе своего развития
и современная компьютерная инженерия оставили \GNUmake{} далеко позади.
На практике поддержка управления ревизиями в \GNUmake{} практически
не используется. И на это есть ряд причин.

Во\hyp{}первых, инструменты контроля ревизий, поддерживаемые
\GNUmake{}, RCS и SCCS, в прошлом весьма значимые и ценные, были
\index{CVS}
повсеместно вытеснены CVS (Concurrent Version System) или
коммерческими инструментами. Несмотря на то, что CVS использует RCS
для внутреннего управления одиночными файлами, прямое использование
RCS порождает значительные проблемы, когда проект состоит из более чем
одного каталога, или в нём задействовано более одного разработчика. В
частности, CVS была разработана для заполнения пробелов в
функциональности RCS в упомянутых аспектах. Поддержки CVS в \GNUmake{}
никогда не было, и это, возможно, является правильным
решением\footnote{CVS, в свою очередь, постепенно вытесняется более
современными инструментами. На данный момент наиболее часто
встречается система управления исходным кодом
\index{Subversion}
Subversion (\filename{\url{http://subversion.tiqris.org}})
(прим. автора).}.

Общепризнано, что жизненный цикл разработки программного обеспечения
становится всё более сложным. Приложения редко плавно продвигаются от
одного релиза к другому. Как правило, одновременно может
использоваться (и, следовательно, требовать исправления ошибок)
несколько версий приложения, в то время как ещё несколько версий могут
находиться в активной разработке. CVS предоставляет богатые
возможности управления параллельной разработкой программного
обеспечения. Однако это требует от разработчика чёткого осознания
того, над какой версией исходного кода он работает. Если бы \GNUmake{}
автоматически извлекал из хранилища исходный код для компиляции, сразу
бы вставали вопросы актуальности извлечённой версии и совместимости
этой версии с кодом, расположенным в рабочих каталогах разработчика.
Во многих проектах разработчики работают с тремя и более различными
версиями программного продукта в течение одного дня. Проверка
целостности сложной системы достаточно сложна и без наличия
инструмента, безмолвно изменяющего ваш исходный код.

К тому же, одной из самых важных возможностей CVS является возможность
доступа к удалённому хранилищу. В большинстве проектов CVS
хранилище (база данных версионных файлов) располагается на сервере,
а не на машине разработчика. Несмотря на то, что удалённый доступ
достаточно быстр (по крайней мере, в локальных сетях), запуск
\GNUmake{}, проверяющего каждый файл на удалённом сервере, не является
хорошей идеей, поскольку производительность упадёт катастрофически.

Таким образом, можно использовать встроенные правила для довольно
прозрачного взаимодействия с RCS и SCCS, но правил для доступа к
хранилищам CVS для поиска файлов не существует. По большому счёту,
даже если бы такие правила существовали, им трудно было бы найти
разумное применение. С другой стороны, использование CVS для
управления версиями \Makefile{}'ов чрезвычайно полезно и порождает
много интересных применений, таких как проверка правильности помещения
файла в хранилище, управление нумерацией релизов и корректное
выполнение автоматического тестирования. Все это возможно при
использовании CVS авторами \Makefile{}'ов, а не за счёт интеграции
\GNUmake{} с CVS.

%---------------------------------------------------------------------
% A simple help command
%---------------------------------------------------------------------
\subsection{Пример простой справки}
Большие \Makefile{}'ы могут содержать много целей, трудных для
запоминания. Одним из способов устранения этой проблемы является
выбор в качестве цели по умолчанию абстрактной цели вывода краткой
справки. Однако поддержка текста этой справки в актуальном состоянии
является довольно утомительным занятием. К счастью, для составления
справки могут быть использованы команды из встроенной базы данных
правил \GNUmake{}. Ниже приведён пример цели, выводящей отсортированный
список доступных целей:

{\footnotesize
\begin{verbatim}
# help - цель по умолчанию
.PHONY: help
help:
    $(MAKE) --print-data-base --question |            \
    $(AWK) '/\^[\^.\%][-A-Za-z0-9\_]*:/               \
           { print substr($$1, 1, length($$1)-1) }' | \
    $(SORT) |                                         \
    $(PR) --omit-pagination --width=80 --columns=4
\end{verbatim}
}

Сценарий состоит из одного конвейера программ. Список правил \GNUmake{}
\index{Опции!print-data-base@\command{-{}-print-data-base (-p)}}
выводится при помощи ключа \command{-{}-print\hyp{}data\hyp{}base}, ключ
\index{Опции!question@\command{-{}-question (-q)}}
\command{-{}-question} исключает выполнение сценариев сборки. Затем
база данных пропускается через простой сценарий \utility{awk},
извлекающий из потока правил все цели, имена которых не начинаются
с символов процента или точки (то все шаблонные и суффиксные правила,
соответственно) и вырезающий всю прочую информацию в строке. Наконец,
цели сортируются по имени и выводятся в четыре колонки.

Другим возможным решением проблемы является применение специального
сценария \utility{awk} непосредственно к \Makefile{}'у. Это потребует
специальной обработки включения \Makefile{}'ов (см. раздел
<<\nameref{sec:include_directive}>> главы~\ref{chap:vars}) и сделает
невозможным обработку правил, созданных самим \GNUmake{} на основе
шаблонных и суффиксных правил. Версия, представленная выше, избавлена
от этих недостатков благодаря вызову \GNUmake{}, осуществляющему все
необходимые действия самостоятельно.
