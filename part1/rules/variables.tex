%%--------------------------------------------------------------------
%% Variables
%%--------------------------------------------------------------------
\section{Переменные}

Рассмотрим некоторые из тех переменных, которые мы использовали в
наших примерах. Самые простые из них имели следующий синтаксис:

{\footnotesize
\begin{alltt}
\emph{\$(имя-переменной)}
\end{alltt}
}

Эта запись означает, что мы хотим получить значение переменной с
именем \variable{имя\hyp{}переменной}. Переменные могут содержать
практически произвольный текст, а имена переменных допускают
использование большинства символов, включая знаки пунктуации.
Например, переменная, содержащая имя команды для компиляции исходного
кода на языке \Clang{}, имеет имя \variable{COMPILE.c}. Как правило,
для подстановки значения переменной её имя окружают символами
\command{\$(} и \command{)}. В случае, когда имя переменной состоит из
одного символа, скобки можно опускать.

Как правило, \Makefile{}'ы содержат много объявлений переменных. Кроме
того, существует множество переменных, определяемых непосредственно
\GNUmake{}. Некоторые из них предназначены для контроля пользователем
поведения \GNUmake{}, другие выставляются \GNUmake{} для
взаимодействия с пользовательским \Makefile{}'ом.

%---------------------------------------------------------------------
% Automatic variables
%---------------------------------------------------------------------
\subsection*{Автоматические переменные}
\label{sec:automatic_vars}

\index{Переменные!автоматические}
\newword{Автоматические переменные} вычисляются \GNUmake{} заново для
каждого исполняемого правила. Они предоставляют доступ к цели и списку
реквизитов, избавляя от необходимости явно указывать имена файлов.
Автоматические переменные полезны для избежания дублирования кода и
необходимы для написания шаблонных правил (их мы рассмотрим позже).

Существует семь автоматических переменных:

\begin{description}
%---------------------------------------------------------------------
% $@
%---------------------------------------------------------------------
\item[\variable{\$@}] \hfill \\
%---------------------------------------------------------------------
Имя файла цели правила. Если цель является элементом архива (archive
member), то <<\variable{\$@}>> обозначает имя файла архива.

%---------------------------------------------------------------------
% $%
%---------------------------------------------------------------------
\item[\variable{\$\%}] \hfill \\
%---------------------------------------------------------------------
Для целей, являющихся элементами архива, обозначает имя
элемента. Если цель не является элементом архива, то \variable{\$\%}
содержит пустое значение.

%---------------------------------------------------------------------
% $<
%---------------------------------------------------------------------
\item[\variable{\${}<}] \hfill \\
%---------------------------------------------------------------------
Имя первого реквизита в списке реквизитов.

%---------------------------------------------------------------------
% $<
%---------------------------------------------------------------------
\item[\variable{\${}?}] \hfill \\
%---------------------------------------------------------------------
Имена всех реквизитов, имеющих более позднюю дату модификации, чем
цель.

%---------------------------------------------------------------------
% $^
%---------------------------------------------------------------------
\item[\variable{\$\^}] \hfill \\
%---------------------------------------------------------------------
Имена всех реквизитов, разделённые пробелами. В списке отсутствуют
повторения элементов, поскольку для большинства задач (копирование,
компиляция и т.д.) повторения нежелательны.

%---------------------------------------------------------------------
% $+
%---------------------------------------------------------------------
\item[\variable{\$+}] \hfill \\
%---------------------------------------------------------------------
Подобно \variable{\$?}, содержит список имён реквизитов, разделённых
пробелами, с тем отличием, что может содержать повторения. Эта
переменная была введена для специфических ситуаций, таких как
компоновка, где повторение аргументов несёт особый смысл.

%---------------------------------------------------------------------
% $*
%---------------------------------------------------------------------
\item[\texttt{\$*}] \hfill \\
%---------------------------------------------------------------------
Основа имени файла цели. Как правило, основой является имя файла с
отброшенным суффиксом (мы рассмотрим вычисление основы в разделе
<<\nameref{sec:pattern_rules}>>). Использование этой переменной вне
шаблонных правил настоятельно не рекомендуется.
%---------------------------------------------------------------------
\end{description}

Кроме того, каждая из вышеперечисленных переменных имеет два варианта
для совместимости с другими версиями \GNUmake{}. Один из этих вариантов
возвращает название каталога, в которой находится соответствующий
файл. Этот вариант обозначается добавлением символа <<D>> к имени
переменной: \variable{\$(@D)}, \variable{\${}(<D)} и т.д. Второй
вариант возвращает только имена файлов без имени каталога, в котором
они находятся. Этот вариант обозначается добавлением символа <<F>> к
имени переменной: \variable{\$(@F)}, \variable{\$(<F)} и т.д.
Поскольку эти варианты имён содержат более одного символа, они должны
заключаться в круглые скобки. GNU \GNUmake{} предоставляет более
читабельные альтернативы в лице функций \function{dir} и
\function{notdir}. Мы обсудим эти функции в
главе~\ref{chap:functions}.

Вот пример нашего \Makefile{}'а, в котором явно указанные имена
заменены подходящими автоматическими переменными.

{\footnotesize
\begin{verbatim}
count_words: count_words.o counter.o lexer.o -lfl
    gcc $^ -o $@

count_words.o: count_words.c
    gcc -c $<

counter.o: counter.c
    gcc -c $<

lexer.o: lexer.c
    gcc -c $<

lexer.c: lexer.l
    flex -t $< > $@
\end{verbatim}
}
