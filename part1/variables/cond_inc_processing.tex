%%--------------------------------------------------------------------
%% Conditional and include processing
%%--------------------------------------------------------------------
\section{Условная обработка и включения}
\label{sec:cond_inc_processing}
Части \Makefile{}'а могут быть опущены или выбраны для обработки во
время его чтения с помощью директив \newword{условной обработки}.
\index{Директивы!условной обработки}
Условия, контролирующие обработку, могут принимать несколько форм,
таких как <<A определено>> или <<A равно B>>. Например:

{\footnotesize
\begin{verbatim}
# переменная COMSPEC определена только в Windows.
ifdef COMSPEC
  PATH_SEP := ;
  EXE_EXT  := .exe
else
  PATH_SEP := :
  EXE_EXT  :=
endif
\end{verbatim}
}

В предыдущем примере обработается первая ветвь условия только в том
случае, если переменная \variable{COMSPEC} определена. Синтаксис
директив условной обработки имеет две формы:

{\footnotesize
\begin{alltt}
\emph{if-условие}
  текст для обработки если условие выполнено
endif
\end{alltt}
}

{\flushleft и:}

{\footnotesize
\begin{alltt}
\emph{if-условие}
  текст для обработки если условие выполнено
else
  текст для обработки если условие не выполнено
endif
\end{alltt}
}

Значения шаблона \ItalicMono{if-условие} могут быть следующими:

{\footnotesize
\begin{alltt}
ifdef  \emph{имя-переменной}
ifndef \emph{имя-переменной}
ifeq  \emph{тест}
ifneq \emph{тест}
\end{alltt}
}

При использовании директив \directive{ifdef\textbackslash{}ifndef}
\index{Директивы!условной обработки!ifdef@\directive{ifdef}}
\index{Директивы!условной обработки!ifndef@\directive{ifndef}}
\ItalicMono{имя-переменной} не нужно заключать в скобки
(\command{\$( )}). Наконец, значением шаблона \ItalicMono{тест}
может быть одно из следующих выражений:

{\footnotesize
\begin{alltt}
"\emph{a}" "\emph{b}"
(\emph{a},\emph{b})
\end{alltt}
}

В выражениях могут использоваться двойные или одинарные кавычки по
желанию (однако тип открывающейся и закрывающейся кавычки должен
совпадать).

Директивы условной обработки могут быть использованы внутри тела
макросов или в командных сценариях:

{\footnotesize
\begin{verbatim}
libGui.a: $(gui_objects)
    $(AR) $(ARFLAGS) $@ $<
  ifdef RANLIB
    $(RANLIB) $@
  endif
\end{verbatim}
}

Я предпочитаю делать отступ перед директивами условной обработки,
однако неосторожное выравнивание может привести к ошибкам. В
предыдущем примере перед директивами сделан отступ в два пробела, а
заключённые в них команды предваряются символом табуляции. \GNUmake{}
не может распознать команды, не начинающиеся с символа табуляции. Если
директива условной обработки предваряется символом табуляции, она
рассматривается как команда и передаётся в командный интерпретатор.

\index{Директивы!условной обработки!ifeq@\directive{ifeq}}
\index{Директивы!условной обработки!ifneq@\directive{ifneq}}
Директивы \directive{ifeq} и \directive{ifneq} проверяют свои
аргументы на на равенство и неравенство соответственно. Пробелы в
условиях директив могут быть причиной трудноуловимых ошибок. Например,
когда используется форма теста с круглыми скобками, пробел после
запятой не учитывается, тогда как все остальные пробелы имеют
значение:

{\footnotesize
\begin{verbatim}
ifeq (a, a)
  # Равенство
endif

ifeq ( b, b )
  # Неравенство - ` b' != `b '
endif
\end{verbatim}
}

Лично я предпочитаю форму с кавычками:

{\footnotesize
\begin{verbatim}
ifeq "a" "a"
  # Равенство
endif

ifeq 'b' 'b'
  # Тоже равенство
endif
\end{verbatim}
}

Однако иногда случается так, что значение переменной содержит пробел в
начале или в конце. Это может быть источником ошибки, поскольку
сравнение учитывает все символы. Для создания более надёжных
\index{Функции!встроенные!strip@\function{strip}}
\Makefile{}'ов используйте функцию \function{strip}:

{\footnotesize
\begin{verbatim}
ifeq "$(strip $(OPTIONS))" "-d"
  COMPILATION_FLAGS += -DDEBUG
endif
\end{verbatim}
}

%---------------------------------------------------------------------
% include directive
%---------------------------------------------------------------------
\subsection{Директива \directive{include}}
\label{sec:include_directive}
\index{Директивы!include@\directive{include}}
Мы уже встречали директиву \directive{include} в
разделе~<<\nameref{sec:auto_dep_gen}>> главы~\ref{chap:rules}. Теперь
давайте рассмотрим её более детально.

Любой \Makefile{} может включать другие файлы. Наиболее частое
использование этой возможности~--- помещение общих определений
\GNUmake{} в заголовочный файл и включение автоматически составленных
файлов зависимостей. Директива \directive{include} используется
следующим образом:

\begin{alltt}
\footnotesize
include definitions.mk
\end{alltt}

Параметры директивы могут содержать произвольное число файлов, шаблоны
командного интерпретатора и переменные \GNUmake{}.

%---------------------------------------------------------------------
% include and dependencies
%---------------------------------------------------------------------
\subsection{Директива \directive{include} в контексте зависимостей}
Когда \GNUmake{} встречает директиву \directive{include}, он
производит раскрытие шаблонов и подстановку значений переменных, а
затем пытается прочитать подключенные файлы. Если файл существует,
выполнение продолжается. Если же указанный файл не существует,
\GNUmake{} выводит предупреждение и продолжает читать остаток
\Makefile{}'а. Когда весь \Makefile{} прочитан, \GNUmake{}
просматривает базу данных в поисках правила сборки подключаемых
файлов. Если соответствие найдено, \GNUmake{} следует найденному
правилу сборки цели. Если хотя бы один из включаемых файлов был
собран, \GNUmake{} очищает свою базу данных и производит повторное
чтение всего \Makefile{}'а. Если после завершения всего процесса
чтения, сборки и повторного чтения какая-то из директив
\directive{include} завершается неудачей ввиду отсутствующих файлов,
\GNUmake{} завершает своё выполнение с ненулевым кодом возврата.

Мы можем увидеть этот процесс в действии при помощи следующего
примера, состоящего из двух файлов. Мы используем встроенную функцию
\index{Функции!встроенные!warning@\function{warning}}
\function{warning}, для вывода сообщений из \GNUmake{} (эта и многие
другие функции рассмотрены в главе~\ref{chap:functions}). Вот
\Makefile{}:

{\footnotesize
\begin{alltt}
# Простой makefile, включающий файл.
include foo.mk
\$(warning Finished include)

foo.mk: bar.mk
    m4 --define=FILENAME=\${}@ bar.mk > \${}@
\end{alltt}
}

Ниже представлен \filename{bar.mk}, подключаемый в \Makefile{}:

{\footnotesize
\begin{alltt}
# bar.mk - выдать сообщение о чтении файла.
\$(warning Reading FILENAME)
\end{alltt}
}

После запуска \GNUmake{} мы увидим следующий вывод:

{\footnotesize
\begin{alltt}
\$ \textbf{make}
Makefile:2: foo.mk: No such file or directory
Makefile:3: Finished include
m4 --define=FILENAME=foo.mk bar.mk > foo.mk
foo.mk:2: Reading foo.mk
Makefile:3: Finished include
make: `foo.mk' is up to date.
\end{alltt}
}

Первая строка отражает тот факт, что \GNUmake{} не смог найти
включаемый файл, однако, вторая строка показывает, что чтение и
выполнение \Makefile{}'а продолжилось. По завершении чтения \GNUmake{}
обнаружил правило для  создания подключаемого файла,
\filename{foo.mk}, и выполнил соответствующий сценарий. Затем
\GNUmake{} начал весь процесс заново, в этот раз не встретив никаких
трудностей с чтением включаемого файла.

Теперь самое время заметить, что \GNUmake{} интерпретирует \Makefile{}
как потенциальную цель. После того, как \Makefile{} прочитан,
\GNUmake{} ищет правило для сборки текущего \Makefile{}'а.  Если такое
правило находится, \GNUmake{} выполняет соответствующий правилу
сценарий и проверяет, изменился ли текущий \Makefile{}. Если
\Makefile{} изменился, \GNUmake{} производит очистку своего состояния
и считывает \Makefile{} заново, повторяя анализ. Ниже приведён простой
пример бесконечного цикла, основанный на описанном поведении:

{\footnotesize
\begin{verbatim}
.PHONY: dummy

makefile: dummy
    touch $@
\end{verbatim}
}

Когда \GNUmake{} выполняет \Makefile{}, он видит, что файл нуждается в
сборке (поскольку цель \target{dummy} является абстрактной) и
выполняет команду \utility{touch}, которая изменяет время последней
модификации \Makefile{}'а. Затем \GNUmake{} читает файл и
обнаруживает, что он требует обновления\ldots{}. В общем, вы поняли.

Где \GNUmake{} ищет включаемые файлы? Если аргумент директивы
\directive{include} является абсолютным путём, то \GNUmake{} открывает
файл по указанному пути. Если указан относительный путь, \GNUmake{}
ищет файл относительно текущего рабочего каталога. Если файл не
найден, то осуществляется поиск в каталогах, указанных при помощи опции
\index{Опции!include-dir@\command{-{}-include-dir (-I)}}
\command{-{}-inc\-lu\-de\hyp{}dir} (или просто \command{-I}). Если
файл не найден и там, производится поиск в стандартных каталогах,
указанных при компиляции \GNUmake{}: \filename{/usr/local/include},
\filename{/usr/gnu/include}, \filename{/usr/include}. Пути могут
отличаться, поскольку они зависят от опций компиляции \GNUmake{}.

Если \GNUmake{} не может найти файл и не может собрать его с помощью
правила, происходит выход с ненулевым кодом возврата. Если вы хотите,
чтобы \GNUmake{} игнорировал включение несуществующих файлов, добавьте
знак дефиса перед директивой \directive{include}:

\begin{alltt}
\footnotesize
-include i-may-not-exist.mk
\end{alltt}

Для обратной совместимости с другими версиями \GNUmake{} слово
\index{Директивы!sinclude@\directive{sinclude}}
\index{Директивы!sinclude@\directive{-include}}
\directive{sinclude} является синонимом \directive{-include}.
