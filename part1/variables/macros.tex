%%--------------------------------------------------------------------
%% Macros
%%--------------------------------------------------------------------
\section{Макросы}

Переменные хороши для хранения одиночных строк текста, но что если мы
хотим сохранить многострочное значение, такое, как командный сценарий,
который мы хотим выполнять в нескольких правилах? Например, следующая
последовательность команд может быть использована для создания \Java{}
архива (\filename{jar}) из \filename{.class} файлов:

{\footnotesize
\begin{verbatim}
echo Creating $@...
$(RM) $(TMP_JAR_DIR)
$(MKDIR) $(TMP_JAR_DIR)
$(CP) -r $^ $(TMP_JAR_DIR)
cd $(TMP_JAR_DIR) && $(JAR) $(JARFLAGS) $@ .
$(JAR) -ufm $@ $(MANIFEST)
$(RM) $(TMP_JAR_DIR)
\end{verbatim}
}

В начале длинной последовательности (наподобие предыдущей) я
предпочитаю печатать диагностическое сообщение. Это значительно
упрощает чтение вывода \GNUmake{}. После вывода сообщения мы помещаем
наши \filename{.class} файлы в новый временный каталог, удалив сначала
этот каталог, если он существует\footnote{%
Для достижения наилучшего эффекта переменная \variable{RM} должна
иметь значение \command{rm -rf}. Как правило, по умолчанию она
определена как \command{rm -f}, что безопаснее, но не так эффективно.
Переменная \variable{MKDIR} должна иметь значение \command{mkdir -p}, и
так далее (прим. автора).}, затем создав новый. После этого мы
копируем в этот каталог каталоги\hyp{}реквизиты (и все их
подкаталоги). Затем мы переходим в него и создаём jar\hyp{}архив с
именем цели. Наконец, мы добавляем к архиву файл манифеста и
осуществляем удаление временного каталога. Естественно, мы не хотим
делать копий этой последовательности команд, поскольку в будущем это
может усложнить поддержку. Мы можем рассмотреть вариант
упаковки всех этих команд в рекурсивную переменную, но такой подход
неудобен при поддержке и труден для чтения при выводе \GNUmake{} (вся
последовательность команд будет выведена на экран как одна большая
строка текста).

Вместо этого мы можем использовать <<упакованную последовательность
команд>> GNU \GNUmake{}, созданную при помощи директивы
\directive{define}.  Термин <<упакованная последовательность>> немного
\index{Макрос}
неуклюж, поэтому мы будем называть это \newword{макросом}. На самом
деле макросы~--- это просто ещё один метод определения переменных в
\GNUmake{}, позволяющий помещать символы окончания строки внутрь
значения переменной. Руководство пользователя GNU \GNUmake{}
использует слова \emph{переменная} и \emph{макрос} как синонимы. В
этой книге мы будем использовать термин \emph{макрос} исключительно
для обозначения переменных, определённых с помощью директивы
\directive{define}, если же определение происходит при помощи
оператора присваивания, будет применяться термин \emph{переменная}.

{\footnotesize
\begin{verbatim}
define create-jar
  @echo Creating $@...
  $(RM) $(TMP_JAR_DIR)
  $(MKDIR) $(TMP_JAR_DIR)
  $(CP) -r $^ $(TMP_JAR_DIR)
  cd $(TMP_JAR_DIR) && $(JAR) $(JARFLAGS) $@ .
  $(JAR) -ufm $@ $(MANIFEST)
  $(RM) $(TMP_JAR_DIR)
endef
\end{verbatim}
}

За директивой \directive{define} следуют имя макроса и новая строка.
Тело макроса содержит весь текст вплоть до слова \directive{endef},
которое должно находиться в отдельной строке. Макросы вычисляются
практически также, как и другие переменные, за тем исключением, что в
контексте командного сценария в начало каждой строки добавляется
символ табуляции. Вот пример, использующий эту особенность:

{\footnotesize
\begin{verbatim}
$(UI_JAR): $(UI_CLASSES)
    $(create-jar)
\end{verbatim}
}

Обратите внимание на символ \command{@}, добавленный перед командой
\command{echo}. \GNUmake{} не выводит команды с таким префиксом перед
их выполнением. Когда мы запустим \GNUmake{}, мы не увидим в выводе
команды \command{echo}, только результат её выполнения. Если префикс
\command{@} применяется внутри макроса, то его действие
распространяется только на ту строку, которую он предваряет. Однако,
если применить его при вызове макроса, его действие будет
распространятся на всё тело макроса:

{\footnotesize
\begin{verbatim}
$(UI_JAR): $(UI_CLASSES)
    @$(create-jar)
\end{verbatim}
}

Одним из результатов выполнения предыдущего примера будет следующий
вывод:

{\footnotesize
\begin{alltt}
\$ \textbf{make}
Creating ui.jar...
\end{alltt}
}

Использование префикса \command{@} рассматривается более детально в
разделе <<\nameref{sec:command_modifiers}>> главы~\ref{chap:commands}.
