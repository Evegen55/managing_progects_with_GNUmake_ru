%%--------------------------------------------------------------------
%% Dependency generation
%%--------------------------------------------------------------------
\section{Генерация зависимостей}

Небольшое введение в технику автоматической генерации зависимостей
можно найти в разделе <<\nameref{sec:auto_dep_gen}>>
главы~\ref{chap:rules}, однако это введение умалчивает о ряде важных
проблем. Этот раздел описывает несколько альтернатив
простого решения, рассмотренного нами ранее\footnote{%
Б\'{о}льшая часть материала, рассмотренного в этом разделе, была
разработана Томом Троми (Tom Tromey, tromey@cygnus.com) для проекта
GNU \utility{automake} и взята из прекрасной сводной статьи Пола Смита
(Paul Smith, программист, осуществляющий поддержку GNU \GNUmake{}),
прочитать которую можно на его веб-сайте
\filename{\url{http://make.paulandlesley.org}}. (прим. автора)}.
В частности, описанный ранее подход, предлагаемый руководством
пользователя GNU \GNUmake{}, обладает следующими недостатками:

\begin{itemize}
%---------------------------------------------------------------------
\item Он неэффективен. Когда \GNUmake{} обнаруживает, что файл
зависимостей не существует или устарел, он обновляет этот файл и
стартует заново. Повторное чтение \Makefile{}'а может быть
неэффективным, если во время чтения осуществляется много задач или
требуется анализ графа зависимостей.
%---------------------------------------------------------------------
\item Каждый раз при запуске сборки после добавления новых исходных
файлов \GNUmake{} выдаёт предупреждение. На момент запуска файл
зависимостей, ассоциированный с новым исходным файлом, ещё не
существует, поэтому при попытке прочитать этот файл зависимостей
\GNUmake{} выдаст предупреждение до того, как осуществит генерацию
файла. Это не критично, но порой очень раздражает.
%---------------------------------------------------------------------
\item Если вы удалите исходный файл, при попытке осуществления сборки
\GNUmake{} будет завершать своё выполнение с ошибкой. Причиной ошибки
является существование файл зависимостей, содержащего удалённый
исходный файл в качестве реквизита. Поскольку \GNUmake{} не может
найти удалённый файл и не имеет правила для его сборки, выдаётся
следующее сообщение об ошибке:

{\footnotesize
\begin{verbatim}
make: *** No rule to make target foo.h, needed by foo.d. Stop.
\end{verbatim}
}

Более того, из-за этой ошибки \GNUmake{} не сможет обновить файл
зависимостей. Единственный возможный выход~--- удалить файл
зависимостей вручную, однако обычно найти эти файлы нелегко, и
пользователи, как правило, удаляют все файлы зависимостей и
осуществляют чистую сборку. Та же проблема возникает при
переименовании файлов.

Обратите внимание на то, что эта проблема чаще всего появляется при
удалении или переименовании заголовочных (\filename{.h}) файлов.
Причина этого заключается в том, что \filename{.c} файлы будут удалены
из списка зависимостей автоматически и не вызовут проблем при сборке.
%---------------------------------------------------------------------
\end{itemize}

%---------------------------------------------------------------------
% Tromey's way
%---------------------------------------------------------------------
\subsection{Решение Троми}

Давайте разбирать проблемы по очереди.

Как нам избежать повторного запуска \GNUmake{}?

После небольшого размышления можно понять, что повторный запуск
\GNUmake{} не требуется. Если файл зависимостей обновлён, это значит,
что хотя бы один его реквизит изменился, что, в свою очередь, значит,
что нам нужно собрать целевой файл заново. На данном этапе \GNUmake{}
не нуждается в дополнительной информации о зависимостях, поскольку она
не изменит его поведения. Однако нам нужно, чтобы файл зависимостей
был обновлён, чтобы при следующем запуске \GNUmake{} обладал полной
информацией о зависимостях.

Поскольку в текущей сборке нам не нужен файл зависимостей, мы можем
обновить его при сборке целевого файла. Мы можем добиться этого путём
соответствующего изменения правила компиляции:

{\footnotesize
\begin{verbatim}
# $(call make-depend,source-file,object-file,depend-file)
define make-depend
  $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $1 | \
  $(SED) 's,\($$(notdir $2)\) *:,$$(dir $2) $3: ,' > $3.tmp
  $(MV) $3.tmp $3
endef

%.o: %.c
    $(call make-depend,$<,$@,$(subst .o,.d,$@))
    $(COMPILE.c) -o $@ $<
\end{verbatim}
}

Мы реализовали возможность создания файлов зависимостей в форме
функции \function{make-depend}, принимающей в качестве аргументов
имена исходного и объектного файлов, а также имя файла
зависимостей. Это предоставляет нам максимальную гибкость на случай,
если мы решим повторно использовать эту функцию в другом контексте.
После подобного изменения правила компиляции следует удалить шаблонное
правило \command{\%.d: \%.c}, это позволит избежать повторного
составления файла зависимостей.

Теперь объектный файл и файл зависимостей логически связаны: если
существует один из них, должен существовать и второй. Таким образом,
нам не нужно больше беспокоиться об отсутствии файла зависимостей.
Если он не существует, объектный файл тоже не существует, оба этих
файла будут созданы при следующей сборке. Теперь мы можем игнорировать
любые предупреждения, возникающие из-за отсутствия файлов
зависимостей.

В разделе <<\nameref{sec:cond_inc_processing}>> главы~\ref{chap:vars}
была описана альтернативная форма директивы \directive{include},
\index{Директивы!sinclude@\directive{-include}}
\index{Директивы!sinclude@\directive{sinclude}}
\directive{-include} или (\directive{sinclude}), игнорирующая ошибки и
не выдающая предупреждений:

{\footnotesize
\begin{verbatim}
ifneq "$(MAKECMDGOALS)" "clean"
  -include $(dependencies)
endif
\end{verbatim}
}

Это решает вторую проблему~--- раздражающие сообщения, возникающие при
отсутствии файлов зависимостей.

Наконец, мы можем избежать предупреждений об отсутствующих реквизитах
с помощью небольшого трюка. Трюк заключается в спецификации для
отсутствующего файла цели без реквизитов и команд. Предположим для
примера, что генератор зависимостей создал следующую зависимость:

{\footnotesize
\begin{verbatim}
target.o target.d: header.h
\end{verbatim}
}

Допустим теперь, что в результате рефакторинга кода файл
\filename{header.h} был удалён. При следующем запуске \Makefile{}'а мы
получим следующую ошибку:

{\footnotesize
\begin{verbatim}
make: *** No rule to make target header.h, needed by target.d. Stop.
\end{verbatim}
}

Однако если мы добавим цель \target{header.h}, не имеющую
ассоциированного командного сценария, ошибки не будет:

{\footnotesize
\begin{verbatim}
target.o target.d: header.h
header.h:
\end{verbatim}
}

Это происходит потому, что если файл \filename{header.h} не
существует, он просто помечается устаревшим и все цели, имеющие этот
файл в качестве реквизита, собираются заново. Таким образом, файл
зависимостей будет создан заново и уже не будет содержать
\filename{header.h}. Если же файл \filename{header.h} существует,
\GNUmake{} просто продолжит выполнение.  Теперь всё, что нужно
сделать~--- это убедиться в том, что каждый реквизит имеет
соответствующее пустое правило. Этот вид привил впервые встретился нам
в разделе <<\nameref{sec:phony_targets}>> главы~\ref{chap:rules}. Ниже
приведена версия функции \function{make-depend}, добавляющая новую
цель:

{\footnotesize
\begin{verbatim}
# $(call make-depend,source-file,object-file,depend-file)
define make-depend
  $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $1 |        \
  $(SED) 's,\($$(notdir $2)\) *:,$$(dir $2) $3: ,' > $3.tmp
  $(SED) -e 's/#.*//'                                       \
         -e 's/^[^:]*: *//'                                 \
         -e 's/ *\\$$$$//'                                  \
         -e '/^$$$$/ d'                                     \
         -e 's/$$$$/ :/' $3.tmp >> $3.tmp
  $(MV) $3.tmp $3
endef
\end{verbatim}
}

Чтобы создать дополнительные правила, мы применяем новую команду
\utility{sed} к файлу зависимостей. Этот кусок кода \utility{sed}
осуществляет пять преобразований: \begin{enumerate} \item Удаляет
комментарии.  \item Удаляет целевые файлы и соответствующие пробелы.
\item Удаляет оконечные пробелы.  \item Удаляет пустые строки.  \item
Добавляет в конец каждой строки двоеточие.  \end{enumerate} (GNU
\utility{sed} может читать файл и добавлять к нему текст в одной
команде, предохраняя нас от необходимости использования второго
временного файла. Этот код может не работать в других системах.)
Новая версия команды \utility{sed} принимает на вход текст следующего
вида:

{\footnotesize
\begin{verbatim}
# любые комментарии
target.o target.d: prereq1 prereq2 prereq3 \
    prereq4
\end{verbatim}
}

{\flushleft и преобразует его к виду:}

{\footnotesize
\begin{verbatim}
prereq1 prereq2 prereq3:
prereq4:
\end{verbatim}
}

Таким образом, функция \function{make-depend} добавляет новые цели к
исходному файлу зависимостей. Это решает проблему <<No rule to make
target>>.

%---------------------------------------------------------------------
% makedepend programs
%---------------------------------------------------------------------
\subsection{Программы \utility{makedepend}}

Всё это время мы могли использовать опцию \command{-M}, которой
обладает б\'{о}льшая часть компиляторов, но что бы мы делали, если бы
этой опции не существовало? Кроме того, есть ли более удачные решения,
чем использование опции \command{-M}?

На данный момент практически все компиляторы языка \Clang{} имеют
поддержку генерации зависимостей исходных файлов, однако не так давно
всё было иначе. На заре проекта X Window System его разработчики
создали программу \utility{makedepend}, определяющую зависимости для
заданного набора исходных файлов \Clang{} и \Cplusplus{}. Доступ к
этой программе можно получить бесплатно через сеть Internet.
Использовать эту программу немного неудобно, поскольку она написана
так, чтобы добавлять свой вывод в \Makefile{}, чего нам не хотелось
бы. Программа \utility{makedepend} подразумевает, что объектные файлы
располагаются в том же каталоге, что и исходные. Это, в свою очередь,
означает, что нам нужно изменить сценарий \utility{sed}:

{\footnotesize
\begin{verbatim}
# $(call make-depend,source-file,object-file,depend-file)
define make-depend
  $(MAKEDEPEND) -f- $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) $1 | \
  $(SED) 's,^.*/\([^/]*\.o\) *:,$(dir $2)\1 $3: ,' > $3.tmp
  $(SED) -e 's/#.*//'                                         \
         -e 's/^[^:]*: *//'                                   \
         -e 's/ *\\$$$$//'                                    \
         -e '/^$$$$/ d'                                       \
         -e 's/$$$$/ :/' $3.tmp >> $3.tmp
  $(MV) $3.tmp $3
endef
\end{verbatim}
}

Опция \command{-f-} программы \utility{makedepend} означает, что
информация о зависимостях должна выводиться на стандартный поток
вывода.

Альтернативой использованию \utility{makedepend} или вашего
собственного компилятора является использование компилятора
\utility{gcc}. Этот компилятор имеет огромное количество опций для
составления информации о зависимостях. Наиболее подходящими для нашего
случая выглядят опции, используемые в следующем примере:

{\footnotesize
\begin{verbatim}
ifneq "$(MAKECMDGOALS)" "clean"
  -include $(dependencies)
endif

# $(call make-depend,source-file,object-file,depend-file)
define make-depend
  $(GCC) -MM            \
         -MF $3         \
         -MP            \
         -MT $2         \
         $(CFLAGS)      \
         $(CPPFLAGS)    \
         $(TARGET_ARCH) \
         $1
endef

%.o: %.c
    $(call make-depend,$<,$@,$(subst .o,.d,$@))
    $(COMPILE.c) $(OUTPUT_OPTION) $<
\end{verbatim}
}

Опция \command{-MM} призывает \utility{gcc} убрать все системные
заголовочные файлы из списка реквизитов. Это удобно, так как эти файлы
меняются редко (если вообще меняются), и помогает сократить
беспорядок, возникающий с ростом и усложнением системы сборки.
Изначально эта опция могла быть введена из соображений
производительности. Однако при использовании современных процессоров
разница в производительности едва ли может быть измерена.

Опция \command{-MF} специфицирует имя файла зависимостей. В качестве
имени будет использоваться имя объектного файла, расширение которого
заменяется на \filename{.d}. \utility{gcc} имеет ещё одну опцию,
\command{-MD} или \command{-MMD}, которая автоматически определяет имя
файла зависимостей, используя правило, подобное описанному выше. В
общем случае мы предпочли бы использовать эту опцию, однако встроенное
правило компилятора не сможет добавить соответствующий относительный
путь к каталогу с объектными файлами, вместо этого оно просто поместит
файлы зависимостей в текущий каталог. Поэтому мы вынуждены делать эту
работу самостоятельно и использовать опцию \command{-MF}.

Опция \command{-MP} призывает \utility{gcc} включать для каждого
реквизита абстрактную цель. Это делает ненужным наше неуклюжее
пятизвенное выражение для \utility{sed}, использовавшееся в функции
\function{make-depend}. Похоже, эту опцию добавили в \utility{gcc} по
просьбе разработчиков \utility{automake}, которые изобрели технику
абстрактных целей. 

Наконец, опция \command{-MT} специфицирует строку, которая будет
использоваться для целей в файле зависимостей. Повторим, без этой
опции \utility{gcc} не сможет включить относительный путь к каталогу
объектных файлов.

Используя \utility{gcc}, мы можем заменить четыре команды, требующиеся
для генерации зависимостей, одной. Даже если вы используете
коммерческий компилятор, вы можете использовать \utility{gcc} для
управления зависимостями.
