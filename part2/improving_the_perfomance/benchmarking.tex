%%--------------------------------------------------------------------
%% Benchmarking
%%--------------------------------------------------------------------
\section{Измеряем производительность}

В этом разделе мы измерим производительность базовых операций
\GNUmake{}. Таблица~\ref{tab:cost_of_operations} содержит результаты
этих измерений. Далее будет рассмотрен каждый из тестов, а также
представлены соображения по поводу влияния этих результатов на
написанные вами \Makefile{}'ы.

\begin{table}[!b]
{\footnotesize
\begin{tabular}{llllll}
\hline
\vspace{0.3em}
Операция &
Повторений &
\parbox[b]{2cm}{\flushleft Секунд на \break выполнение (Windows)} &
\parbox[b]{2cm}{\flushleft Число \break выполнений в секунду (Windows)} &
\parbox[b]{2cm}{\flushleft Секунд на \break выполнение (Linux)} &
\parbox[b]{2cm}{\flushleft Число \break выполнений в секунду (Linux)} \\
\hline
\vspace{0.5em}
make (bash) & $\hphantom{0.}1000$ & 0,0436 & $\hphantom{00}22$ & 0,0162 & $\hphantom{000.}61$ \\
\vspace{0.5em}
make (ash) & $\hphantom{0.}1000$ & 0,0413 & $\hphantom{00}24$ & 0,0151 & $\hphantom{000.}66$ \\
\vspace{0.5em}
make (bash) & $\hphantom{0.}1000$ & 0,0452 & $\hphantom{00}22$ & 0,0159 & $\hphantom{000.}62$ \\
\vspace{0.5em}
присваивание & 10.000 & 0,0001 & 8130 & 0,0001 & 10.989 \\
\vspace{0.5em}
subst (short) & 10.000 & 0,0003 & 3891 & 0,0003 & $\hphantom{0.}3846$ \\
\vspace{0.5em}
subst (long) & 10.000 & 0,0018 & $\hphantom{0}547$ & 0,0014 & $\hphantom{00.}704$ \\
\vspace{0.5em}
sed (bash) & $\hphantom{0.}1000$ & 0,0910 & $\hphantom{00}10$ & 0,0342 & $\hphantom{000.}29$ \\
\vspace{0.5em}
sed (ash) & $\hphantom{0.}1000$ & 0,0699 & $\hphantom{00}14$& 0,0069 & $\hphantom{00.}144$ \\
\vspace{0.5em}
sed (sh) & $\hphantom{0.}1000$ & 0,0911 & $\hphantom{00}10$ & 0,0139 & $\hphantom{000.}71$ \\
\vspace{0.5em}
shell (bash) & $\hphantom{0.}1000$ & 0,0398 & $\hphantom{00}25$ & 0,0261 & $\hphantom{000.}38$ \\
\vspace{0.5em}
shell (ash) & $\hphantom{0.}1000$ & 0,0253 & $\hphantom{00}39$ & 0,0018 & $\hphantom{00.}555$ \\
\vspace{0.3em}
shell (sh) & $\hphantom{0.}1000$ & 0,0399 & $\hphantom{00}25$ & 0,0050 & $\hphantom{00.}198$ \\
\hline
\end{tabular}
}
\caption{Стоимость базовых операций} \label{tab:cost_of_operations}
\end{table}

Тесты для Windows запускались на Pentium 4 с тактовой частотой 1,9 ГГц
(приблизительно 3578 BogoMips\footnote{
Объяснение величины BogoMips можно найти на сайте
\url{http://www.clifton.nl/bogomips.html } (прим. автора).})
и оперативной памятью 512 Мб под управлением операционной системы
Windows XP. Использовался Cygwin \GNUmake{} версии 3.80, запускаемый
из окна \utility{rxvt}. Тесты для Linux запускались на Pentium 2 с
тактовой частотой 450 ГГц (891 BogoMips) и оперативной памятью 256 Mб
под управлением операционной системы Linux RedHat 9.

Командный интерпретатор, используемый \GNUmake{}, может существенно
повлиять на производительность выполнения \makefile{а}. Командный
интерпретатор \utility{bash} сложен и обладает обширной
функциональностью, поэтому он достаточно тяжеловесен. Интерпретатор
\utility{ash} гораздо легче, он обладает меньшими возможностями,
впрочем, вполне подходящими для большинства задач. Чтобы усложнить
задачу, добавлю, что при запуске \utility{bash} командой
\filename{/bin/sh} его поведение существенно изменяется с целью
максимального соответствия возможностям стандартного интерпретатора.
На большинстве Linux\hyp{}систем файл \filename{/bin/sh} является
символической ссылкой на \utility{bash}, в то время как в Cygwin эта
ссылка указывает на \utility{ash}. Для учёта этих различий некоторые
тесты запускались трижды, по одному разу для каждого командного
интерпретатора. Командный интерпретатор, использованный в тесте,
указан в скобках. К примеру, <<(sh)>> означает, что использовался
интерпретатор \utility{bash}, запущенный при помощи символической
ссылки \filename{/bin/sh}.

Первые три теста, обозначенные как <<make>>, отображают стоимость
запуска \GNUmake{}, не совершающего полезной работы. \makefile{}
содержит следующие строки:

{\footnotesize
\begin{verbatim}
SHELL := /bin/bash
.PHONY: x
x:
    $(MAKE) --no-print-directory --silent --question make-bash.mk; \
    ...Эта команда повторяется ещё 99 раз...
\end{verbatim}
}

По необходимости слово <<bash>> заменялось соответствующим названием
командного интерпретатора.

Мы использовали опции \command{-{}-no\hyp{}print\hyp{}directory} и
\command{-{}-{}silent} для исключения ненужных вычислений, которые
могли повлиять на время выполнения и затмить измеренные временные
величины грудой бесполезного текста. Опция \command{-{}\hyp{}question}
сообщает \GNUmake{}, что выполнять команды не требуется, нужна только
проверка зависимостей. В этом случае, если файл не требует обновления,
\GNUmake{} завершит работу с нулевым кодом возврата. Это позволяет
\GNUmake{} делать настолько мало работы, насколько это возможно. Этот
\makefile{} не будет выполнять команд, зависимости в нём существуют
только для одной абстрактной цели. Файл \filename{make-bash.mk}
выполняется родительским процессом \GNUmake{} 10 раз. Содержимое этого
файла представлено ниже:

{\footnotesize
\begin{verbatim}
define ten-times
  TESTS += $1
  .PHONY: $1
  $1:
      @echo $(MAKE) --no-print-directory --silent $2; \
      time $(MAKE) --no-print-directory --silent $2; \
      time $(MAKE) --no-print-directory --silent $2; \
      time $(MAKE) --no-print-directory --silent $2; \
      time $(MAKE) --no-print-directory --silent $2; \
      time $(MAKE) --no-print-directory --silent $2; \
      time $(MAKE) --no-print-directory --silent $2; \
      time $(MAKE) --no-print-directory --silent $2; \
      time $(MAKE) --no-print-directory --silent $2; \
      time $(MAKE) --no-print-directory --silent $2; \
      time $(MAKE) --no-print-directory --silent $2
endef

.PHONY: all
all:

$(eval $(call ten-times, make-bash, -f make-bash.mk))

all: $(TESTS)
\end{verbatim}
}

После этого время, требуемое для тысячи запусков, усредняется.

Как вы можете видеть из таблицы, Cygwin \GNUmake{} выполняется
примерно 22 раза в секунду, или 0,044 секунд, в то время как под
управлением операционной системы Linux (не смотря на гораздо более
медленный процессор) выполнение осуществляется примерно 61 раз в
секунду (т.е. одно выполнение занимает 0,016 секунд). Для проверки
этих результатов был протестирован порт \GNUmake{} под Windwos, не
показавший, впрочем, существенного выигрыша в производительности.
Заключение: хоть создание процесса Cygwin \GNUmake{} и
занимает немного больше времени, чем та же операция в Windows
\GNUmake{}, оба этих варианта значительно уступают в
производительности аналогичной операции в Linux. Отсюда следует, что
рекурсивное выполнение \GNUmake{} под Windows может занимать
значительно больше времени, чем рекурсивная сборка, запущенная под
управлением Linux.

Как вы могли ожидать, используемый командный интерпретатор практически
не влияет на скорость выполнения. Поскольку командный сценарий не
содержит специальных символов, командный интерпретатор даже не
вызывался. \GNUmake{} выполнял команды самостоятельно. Это можно
проверить, присвоив переменной \variable{SHELL} произвольное значение
и убедившись в том, что тест выполняется корректно. Разница в
производительности при использовании различных интерпретаторов можно
списать на нормальную вариацию времени выполнения процесса в системе.

Следующий тест измеряет время, требуемое для присваивания переменной
значения~--- наиболее элементарной операции \GNUmake{}. \makefile{},
называющийся \filename{assign.mk}, содержит следующие строки:

{\footnotesize
\begin{verbatim}
# 10000 assignments
z := 10
...предыдущая строка повторяется 10000 раз...
.PHONY: x
x: ;
\end{verbatim}
}

Этот \makefile{} выполняется в родительском \makefile{е} с
использованием нашей функции \function{ten\hyp{}times}.

Очевидно, присваивание выполняется очень быстро. Cygwin \GNUmake{}
выполняет 8130 присваиваний в секунду, в то время как в системе Linux
этот показатель доходит до 10.989. Я уверен, что производительность
выполнения этой операции в системе Windows на самом деле выше, чем
показывают наши измерения, поскольку точное время создания десяти
процессов \GNUmake{} невозможно отделить от времени выполнения
присваивания. Заключение: поскольку вероятность того, что в среднем
\makefile{е} будет осуществляться 10.000 присваиваний, довольно мала,
стоимость выполнения присваиваний в среднем \makefile{е} можно не
учитывать.

Следующие два теста измеряют время выполнения функции \function{subst}.
Первый тест осуществляет подстановку трёх символов в коротких строках,
состоящих из десяти символов:

{\footnotesize
\begin{verbatim}
# 10000 подстановок в строке из 10 символов
dir := ab/cd/ef/g
x := $(subst /, ,$(dir))
...предыдущая строка повторяется 10000 раз...
.PHONY: x
x: ;
\end{verbatim}
}

Операция занимает примерно в два раза больше времени чем простое
присваивание, выполняясь в Windows 3891 раз в секунду. Повторюсь,
показатели производительности в системе Linux значительно превосходят
аналогичные показатели в Windows (как вы помните, производительность
процессора компьютера, на котором установлена система Linux, примерно
в четыре раза меньше производительности процессора компьютера с
системой Windows).

Второй тест осуществляет примерно 100 подстановок в строке длиной в
1000 символов:

{\footnotesize
\begin{verbatim}
# Имя файла из 10 символов
dir := ab/cd/ef/g
# список путей из 1000 символов
p100 := $(dir);$(dir);$(dir);$(dir);$(dir);...
p1000 := $(p100)$(p100)$(p100)$(p100)$(p100)...

# 10000 подстановок в строке длиной в 1000 символов
x := $(subst ;, ,$(p1000))
...предыдущая строка повторяется 10000 раз...
.PHONY: x
x: ;
\end{verbatim}
}

Следующие три теста измеряют скорость той же подстановки при
использовании \utility{sed}. Содержимое тестового файла представлено
ниже:

{\footnotesize
\begin{verbatim}
# 100 sed using bash
SHELL := /bin/bash

.PHONY: sed-bash
sed-bash:
echo '$(p1000)' | sed 's/;/ /g' > /dev/null
...предыдущая строка повторяется 100 раз...
\end{verbatim}
}

Как и раньше, \makefile{} выполняется с помощью функции
\function{ten-times}. В системе Windows \utility{sed} выполняется
примерно в 50 раз медленнее, чем функция \function{subst}. В системе
Linux \utility{sed} работает в 24 раза медленнее.

Если учесть время, затраченное на запуск командного интерпретатора,
становится очевидным, что использование командного интерпретатора
\utility{ash} в Windows даёт небольшую прибавку в скорости. При
использовании \utility{ash} \utility{sed} всего лишь в 39 раз
медленнее \function{subst}! В Linux влияние используемого командного
интерпретатора на скорость выполнения прослеживается более чётко. При
использовании \utility{ash} \utility{sed} всего в пять раз медленнее
\function{subst}. Здесь же можно проследить эффект замены
\utility{bash} на \utility{sh}. В среде Cygwin разница между
\utility{bash}, вызванного через \filename{/bin/bash}, и
\utility{bash}, вызванного через \filename{/bin/sh}, не
прослеживается. В Linux же \utility{/bin/sh} выполняется значительно
быстрее.

Последний тест измеряет затраты на выполнение команды в дочернем
командном интерпретаторе, вызывая команду \command{make shell}.
\makefile{} содержит следующие строки:

{\footnotesize
\begin{verbatim}
# 100 $(shell ) using bash
SHELL := /bin/bash
x := $(shell :)
...предыдущая строка повторяется 100 раз...
.PHONY: x
x: ;
\end{verbatim}
}

Впрочем, результаты были вполне предсказуемы. Система Windows работает
медленнее, чем Linux, командный интерпретатор \utility{ash}
работает быстрее, чем \utility{bash}. Выигрыш от использования
\utility{ash} выражен в этом тесте более ярко и составляет примерно
50\%. В системе Linux наибольшая производительность достигается при
использовании \utility{ash}, наименьшая~--- при использовании
\utility{bash} (вызванного из файла \filename{/bin/bash}).

Тесты производительности являются неиссякаемым источником задач,
тем не менее, сделанные нами измерения могут помочь нам извлечь
некоторую полезную информацию. Создавайте столько переменных, сколько
считаете нужным, если, конечно, они помогают упростить структуру
\makefile{а}, поскольку их использование практически ничего не стоит.
Встроенные функции более предпочтительны, чем запуск внешних программ,
даже если структура вашего кода обязывает вас последовательно
выполнять вызовы функций \GNUmake{}. Избегайте использования
рекурсивного \GNUmake{} или избыточного порождения процессов в
Windows. Если вы работаете в Linux и вам нужно создавать множество
процессов, используйте \utility{ash}.

Наконец, запомните, что для большинства \makefile{ов} справедливо
следующее утверждение: время выполнения \makefile{а} практически
полностью определяется временем выполнения внешних программ, а вовсе
не нагрузкой \GNUmake{} и не структурой \makefile{а}. Как правило,
сокращение числа запусков внешних программ сократит и время выполнения
\makefile{а}.
