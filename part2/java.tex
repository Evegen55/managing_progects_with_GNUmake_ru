%%%-------------------------------------------------------------------
%%% Java
%%%-------------------------------------------------------------------
\chapter{\Java{}}
\label{chap:java}

\index{Интегрированные среды разработки}
Многие Java\hyp{}разработчики предпочитают использовать
интегрированные среды разработки (Integrated Development Environments,
IDE), например, Eclipse. У вас может возникнуть вопрос, зачем вам
нужно использовать \GNUmake{} в \Java{} проектах, если есть такие
известные альтернативы, как Ant и среды разработки \Java{}? Эта глава
содержит исследование значения \GNUmake{} в среде \Java{}, в
частности, в ней приводится универсальный \Makefile{}, который может
быть помещён с минимальными модификациями практически в любой
\Java{}\hyp{}проект для осуществления всех стандартных задач сборки.

Использование \GNUmake{} в совокупности с \Java{} поднимает несколько
проблем и предоставляет некоторые дополнительные возможности. Причиной
этого является сочетание трёх основных факторов: во-первых, компилятор
\Java{} работает очень быстро; во-вторых, стандартный компилятор
\Java{} поддерживает синтаксис \command{@fi\-le\-na\-me} для чтения
параметров командной строки из файла; в третьих, если в коде
\Java{}\hyp{}класса указан пакет, путь к \filename{.class}\hyp{}файлу
определяется однозначно.

Стандартный компилятор \Java{} работает очень быстро. Главной причиной
этого является принцип работы директивы \directive{import}. Подобно
директиве \directive{\#include} препроцессора языка \Clang{}, эта
директива используется для обеспечения доступа к внешним символам.
Однако вместо повторного чтения исходного кода, который затем
потребует повторного разбора и анализа, компилятор \Java{} считывает
файлы классов напрямую. Поскольку символы, определяемые в файле
класса, не могут измениться в процессе компиляции, компилятор
производит кэширование классов. Даже в случае проектов среднего
размера это означает, что компилятор \Java{} избавлен от необходимости
повторно считывать, разбирать и анализировать буквально миллионы строк
кода, с которыми пришлось бы работать компилятору языка \Clang{}.
Менее существенный прирост производительности достигается за счёт
свед\'{е}ния к минимуму оптимизаций, выполняемых большинством
компиляторов \Java{}. Вместо статической оптимизации предпочтение
отдаётся сложным оптимизациям времени выполнения (just-in-time, JIT),
осуществляемым виртуальной машиной \Java{} (\Java{} virtual machine,
JVM).

\index{Java!пакет}
Практически все крупные \Java{}\hyp{}проекты интенсивно используют
\newword{пакеты} (\newword{pack\-ages}). Каждый класс инкапсулируется в
пакет, определяющий область видимости символов, определённых в файле.
Имена пакетов имеют иерархическую структуру и неявно определяют
структуру файловой системы, предназначенную для их хранения. Например,
пакет \command{a.b.c} неявно определяет структуру каталогов
\filename{a/b/c}. Код, объявленный соответствующей директивой как
принадлежащий пакету \command{a.b.c}, будет скомпилирован в файлы
классов и помещён в каталог \filename{a/b/c}. Это означает, что
обычный алгоритм \GNUmake{}, отвечающий за ассоциацию бинарных файлов
с соответствующими исходными файлами, не будет работать правильно.
Однако это также означает, что нам больше не нужно указывать опцию
\command{-o} для спецификации каталога, предназначенного для
размещения объектного файла. Достаточно указать корень дерева
каталогов бинарных файлов, одинаковый для всех исходных файлов. Это, в
свою очередь, означает, что исходный код из различных каталогов может
быть скомпилирован одной и той же командой.

Все стандартные компиляторы \Java{} поддерживают синтаксис
\command{@fi\-le\-na\-me}, позволяющий считывать параметры командной
строки из файла. Это имеет большое значение в сочетании с функционалом
пакетов, поскольку позволяет производить компиляцию всего исходного
кода единственным вызовом компилятора. Такой подход даёт значительный
выигрыш в производительности, так как время, требуемое для загрузки и
работы компилятора, является значительной частью времени выполнения
сборки.

Итак, после составления соответствующей командной строки, компиляция
400\,000 строк \Java{}\hyp{}кода занимает около трёх минут при
использовании процессора Pentium 4 (2,5ГГц). Компиляция эквивалентного
по размеру приложения, написанного на \Cplusplus{}, потребует
нескольких часов.

\input{./part2/java/alternatives_to_make.tex}
\input{./part2/java/generic_java_makefile.tex}
\input{./part2/java/compiling_java.tex}
\input{./part2/java/managing_jars.tex}
\input{./part2/java/reference_trees.tex}
\input{./part2/java/ejb.tex}
