%%--------------------------------------------------------------------
%% Alternatives to make
%%--------------------------------------------------------------------
\section{Альтернативы \GNUmake{}}

Как уже было замечено, сообщество \Java{}\hyp{}разработчиков с
энтузиазмом принимает новые технологии. Рассмотрим две из них, имеющие
отношение к \GNUmake{}~--- \utility{Ant} и интегрированные среды
разработки.

%---------------------------------------------------------------------
% Ant
%---------------------------------------------------------------------
\subsection{Ant}
\index{Ant@\utility{Ant}}
Сообщество \Java{}\hyp{}разработчиков очень активно и производит новые
инструменты с впечатляющей скоростью. Одним из таких инструментов
является \utility{Ant}~--- система сборки, призванная занять место
\GNUmake{} в процессе разработки \Java{}\hyp{}приложений. Как и
\GNUmake{}, \utility{Ant} использует файл спецификации для определения
целей и реквизитов проекта. В отличие от \GNUmake{}, \utility{Ant}
написан на языке \Java{} и принимает файлы спецификации в формате XML.

Чтобы дать вам представление о файле спецификации в формате XML,
приведу небольшую выдержку из файла сборки для \utility{Ant}:

{\footnotesize
\begin{verbatim}
<target name="build"
        depends="prepare, check_for_optional_packages"
        description="--> compiles the source code">
  <mkdir dir="${build.dir}"/>
  <mkdir dir="${build.classes}"/>
  <mkdir dir="${build.lib}"/>

  <javac srcdir="${java.dir}"
         destdir="${build.classes}"
         debug="${debug}"
         deprecation="${deprecation}"
         target="${javac.target}"
         optimize="${optimize}" >
    <classpath refid="classpath"/>
  </javac>
  
  ...

  <copy todir="${build.classes}">
    <fileset dir="${java.dir}">
      <include name="**/*.properties"/>
      <include name="**/*.dtd"/>
    </fileset>
  </copy>
</target>
\end{verbatim}
}

Как вы могли заметить, цель объявляется при помощи XML тега
\command{<target>}. Каждая цель имеет имя и список зависимостей,
указанных в атрибутах \command{name} и \command{depends}
\index{Ant!задачи}
соответственно. Действия, выполняемые \utility{Ant}, называются
\newword{задачами} (\newword{tasks}). Задачи реализованы на языке
\Java{} и привязаны к XML тегу. Например, задача создания каталога
специфицируется при помощи тега \command{<mkdir>} и вызывает
выполнение метода \command{Mkdir.execute}, который в конечном итоге
вызывает метод \command{File.mkdir}. Насколько это возможно, все
задачи реализуются средствами \Java{} API.

Эквивалентный файл сборки \GNUmake{} содержит следующий код:

{\footnotesize
\begin{verbatim}
# производит компиляцию исходного кода
build: $(all_javas) prepare check_for_optional_packages
    $(MKDIR) -p $(build.dir) $(build.classes) $(build.lib)
    $(JAVAC) -sourcepath $(java.dir) \
             -d $(build.classes)     \
             $(debug)                \
             $(deprecation)          \
             -target $(javac.target) \
             $(optimize)             \
             -classpath $(classpath) \
             @$<
    ...
    $(FIND) . \( -name '*.properties' -o -name '*.dtd' \) | \
    $(TAR) -c -f - -T - | $(TAR) -C $(build.classes) -x -f -

\end{verbatim}
}

Отрывок кода, приведённый выше, использует техники, которые мы ещё не
обсуждали. Пока удовлетворимся тем, что реквизит \target{all.javac}
содержит список всех \filename{java} файлов, которые нужно
скомпилировать. Задачи \utility{Ant} \command{<mkdir>},
\command{<javac>} и \command{<copy>} также осуществляют проверку
зависимостей. К примеру, если каталог уже существует, задача
\command{mkdir} не выполнит никаких действий. Более того, если файлы
\Java{}\hyp{}классов имеют более позднюю дату модификации, чем
соответствующие исходные файлы, компиляция не будет осуществляться.
Тем не менее, командный сценарий \GNUmake{} осуществляет по существу
такие же функции. \utility{Ant} включает общую задачу, именуемую
\command{<exec>}, используемую для запуска локальных программ.

\utility{Ant} использует искусный и оригинальный подход, однако, при
его использовании возникает несколько проблем, которые стоит
рассмотреть:

\begin{itemize}
%---------------------------------------------------------------------
\item Несмотря на то, что \utility{Ant} получил широкое
распространение в \Java{}\hyp{}сообществе, вне сообщества
\utility{Ant} практически не распространён. К тому же, сомнительно,
что его популярность когда-нибудь выйдет за пределы
\Java{}\hyp{}проектов (по причинам, перечисленным далее). \GNUmake{},
в свою очередь, успешно применяется во многих областях, включая
разработку программного обеспечения, обработку документов и
типографское дело, поддержку веб\hyp{}сайтов. Понимание \GNUmake{}
очень важно для любого, кому требуется работать в различных
программных системах.
%---------------------------------------------------------------------
\item Выбор XML как языка спецификаций вполне разумен для
\Java{}\hyp{}приложения. Однако читать и писать спецификации на языке
XML большинству людей не очень удобно. Хороший XML\hyp{}редактор может
быть нелегко найти или интегрировать с существующими инструментами
(если моя интегрированная среда разработки не содержит хорошего
XML\hyp{}редактора, мне придётся либо менять среду разработки, либо
искать такой редактор и использовать его отдельно). Как вы могли
видеть из предыдущего примера, \utility{Ant}\hyp{}диалект XML довольно
избыточен по сравнению с синтаксисом \GNUmake{}, и полон специфических
для XML особенностей.
%---------------------------------------------------------------------
\item В процессе работы с файлами \utility{Ant} вам нужно преодолевать
некоторую косвенность ваших спецификаций. Задача \utility{Ant}
\command{<mkdir>} те вызывает соответствующую программу
\utility{mkdir} вашей системы. Вместо этого вызывается метод
\command{mkdir()} класса \command{java.io.File}. Результатом вызова
может быть совсем не то, что вы ожидаете. По существу, любое
предположение программиста о поведении основных инструментов
\utility{Ant} должно быть проверено с привлечением документации по
\utility{Ant} или \Java{}, либо исходного кода \utility{Ant}. В
добавок, для вызова, к примеру, компилятора \Java{}, вам может
понадобиться разобраться в использовании десятка или более незнакомых
XML атрибутов, например, \command{srcdir}, \command{debug} и т.д., не
вошедших в руководство пользователя компилятора. В противоположность
этому \GNUmake{} совершенно прозрачен; как правило, вы можете просто
набирать команды прямо в интерпретаторе и следить за их поведением.
%---------------------------------------------------------------------
\item И всё же, несомненно, \utility{Ant} переносим, как и \GNUmake{}.
Как показано в главе~\ref{chap:portable_makefiles}, написание
переносимых \Makefile{}'ов, как и написание переносимых спецификаций
\utility{Ant}, требуют опыта и особых знаний. Программисты писали
переносимые \Makefile{}'ы два десятилетия. Более того, в документации
\utility{Ant} отмечается, что \utility{Ant} имеет проблемы
переносимости, связанные с символическими ссылками \UNIX{} и длинными
именами файлов в Windows, а MacOS X является единственной операционной
системой Apple, поддерживаемой \utility{Ant}, поддержка же других
платформ не гарантируется. К тому же, базовые операции наподобие
выставления флага исполняемости файлов не могут осуществляться при
помощи \Java{} API, для этого требуется вызов внешней программы.
Переносимость никогда не может быть простой или полной.
%---------------------------------------------------------------------
\item Программа \utility{Ant} не предоставляет подробного отчёта о
своих действиях. Поскольку задачи \utility{Ant} реализованы не в виде
командных сценариев, отображение действий, совершаемых этими задачами,
вызывает определённые трудности. Как правило, вывод состоит из
выражений на естественном языке, выдаваемых выражениями
\command{print}, добавленными автором задачи. Эти выражения не могут
быть выполнены пользователем в командной строке. В противоположность
этому, строки текста, отображаемые \GNUmake{} являются выражениями
интерпретатора и могут быть копированы из вывода и вставлены в
командный интерпретатор для повторного выполнения. Это означает, что
\utility{Ant} менее полезен для разработчиков, пытающихся понять
процесс сборки и способ работы инструментов, используемых в этом
процессе. Кроме того, это не даёт разработчику возможности повторно
использовать элементы этих задач экспромтом, при помощи клавиатуры.
%---------------------------------------------------------------------
\item Последняя и наиболее важная проблема заключается в том, что
\utility{Ant} сдвигает парадигмы осуществления сборок, призывая
использовать компилируемый язык программирования взамен
интерпретируемого. Задачи \utility{Ant} написаны на языке \Java{}.
Если какая-то задача не реализована или делает не то, что вы хотите,
вам нужно либо реализовать собственную задачу на \Java{}, либо
использовать задачу \command{<exec>} (разумеется, если вам приходится
часто использовать задачу \command{<exec>}, то гораздо проще
использовать \GNUmake{} с его макросами, функциями и более компактным
синтаксисом).

С другой стороны, интерпретируемые языки программирования были
изобретены для решения именно таких проблем. \GNUmake{} существует
около тридцати лет и может быть использован в большинстве сложных
ситуаций без расширения своей реализации. Разумеется, за эти тридцать
лет была реализована поддержка множества новых возможностей. Многие из
них задуманы и реализованы в GNU \GNUmake{}.
%---------------------------------------------------------------------
\end{itemize}

\utility{Ant} является замечательной программой, широко
распространённой в \Java{}\hyp{}сообществе. Тем не менее, прежде, чем
приступить к новому проекту, тщательно убедитесь, что \utility{Ant}
является подходящим инструментом для вашей среды разработки. Надеюсь,
эта глава докажет вам, что \GNUmake{} может быть успешно использован
для осуществления сборки вашего \Java{}\hyp{}проекта.

%---------------------------------------------------------------------
% Ant
%---------------------------------------------------------------------
\subsection{Интегрированные среды разработки}

Многие \Java{}\hyp{}разработчики используют интегрированные среды
разработки, совмещающие в единой (как правило, графической) среде
редактор, компилятор, отладчик и инструмент для навигации по исходному
коду. В качестве примеров можно привести такие проекты с открытым
исходным кодом, как Eclipse (\filename{\url{http://www.eclipse.org}})
и Emacs JDEE (\filename{\url{http://jdee.sunsite.dk}}), а также, если
рассматривать коммерческие разработки, Sun Java Studio
(\filename{\url{http://www.sun.com/software/sundev/jde}}) и JBuilder
(\filename{\url{http://www.borland.com/jbuilder}}). Эти среды, как
правило, имеют понятие процесса сборки проекта, заключающегося в
компиляции необходимых файлов и запуска приложения на выполнение.

Если интегрированная среда разработки поддерживает все эти операции,
зачем тогда нам рассматривать использование \GNUmake{}? Наиболее
очевидной причиной является переносимость. Если возникнет
необходимость осуществить сборку проекта на другой платформе, сборка
может закончится неудачей. Несмотря на то, что код \Java{} сам по себе
является переносимым, инструменты для работы с ним, как правило,
таковыми не являются. Например, конфигурационные файлы вашего проекта
могут включать списки путей в стиле \UNIX{} или Windows, это может
стать причиной ошибки при попытке запуска сборки под управлением
другой операционной системы. Второй причиной является тот факт, что
\GNUmake{} поддерживает автоматические сборки. Некоторые
интегрированные среды разработки поддерживают пакетные сборки, а
некоторые нет. Качество этой поддержки также варьируется. Наконец,
встроенная поддержка сборок часто бывает довольно ограниченной. Если
вы хотите реализовать собственную структуру каталогов, соответствующую
структуре релизов вашего проекта, интегрировать файлы помощи внешних
приложений, поддерживать автоматическое тестирование, ветвление и
параллельные треки разработки, скорее всего, вы обнаружите, что
встроенная поддержка сборок не подходит для ваших нужд.

По собственному опыту я могу судить, что интегрированные среды
разработки вполне подходят для небольших немасштабируемых приложений,
однако промышленные системы сборки требуют большей поддержки,
и \GNUmake{} может её обеспечить. Обычно я использую интегрированную
среду разработки для написания и отладки кода и составляю \Makefile{}
для промышленных сборок и релизов. Во время разработки я использую
интегрированную среду для компиляции проекта в состояние, пригодное
для отладки. Однако если я изменяю много файлов или модифицирую файлы,
являющиеся входными файлами для генератора кода, я запускаю
\Makefile{}. Интегрированная среда разработки, которую я использовал,
не имела соответствующей поддержки внешних программ, осуществляющих
генерацию кода. Обычно сборки, полученные с помощью интегрированной
среды, не подходят для поставок внутренним или внешним потребителям.
Для таких задач я использую \GNUmake{}.
