%%--------------------------------------------------------------------
%% Compiling Java
%%--------------------------------------------------------------------
\section{Компиляция \Java{} кода}

Есть два способа компиляции кода \Java{} с помощью \GNUmake{}:
традиционный подход, вызывающий \utility{javac} для компиляции каждого
файла, и более быстрый подход, изложенный ранее и использующий
синтаксис \command{@filename}.

%---------------------------------------------------------------------
% The fast approach: all-in-one compile
%---------------------------------------------------------------------
\subsection*{Быстрый подход: компиляция всех исходных файлов за один
раз} \label{sec:all_in_one_compile}

Давайте более детально рассмотрим быстрый подход. Обратите внимание на
следующий фрагмент универсального \Makefile{}'а:

{\footnotesize
\begin{verbatim}
# all_javas - временный файл для хранения списка исходных файлов
all_javas := $(OUTPUT_DIR)/all.javas

# compile - компилирует исходный код
.PHONY: compile
compile: $(all_javas)
    $(JAVAC) $(JFLAGS) @$<

# all_javas - составляет список исходных файлов
.INTERMEDIATE: $(all_javas)
$(all_javas):
    $(FIND) $(SOURCE_DIR) -name '*.java' > $@
\end{verbatim}
}

Абстрактная цель \target{compile} вызывает \utility{javac} для
компиляции всего исходного кода проекта.

Реквизит \target{\$(all\_java)}~--- это файл, \filename{all.javas},
содержащий список исходных файлов \Java{}, по одному файлу на каждой
строке. Вовсе необязательно размещать каждый файл на отдельной строке,
однако так гораздо легче производить фильтрацию этого списка командой
\command{grep -v}, если в этом возникнет необходимость. Правило создания
файла \filename{all.javas} помечено как \target{.INTERMEDIATE},
поэтому \GNUmake{} будет удалять этот файл после каждого запуска и
создавать его заново перед каждой компиляцией. Командный сценарий для
создания файла очень прост. Для обеспечения максимальной переносимости
мы используем команду \utility{find} для извлечения всех исходных
файлов \Java{} из дерева каталогов с исходными файлами. Эта команда
работает не очень быстро, однако мы можем быть уверены в её корректной
работе. Более того, при изменении структуры дерева каталогов с
исходным кодом нам практически не придётся вносить изменений в этот
командный сценарий.

Если список каталогов, содержащих исходный код, определён и может быть
указан в вашем \Makefile{}'е, вы можете использовать более
производительный способ составления файла \filename{all.javas}.
Если список каталогов с исходным кодом не очень велик и помещается в
командной строке, не нарушая ограничений, накладываемых операционной
системой, можно использовать следующий сценарий:

{\footnotesize
\begin{verbatim}
$(all_javas):
    shopt -s nullglob; \
    printf "%s\n" $(addsuffix /*.java,$(PACKAGE_DIRS)) > $@
\end{verbatim}
}

Этот сценарий использует шаблоны командного интерпретатора для
определения списка \Java{}\hyp{}файлов в каждом каталоге. Однако если
каталог не содержит \Java{}\hyp{}файлов, нам хотелось бы, чтобы
раскрытие шаблон порождало пустую строку, а не текст исходного шаблона
(именно таково поведение по умолчанию многих командных
интерпретаторов). Для достижения этого эффекта используется опция
командного интерпретатора \utility{bash} \command{shopt -s nullglob}.
Большинство других интерпретаторов имеет подобную опцию. Наконец, мы
используем шаблоны и команду \command{printf} вместо \command{ln -l},
поскольку эти инструменты интегрированы в \utility{bash}, поэтому
потребуется выполнение всего одной программы независимо от числа
каталогов.

Мы можем избежать использования шаблонов интерпретатора при помощи
вызова функции \function{wildcard}:

{\footnotesize
\begin{verbatim}
$(all_javas):
    print "%s\n" $(wildcard \
                   $(addsuffix /*.java,$(PACKAGE_DIRS))) > $@
\end{verbatim}
}

Если ваш проект содержит много каталогов с исходным кодом (или пути к
ним имеют очень большую длину), предыдущий сценарий может превысить
предел длины командной строки вашей системы. В этом случае более
предпочтительным является следующий вариант:

{\footnotesize
\begin{verbatim}
.INTERMEDIATE: $(all_javas)
$(all_javas):
    shopt -s nullglob;           \
    for f in $(PACKAGE_DIRS);    \
    do                           \
      printf "%s\n" $$f/*.java;  \
    done > $@

\end{verbatim}
}

Заметим, что цель \target{compile} и вспомогательное правило следуют
подходу, основанному на нерекурсивном вызове \GNUmake{}. Не важно,
сколько подкаталогов в нашем проекте, мы используем единственный
\Makefile{} и производим единственный вызов компилятора. Если вам
нужно произвести компиляцию всего исходного кода, этот подход является
наиболее быстрым.

К тому же, мы совершенно не используем информацию о зависимостях.
Используя эти правила, \GNUmake{} не знает о связях между файлами и не
заботится о датах их модификации. Он просто осуществляет компиляцию
всего исходного кода при каждом вызове. В качестве бонуса мы получаем
возможность вызывать \GNUmake{} из каталога с исходными, а не
бинарными файлами. В контексте возможностей управления зависимостями
\GNUmake{} это может выглядеть как неразумный способ организации
\Makefile{}'а, однако давайте примем во внимание следующие доводы:

\begin{itemize}
%---------------------------------------------------------------------
\item Альтернатива (краткий обзор которой мы произведём позже)
использует стандартный подход, основанный на зависимостях. При этом
для каждого файла создаётся новый процесс \utility{javac}, что
увеличивает накладные расходы. Однако если наш проект не очень велик,
компиляция всех исходных файлов займёт не намного больше времени, чем
компиляция нескольких файлов, поскольку компилятор \utility{javac}
работает очень быстро, а создание новых процессов происходит
относительно медленно. Любая сборка, занимающая менее 15 секунд,
практически эквивалентна другой такой же, независимо от количества
работы, которую необходимо выполнить. Например, компиляция
приблизительно пятисот исходных файлов  (дистрибутива \utility{Ant})
занимает 14 секунд при выполнении на моём Pentium 4 1.8 ГГц, имеющем
512 Мб оперативной памяти. Компиляция одного файла занимает пять
секунд.
%---------------------------------------------------------------------
\item Б\'{о}льшая часть разработчиков будет использовать некий аналог
рабочей среды, предоставляющей быструю компиляцию отдельных файлов.
\Makefile{} же в основном будет использоваться в том случае, если
изменения охватывают большой участок кода, или требуется чистая
сборка, или же сборка осуществляется без вмешательства человека.
%---------------------------------------------------------------------
\item Как мы увидим, усилия, требуемые для реализации и поддержки
подхода, основанного на зависимостях, сравнимы усилиями, необходимыми
для реализации разделения деревьев каталогов исходных и бинарных
файлов для проектов, написанных на \Clang{}/\Cplusplus (эта тема
обсуждается в главе~\ref{chap:c_and_cpp}). Эту задачу не стоит
недооценивать.
%---------------------------------------------------------------------
\end{itemize}

Как мы увидим в следующих примерах, переменная
\variable{PACKAGE\_DIRS} используется не только для составления файла
\filename{all.javas}. Поддержка корректного значения этой переменной
может быть трудоёмким и потенциально сложным шагом. В случае небольших
проектов список каталогов может указываться явно прямо в
\Makefile{}'е, однако при росте числа каталогов до нескольких сотен
ручное редактирование этого списка становится довольно неприятным
занятием может привести к ошибкам. Более благоразумным способом может
быть использование программы \utility{find} для поиска соответствующих
каталогов:

{\footnotesize
\begin{verbatim}
# $(call find-compilation-dirs, root-directory)
  find-compilation-dirs =                       \
    $(patsubst %/,%,                            \
      $(sort                                    \
        $(dir                                   \
          $(shell $(FIND) $1 -name '*.java'))))
  PACKAGE_DIRS := $(call find-compilation-dirs, $(SOURCE_DIR))

\end{verbatim}
}

Команда \command{find} возвращает список файлов, функция
\function{dir} отсекает лишнюю часть имени, оставляя только имя
каталога, функция \function{sort} удаляет из списка дубликаты, а
функция \function{patsubst} удаляет слэш на конце каждого имени.
Обратите внимание на то, что функция \function{find-compilation-dirs}
находит все файлы, подлежащие компиляции, только для того, чтобы
отсечь имена файлов, в то время как правило, ассоциированное с
\filename{all.javas} использует шаблоны для восстановления этих имён.
Это может показаться напрасным расточительством ресурсов, однако я
часто замечаю, что наличие списка пакетов, содержащих исходный код,
чрезвычайно удобно в других аспектах сборки, например, при
сканировании конфигурационных файлов EJB. Если в вашем случае список
пакетов не требуется, просто используйте один из более простых
методов, упомянутых при обсуждении составления файла
\filename{all.javas}.

%---------------------------------------------------------------------
% Compiling with dependencies
%---------------------------------------------------------------------
\subsection*{Компиляция с учётом зависимостей}

Для реализации сборки с полным учётом зависимостей нам потребуется
инструмент для извлечения информации о зависимостях из исходных файлов
\Java{}, подобный команде \command{cc -M}. Программа Jikes
(\filename{\url{http://www.ibm.com/developerworks/opensource/jikes}})~---
это компилятор \Java{} с открытым исходным кодом, поддерживающий
эту возможность при использовании опций \command{-makefile} или
\command{+M}. Jikes~--- не идеальный инструмент для разделения
исходного кода и бинарных файлов, потому что он всегда записывает файл
зависимостей в тот же каталог, в котором находится исходный файл,
однако он бесплатен и эффективен. Есть и положительная сторона: файлы
зависимостей создаются во время компиляции, поэтому дополнительный
вызов компилятора не требуется.

Ниже приведён пример функции для работы с зависимостями и правила,
использующего эту функцию:

{\footnotesize
\begin{verbatim}
%.class: %.java
    $(JAVAC) $(JFLAGS) +M $<
    $(call java-process-depend,$<,$@)

# $(call java-process-depend, source-file, object-file)
define java-process-depend
  $(SED) -e 's/^.*\.class *:/$2 $(subst .class,.d,$2):/' \
         $(subst .java,.u,$1) > $(subst .class,.tmp,$2)
  $(SED) -e 's/#.*//'                                    \
         -e 's/^[^:]*: *//'                              \
         -e 's/ *\\$$$$//'                               \
         -e '/^$$$$/ d'                                  \
         -e 's/$$$$/ :/' $(subst .class,.tmp,$2)         \
         >> $(subst .class,.tmp,$2)
  $(MV) $(subst .class,.tmp,$2).tmp $(subst .class,.d,$2)
endef
\end{verbatim}
}

Этот сценарий требует, чтобы запуск \GNUmake{} осуществлялся из
каталога с бинарными файлами, и чтобы директива \directive{vpath}
указывала расположение исходных файлов. Если вы хотите использовать
компилятор Jikes только для генерации зависимостей, обращаясь к
другому компилятору для непосредственной генерации кода, вы можете
использовать опцию \command{+B}, в этом случае Jikes не будет
генерировать байт\-код.

В небольшом тесте производительности, в рамках которого происходила
компиляция 223 \Java{}\hyp{}файлов, однострочная команда компиляции,
описанная ранее, выполнялась на моей машине 9.9 секунд. Компиляция тех
же 223 файлов с индивидуальным вызовом компилятора для каждого файла
потребовала 411.6 секунд, т.е. в 41.5 раз больше времени. Более того,
при использовании раздельной компиляции любая сборка, требующая
компиляции более четырёх исходных файлов, будет занимать больше
времени, чем компиляция всего проекта одной командой. Если генерация
зависимостей и компиляция будут осуществляться разными программами,
разница только увеличится.

Разумеется, среды разработки варьируются, однако всегда важно
внимательно обдумать ваши цели. Минимизация числа файлов, подлежащих
компиляции, не всегда будет означать минимизацию времени, требующегося
для сборки системы. В случае языка \Java{} полная проверка
зависимостей и минимизация числа компилируемых файлов не являются
необходимыми атрибутами хорошей среды программирования.

%---------------------------------------------------------------------
% Setting CLASSPATH
%---------------------------------------------------------------------
\subsection*{Определение переменной CLASSPATH}

Одной из самых важных проблем при разработке программного обеспечения
на языке \Java{} является корректное определение переменной
\variable{CLASSPATH}. Эта переменная определяет, откуда будет
загружаться код при разрешении ссылки на класс. Для корректной
компиляции \Java{}\hyp{}приложения \Makefile{} должен включать
правильное определение переменной \variable{CLASSPATH}. Эта задача
быстро становится сложной при добавлении \Java{}\hyp{}пакетов,
программных интерфейсов приложений (API) и вспомогательных
инструментов. Если правильное определение \variable{CLASSPATH} может
быть сложной задачей, имеет смысл делать эту задачу в каком-то одном
месте.

Техника, которую я нашёл полезной, заключается в определении
переменной \variable{CLASSPATH} \Makefile{}'е для нужд не только
\GNUmake{}, но и других программ. Например, цель \target{classpath}
может возвращать команду экспорта переменной \variable{CLASSPATH} в
среду командного интерпретатора, вызвавшего \GNUmake{}:

{\footnotesize
\begin{verbatim}
.PHONY: classpath
classpath:
    @echo "export CLASSPATH='$(CLASSPATH)'"
\end{verbatim}
}

Разработчики могут определять \variable{CLASSPATH} следующим образом
(если они используют \utility{bash}):

{\footnotesize
\begin{alltt}
\$ \textbf{eval \$(make classpath)}
\end{alltt}
}

Определить переменную \variable{CLASSPATH} в среде Windows можно
следующим образом:

{\footnotesize
\begin{verbatim}
.PHONY: windows_classpath
windows_classpath:
    regtool set /user/Environment/CLASSPATH \
	        "$(subst /,\\,$(CLASSPATH))"
    control sysdm.cpl,@1,3 &
    @echo "Теперь нажмите кнопку <<Переменные окружения>>, " \
	      "затем OK, затем снова OK."
\end{verbatim}
}

Программа \utility{regtool} является частью среды разработки Cygwin и
предназначена для работы с реестром Windows. Однако простое обновление
реестра не вызовет считывания нового значения. Одним из способов
осуществления этой задачи является посещение диалогового окна
<<Переменные окружения>> (Environment Variables) и закрытие этого
окна при помощи кнопки OK.

Вторая строка сценария сообщает Windows, что нужно отобразить
диалоговое окно <<Свойства системы>> (System Properties) и сделать
активной вкладку <<Дополнительно>> (Advanced). К сожалению, командный
сценарий не может отобразить диалоговое окно <<Переменные окружения>>
или активировать кнопку OK, поэтому последняя строка сценария
предлагает пользователю завершить работу самостоятельно.

Экспорт переменной \variable{CLASSPATH} в другие программы, такие как
проектные файлы Emacs JDEE или JBuilder, осуществляется очень просто.

Непосредственное определение переменной \variable{CLASSPATH} может
также управляться при помощи \GNUmake{}. Определение этой переменной
очевидным способом определённо является разумной идеей:

{\footnotesize
\begin{verbatim}
CLASSPATH = /third_party/toplink-2.5/TopLink.jar:/third_party/...
\end{verbatim}
}

Из соображений переносимости более предпочтительным способом является
использование переменных:

{\footnotesize
\begin{verbatim}
# Определение Java classpath
class_path := OUTPUT_DIR          \
              XERCES_JAR          \
              COMMONS_LOGGING_JAR \
              LOG4J_JAR           \
              JUNIT_JAR
...
# Определение CLASSPATH
export CLASSPATH := $(call build-classpath, $(class_path))
\end{verbatim}
}
(Определение \variable{CLASSPATH}, приведённое в коде универсального
\Makefile{}'а, более показательно и полезно). Должным образом
реализованная функция \function{build\hyp{}classpath} решает несколько
раздражающих проблем:

\begin{itemize}
%---------------------------------------------------------------------
\item Очень просто собрать значение \variable{CLASSPATH} из частей.
Например, если используется несколько серверов приложений, может
потребоваться изменение \variable{CLASSPATH}. Различные версии
\variable{CLASSPATH} могут заключаться в секции \directive{ifdef} и
выбираться на основании значения какой-либо переменной \GNUmake{}.
%---------------------------------------------------------------------
\item Люди, занимающиеся поддержкой \Makefile{}'а, не должны
волноваться о внутренних пробелах, символах новой строки или переносах
строк, функция \function{build\hyp{}classpath} осуществляет
необходимые операции самостоятельно.
%---------------------------------------------------------------------
\item Функция \function{build\hyp{}classpath} может выбирать
разделитель путей автоматически, делая тем самым значение переменной
корректным для Windows и \UNIX{}.
%---------------------------------------------------------------------
\item Функция \function{build\hyp{}classpath} может осуществлять
проверку правильности элементов списка путей. В частности, одной из
раздражающих проблем \GNUmake{} является то, что вычисление
переменных, значение которых не определено, просто возвращает пустую
строку.  В большинстве случаев такое поведение полезно, однако иногда
оно может встать на вашем пути. В этом случае значение переменной
\variable{CLASSPATH} будет иметь фиктивное значение%
\footnote{
Для обнаружения этой ситуации можно попробовать использовать опцию
\command{-{}-warn\hyp{}undefined\hyp{}variables}, однако это приведёт
к предупреждениям, относящимся к тем переменным, неопределённое
значение которых нас устраивает.}.
Мы можем решить эту проблему, добавив проверку определённости
переменных, входящих в список путей, в функцию
\function{build\hyp{}classpath}. Функция также может проверять
существование каждого файла или каталога, входящего в список, и, в
случае невыполнения ограничений, выводить соответствующее
предупреждение.
%---------------------------------------------------------------------
\item Наконец, для реализации наиболее изощрённого функционала
(например, обработки пробелов в именах файлов или путях поиска) может
быть удобно использовать триггер для обработки переменной
\variable{CLASSPATH}.
%---------------------------------------------------------------------
\end{itemize}

Ниже приведена реализация функции \function{build\hyp{}classpath},
учитывающая первые три пункта нашего списка:

{\footnotesize
\begin{verbatim}
# $(call build-classpath, variable-list)
define build-classpath
  $(strip                                         \
    $(patsubst %:,%,                              \
      $(subst : ,:,                               \
        $(strip                                   \
          $(foreach c,$1,$(call get-file,$c):)))))
endef

# $(call get-file, variable-name)
define get-file
  $(strip                                        \
    $($1)                                        \
    $(if $(call file-exists-eval,$1),,           \
      $(warning Файл, указанный в переменной     \
                '$1' ($($1)), не найден)))
endef

# $(call file-exists-eval, variable-name)
define file-exists-eval
  $(strip                                                \
    $(if $($1),,$(warning Переменная'$1' не определена)) \
    $(wildcard $($1)))
endef
\end{verbatim}
}

Функция \function{build\hyp{}classpath} проходит по всем словам своего
аргумента, производя проверку каждого элемента и соединяя эти
элементы, используя разделитель путей (в нашем случае это
\command{:}).  Реализовать автоматический выбор разделителя путей
теперь очень просто. Затем функция удаляет пробелы, добавленные
функцией \function{get\hyp{}file} и циклом \function{for\-each}. Затем
функция удаляет последний разделитель, добавленный циклом
\function{for\-each}. Наконец, весь список подаётся на вход функции
\function{strip}, благодаря чему удаляются лишние пробелы, добавленные
продолжением строк.

Функция \function{get\hyp{}file} принимает на вход имя переменной и
осуществляет проверку существования файла, имя которого является
значением переменной. Если файл не существует, генерируется
предупреждение. Функция возвращает значение переменной независимо от
того, существует ли соответствующий файл, так как это значение может
быть полезным для пользователя. В некоторых случаях функция
\function{get\hyp{}file} может быть применена к файлу, который будет
сгенерирован позже и пока не существует.

Последняя функция, \function{file\hyp{}exists\hyp{}eval}, принимает
в качестве аргумента имя переменной, содержащей имя файла. Если
переменная содержит пустую строку, генерируется предупреждение, в
противном случае для проверки существования файла (или списка файлов)
используется вызов функции \function{wild\-card}

Если функция \function{build\hyp{}classpath} применяется к фиктивным
значениям, при запуске мы увидим следующие ошибки:

{\footnotesize
\begin{verbatim}
Makefile:37: Файл, указанный в переменной 'TOPLINKX_25_JAR'
             (/usr/java/toplink-2.5/TopLinkX.jar), не найден
...
Makefile:37: Переменная 'XERCES_142_JAR' не определена
Makefile:37: Файл, указанный в переменной 'XERCES_142_JAR'
             ( ), не найден
\end{verbatim}
}

Этот пример демонстрирует существенный прогресс по сравнению с
молчанием, которое мы получаем при использовании простого подхода.

Существование функции \function{get\hyp{}file} подразумевает, что мы
можем обобщить задачу поиска входных файлов.

{\footnotesize
\begin{verbatim}
# $(call get-jar, variable-name)
define get-jar
  $(strip                                                     \
    $(if $($1),,$(warning Переменная '$1' пуста))             \
    $(if $(JAR_PATH),,$(warning Переменная JAR_PATH пуста))   \
    $(foreach d, $(dir $($1)) $(JAR_PATH),                    \
      $(if $(wildcard $d/$(notdir $($1))),                    \
        $(if $(get-jar-return),,                              \
          $(eval get-jar-return := $d/$(notdir $($1))))))     \
    $(if $(get-jar-return),                                   \
      $(get-jar-return)                                       \
      $(eval get-jar-return :=),                              \
      $($1)                                                   \
      $(warning get-jar: Файл '$1' не найден в $(JAR_PATH))))
endef
\end{verbatim}
}

Здесь мы определяем переменную \variable{JAR\_PATH}, содержащую пути
для поиска файлов. Возвращается первый найденный файл. Параметром
функции является имя переменной, содержащей путь к архиву jar. Мы
производим поиск jar\hyp{}файла, используя сначала путь, содержащийся
в переданной переменной, затем набор путей, содержащихся в переменной
\variable{JAR\_PATH}. Чтобы реализовать такое поведение, список
каталогов в цикле \function{for\-each} составляется из значения
переменной, за которым сделует значение переменной
\variable{JAR\_PATH}. Два других обращения к параметру обрамляются
вызовом функции \function{notdir}, благодаря чему имя архива можно
соединить с соответствующим элементом списка. Обратите внимание на то,
что мы не можем выйти из цикла \function{for\-each}. Вместо этого,
однако, мы используем функцию \function{eval} для определения
переменной \variable{get\hyp{}jar\hyp{}return}, используемую для
хранения первого найденного файла. После выхода из цикла мы возвращаем
значение временной переменной или генерируем предупреждение, если файл
не был найден. Важно не забыть сбросить значение временной переменной
перед завершением работы макроса.

Эта функция по существу является реализацией директивы
\directive{vpath} в контексте определения переменной
\variable{CLASSPATH}. Чтобы понять это, вспомним, что директива
\directive{vpath} используется \GNUmake{} для нахождения реквизитов,
которые не были найдены по их относительному пути. В такой
ситуации \GNUmake{} производит поиск реквизитов в каталогах, указанных
директивой \directive{vpath}, и подставляет дополненный путь в
автоматические переменные \variable{\$\^}, \variable{\$?} и
\variable{\$+}. Мы хотим, чтобы для определения переменной
\variable{CLASSPATH} \GNUmake{} производил поиск пути к каждому
jar\hyp{}файлу и производил конкатенацию переменной
\variable{CLASSPATH} с этим дополненным путём. Поскольку \GNUmake{} не
имеет встроенной поддержки этого функционала, мы добавляем его
самостоятельно.  Разумеется, вы можете просто всегда прописывать
полные пути к jar\hyp{}файлам, предоставив задачу поиска виртуальной
машине \Java{}, однако переменная \variable{CLASSPATH} и без того
быстро становится длинной. На некоторых операционных системах длина
переменных окружения ограничена и существует опасность усечения
длинных значений \variable{CLASSPATH}.  Например, на операционной
системе Windows XP длина значения переменной окружения ограничена 1023
символами. В добавок, даже если переменая \variable{CLASSPATH} не
будет усечена, виртуальная машина \Java{} должна производить поиск в
\variable{CLASSPATH} при загрузке классов, что замедляет работу
приложения.
