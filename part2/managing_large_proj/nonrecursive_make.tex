%%-------------------------------------------------------------------
%% Nonrecursive make
%%-------------------------------------------------------------------
\section{Нерекурсивный \GNUmake{}}

Проекты, содержащие множество каталогов, могут управляться и без
рекурсивного \GNUmake{}. Разница заключается в том, что исходные
файлы, которыми манипулирует \Makefile{}, находятся более чем в одном
каталоге.  Чтобы отразить этот факт, все ссылки на файлы
должны использовать абсолютные или относительные пути к файлам.

Часто \Makefile{} большого проекта содержит множество целей, по одной
для каждого модуля системы. Например, в нашем проекте mp3 плеера нам
понадобились цели для каждой библиотеки и каждого приложения. Также
полезным может быть включение абстрактных целей для групп компонентов,
таких, например, как группа всех библиотек. Цель по умолчанию, как
правило, производит сборку всех этих целей. Часто цель по умолчанию
также производит составление документации и запуск процедур
автоматического тестирования.

Наиболее простой способ использования нерекурсивного \GNUmake{}~---
включение всех целей, ссылок на объектные файлы и зависимостей в один
\Makefile{}. Это часто не устраивает разработчиков, знакомых с
рекурсивным \GNUmake{}, поскольку в этом случае вся информация о
файлах и каталогах сосредоточена в одном файле, в то время как сами
файлы рассредоточены по файловой системе. Для решения этой проблемы
Миллер в своей статье о нерекурсивном \GNUmake{} предлагает добавлять
в каждый каталог включаемый файл, содержащий список файлов модуля и
правила, специфичные для него. Головной \Makefile{} включает все
дочерние \Makefile{}'ы.

Следующий пример демонстрирует \Makefile{} нашего проекта mp3 плеера,
включающий \Makefile{}'ы модулей из соответствующих каталогов.
{\footnotesize
\begin{verbatim}
# Информация о каждом модуле хранится в следующих четырёх
# переменных. Инициализируем их как простые переменные.
programs    :=
sources     :=
libraries   :=
extra_clean :=

objects      = $(subst .c,.o,$(sources))
dependencies = $(subst .c,.d,$(sources))

include_dirs := lib include
CPPFLAGS     += $(addprefix -I ,$(include_dirs))
vpath %.h $(include_dirs)

MV  := mv -f
RM  := rm -f
SED := sed

all:

include lib/codec/module.mk
include lib/db/module.mk
include lib/ui/module.mk
include app/player/module.mk

.PHONY: all
all: $(programs)

.PHONY: libraries
libraries: $(libraries)

.PHONY: clean
clean:
    $(RM) $(objects) $(programs) $(libraries) \
          $(dependencies) $(extra_clean)

  ifneq "$(MAKECMDGOALS)" "clean"
    include $(dependencies)
  endif

%.c %.h: %.y
    $(YACC.y) --defines $<
    $(MV) y.tab.c $*.c
    $(MV) y.tab.h $*.h

%.d: %.c
    $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $< | \
    $(SED) 's,\($(notdir $*)\.o\) *:,$(dir $@)\1 $@: ,' > $@.tmp
    $(MV) $@.tmp $@
\end{verbatim}
}

Далее приведён пример \Makefile{}'а модуля \filename{/lib/codec}
(\filename{module.mk}):
{\footnotesize
\begin{verbatim}
local_dir  := lib/codec
local_lib  := $(local_dir)/libcodec.a
local_src  := $(addprefix $(local_dir)/,codec.c) 
local_objs := $(subst .c,.o,$(local_src))

libraries += $(local_lib)
sources   += $(local_src)

$(local_lib): $(local_objs)
    $(AR) $(ARFLAGS) $@ $^
\end{verbatim}
}

Таким образом, информация, специфичная для модуля, хранится во
включаемом файле в каталоге соответствующего модуля. Головной
\Makefile{} содержит только список модулей и директивы
\directive{include}. Давайте рассмотрим файл \filename{module.mk}
более детально.

Каждый файл \filename{module.mk} добавляет к переменной
\variable{libraries} имя текущей библиотеки, а к переменной
\variable{sources}~--- пути к исходным файлам. Переменные с префиксом
\variable{local\_} используются для хранения констант или для
предотвращения повторного вычисления значений. Обратите внимание на
то, что каждый модуль использует одинаковые имена \variable{local\_}
переменных. Именно поэтому вместо рекурсивных переменных используются
простые (объявляемые при помощи оператора \texttt{:=}): так сборки,
затрагивающие несколько \Makefile{}'ов, не подвержены риску
повреждения значений переменных в отдельных \Makefile{}'ах. Как уже
упоминалось, имена библиотек и списки исходных файлов используют
относительные пути. Наконец, включаемый файл содержит правила для
сборки текущей библиотеки. Использование \variable{local\_} переменных
в правилах вполне допустимо, так как цели и реквизиты правил
вычисляются при чтении файла.

Первые четыре строки головного \Makefile{}'а определяют переменные,
дополняемые информацией о каждом отдельном модуле. Эти переменные
должны быть простыми, поскольку каждый модуль будет добавлять к ним
данные из локальных переменных:
 
{\footnotesize
\begin{verbatim}
local_src := $(addprefix $(local_dir)/,codec.c)
...
sources   += $(local_src)
\end{verbatim}
}

Если бы переменная \variable{sources} была рекурсивной, финальное её
значение содержало бы просто последнее значение \variable{local\_src},
повторяющееся снова и снова. Поскольку по умолчанию переменные
являются рекурсивными, применяется явная инициализация пустым
значением.

Следующий раздел содержит вычисление списка объектных файлов,
\variable{objects}, и списка файлов зависимостей при помощи значения
переменной \variable{sources}. Эти переменные являются рекурсивными,
поскольку на данном этапе обработки \Makefile{}'а переменная
\variable{sources} содержит пустое значение. Это значение не будет
использоваться до тех пор, пока не будут прочитаны включаемые
\Makefile{}'ы. В нашем случае наиболее разумно было бы поместить
определение этих переменных после директив включения и объявить эти
переменные как простые, однако расположение переменных,
хранящих списки файлов (\variable{sources}, \variable{libraries},
\variable{objects}), рядом друг с другом упрощает понимание
\Makefile{}'а в целом и является хорошей практикой. К тому же, в
более сложных ситуациях перекрёстные ссылки между переменными
потребовали бы использования рекурсивных переменных.

Далее мы специфицируем обработку заголовочных файлов \Clang{}, указывая
значение переменной \variable{CPPFLAGS}. Это позволяет компилятору
находить заголовочные файлы. Для этой цели используется дополнение
значения (оператор \texttt{+=}), поскольку заранее нельзя сказать, что
значение переменной не определено: опции командной строки, переменные
окружения или конструкции \GNUmake{} могли уже придать ей какое-то
значение. Директива \directive{vpath} позволяет \GNUmake{} находить
заголовочные файлы, располагающиеся в других каталогах. Переменная
\variable{include\_dirs} используется для того, чтобы избежать
повторного вычисления списка включаемых каталогов.

Переменные \variable{MV}, \variable{RM} и \variable{SED} используются
для того, чтобы избежать жёсткой привязки к конкретным программам.
Обратите внимание на регистр имён переменных. Здесь мы следовали
соглашениям, принятым в руководству по \GNUmake{}. Имена переменных,
используемых только внутри \Makefile{}'а, состоят из прописных букв,
имена переменных, значение которых можно задать из командной
строки~--- из заглавных.

В следующей секции \Makefile{}'а всё ещё интереснее. Мы начинаем
раздел явных правил с указания цели по умолчанию, \target{all}. К
сожалению, реквизитом цели \target{all} является переменная
\variable{programs}.  Эта переменная будет вычислена незамедлительно,
однако её значение будет известно только после чтения включаемых
файлов. Таким образом, нам требуется прочитать включаемые файлы перед
тем, как определить цель \target{all}. Однако включаемые файлы
содержат цели, первая из которых станет целью по умолчанию. Чтобы
разрешить эту дилему, мы можем указать цель \target{all} без
реквизитов, прочитать включаемые файлы и добавить реквизиты к цели
\target{all} позднее.

Оставшаяся часть \Makefile{}'а уже знакома вам по предыдущим примерам,
однако всё же стоит обратить внимание на то, как \GNUmake{} применяет
неявные правила. Исходные файлы располагаются в подкаталогах. Когда
\GNUmake{} пытается применить стандартное правило \texttt{\%.o: \%.c},
реквизитом будет файл с относительным путём, например,
\filename{lib/ui/ui.c}. \GNUmake{} автоматически распространит
относительный путь на файл цели и попробует собрать
\filename{lib/ui/ui.o}. Таким образом, \GNUmake{} автомагически
(automagically) делает именно то, что нужно.

Есть один неприятный сбой. Несмотря на то, что \GNUmake{} обрабатывает
пути должным образом, не все инструменты, используемые им, делают тоже
самое. В частности, при использовании \utility{gcc} для генерации
зависимостей, результирующий файл не будет содержать относительного
пути к целевому объектному файлу. Вывод команды \texttt{gcc -M} будет
следующим:

{\footnotesize
\begin{verbatim}
ui.o: lib/ui/ui.c include/ui/ui.h lib/db/playlist.h
\end{verbatim}
}

в то время как мы ожидаем увидеть другое:


{\footnotesize
\begin{verbatim}
lib/ui/ui.o: lib/ui/ui.c include/ui/ui.h lib/db/playlist.h
\end{verbatim}
}

Это нарушает обработку файлов реквизитов. Для решения этой проблемы мы
можем настроить команду \utility{sed} так, чтобы она добавляла
информацию об относительных путях:

{\footnotesize
\begin{verbatim}
$(SED) 's,\($(notdir $*)\.o\) *:,$(dir $@)\1 $@: ,'
\end{verbatim}
}

Тонкая настройка \Makefile{}'а для обхода причуд различных
инструментов является естественной частью работы с \GNUmake{}.
Код переносимых \Makefile{}'ов часто бывают очень сложным из-за
капризов различных наборов инструментов, на которые приходится
полагаться.

Теперь у нас есть добротный нерекурсивный \Makefile{}, однако при
поддержке могут возникнуть проблемы. Дело в том, что включаемые файлы
\filename{module.mk} во многом схожи. Изменения в одном из них скорее
всего приведут к необходимости менять другие файлы. Для небольшого
проекта наподобие нашего mp3 плеера это неприятно. Для большого
проекта, содержащего несколько сотен включаемых файлов, это может быть
фатально. При разумном выборе имён переменных и регуляризации
содержимого включаемых файлов эта болезнь поддаётся лечению. Ниже
приводится включаемый файл \filename{lib/codec} после рефакторинга:

{\footnotesize
\begin{verbatim}
local_src := $(wildcard $(subdirectory)/*.c)
$(eval $(call make-library,
         $(subdirectory)/libcodec.a,
		 $(local_src)))
\end{verbatim}
}

Вместо того, чтобы перечислять исходные файлы явно, мы используем
предположение, согласно которому в сборке нуждаются все исходные файлы
в каталоге. Функция \function{make-library} осуществляет набор
операций, общих для всех включаемых файлов. Эта функция определяется в
начале головного \Makefile{}'а нашего проекта:

{\footnotesize
\begin{verbatim}
# $(call make-library, library-name, source-file-list)
define make-library
  libraries += $1
  sources   += $2

  $1: $(call source-to-object,$2)
    $(AR) $(ARFLAGS) $$@ $$^
endef
\end{verbatim}
}

Функция добавляет исходные файлы и имя библиотеки к соответствующим
переменным, затем определяет явные правила для сборки
библиотеки. Обратите внимание на то, что автоматические переменные
используются с двумя знаками доллара, чтобы отложить их вычисление до
выполнения правила. Функция \function{source-to-object} трансформирует
список исходных файлов в список соответствующих объектных файлов:

{\footnotesize
\begin{verbatim}
source-to-object = $(subst .c,.o,$(filter %.c,$1)) \
                   $(subst .y,.o,$(filter %.y,$1)) \
                   $(subst .l,.o,$(filter %.l,$1))
\end{verbatim}
}

В предыдущей версии \Makefile{}'а мы затушевали тот факт, что
настоящими исходными файлами являются \filename{playlist.y} и
\filename{scanner.l}. Вместо этого в списке файлов мы указывали
сгенерированные \filename{.c} файлы. Из-за этого нам приходилось
указывать их явно и включать дополнительную переменную,
\variable{extra\_clean}. Мы решили эту проблему, позволив переменной
\variable{sources} содержать файлы \filename{.y} и \filename{.l} и
возложив на функцию \function{source-to-object} работу по переводу
имён этих файлов в имена соответствующих объектных файлов.

В дополнение к модификации функции \function{source-to-object} нам
нужно добавить ещё одну функцию, вычисляющую имена выходных файлов
\utility{yacc} и \utility{lex}, чтобы позволить цели \target{clean}
должным образом выполнять свою работу. Функция
\function{generated-source} принимает на вход список файлов и
возвращает список промежуточных файлов:

{\footnotesize
\begin{verbatim}
# $(call generated-source, source-file-list)
generated-source = $(subst .y,.c,$(filter %.y,$1)) \
                   $(subst .y,.h,$(filter %.y,$1)) \
                   $(subst .l,.c,$(filter %.l,$1))
\end{verbatim}
}

Другая полезная функция, \function{subdirectory}, помогает избавиться
от локальной переменной \variable{local\_dir}.

{\footnotesize
\begin{verbatim}
subdirectory = $(patsubst %/makefile,%, \
                 $(word                 \
                   $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST)))
\end{verbatim}
}

Как уже было замечено в разделе <<\nameref{sec:str_func}>>
главы~\ref{chap:functions}, мы можем получить имя текущего
\Makefile{}'а из переменной \variable{MAKEFILE\_LIST}. Использовав
функцию \function{patsubst}, мы можем извлечь относительный путь из
имени последнего прочитанного \Makefile{}'а. Это помогает устранить
одну переменную и уменьшить разницу между включаемыми файлами.

Нашей последней оптимизацией (по крайней мере, в этом примере)
является использование функции \function{wildcard} для получения
списка исходных файлов. Это прекрасно работает в большинстве сред,
поддерживающих чистоту в каталогах с исходными файлами. Однако мне
приходилось работать в проекте, в котором это было не принято. Старый
код хранился в каталогах с исходными файлами <<на всякий случай>>.
Это влекло реальные затраты, выраженные во времени и нервах
программистов, поскольку средства поиска и замены находили символы в
старом коде, и новые программисты (или старые, не знакомые с модулем)
пытались откомпилировать и отладить код, который никогда не
использовался. Если вы используете современную систему контроля версий
(например, CVS), хранение старого кода в каталогах с исходным кодом
совершенно бессмысленно (поскольку весь код уже хранится в
репозитории), и использование \function{wildcard} становится
оправданным.

Директивы \directive{include} также могут быть оптимизированы:

{\footnotesize
\begin{verbatim}
modules := lib/codec lib/db lib/ui app/player
...
include $(addsuffix /module.mk,$(modules))
\end{verbatim}
}

Для больших проектов даже этот код может стать проблемой при
поддержке, поскольку список модулей может вырасти до сотен или даже
тысяч. При некоторых обстоятельствах более предпочтительным является
автоматическое определение модулей при помощи команды \utility{find}:

{\footnotesize
\begin{verbatim}
modules := $(subst /module.mk,,
             $(shell find . -name module.mk))
...
include $(addsuffix /module.mk,$(modules))
\end{verbatim}
}

Мы обрезаем имена файлов, обнаруженных командой \utility{find}, делая
переменную \variable{modules} более полезной как список модулей. Если
вам этого не требуется, тогда, конечно, можно опустить вызовы
\function{subst} и \function{addsuffix} и просто сохранить вывод
команды \utility{find} в переменной \variable{modules}.  Следующий
пример демонстрирует результирующий \Makefile{}.

{\footnotesize
\begin{verbatim}
# $(call source-to-object, source-file-list)
source-to-object = $(subst .c,.o,$(filter %.c,$1)) \
                   $(subst .y,.o,$(filter %.y,$1)) \
                   $(subst .l,.o,$(filter %.l,$1))

# $(subdirectory)
subdirectory = $(patsubst %/module.mk,%, \
                 $(word                  \
                   $(words $(MAKEFILE_LIST)),
				           $(MAKEFILE_LIST)))

# $(call make-library, library-name, source-file-list)
define make-library
  libraries += $1
  sources   += $2
  $1: $(call source-to-object,$2)
      $(AR) $(ARFLAGS) $$@ $$^
endef

# $(call generated-source, source-file-list)
generated-source = $(subst .y,.c,$(filter %.y,$1)) \
                   $(subst .y,.h,$(filter %.y,$1)) \
                   $(subst .l,.c,$(filter %.l,$1)) 

# Информация о каждом модуле хранится в следующих четырёх
# переменных. Инициализируем их как простые переменные.
modules      := lib/codec lib/db lib/ui app/player
programs     :=
libraries    :=
sources      :=
objects      = $(call source-to-object,$(sources))
dependencies = $(subst .o,.d,$(objects))

include_dirs := lib include
CPPFLAGS     += $(addprefix -I ,$(include_dirs))
vpath %.h $(include_dirs)

MV  := mv -f
RM  := rm -f
SED := sed

all:

include $(addsuffix /module.mk,$(modules))

.PHONY: all
all: $(programs)

.PHONY: libraries
libraries: $(libraries)

.PHONY: clean
clean:
    $(RM) $(objects) $(programs) $(libraries) $(dependencies) \
          $(call generated-source, $(sources))

  ifneq "$(MAKECMDGOALS)" "clean"
    include $(dependencies)
  endif

%.c %.h: %.y
    $(YACC.y) --defines $<
    $(MV) y.tab.c $*.c
    $(MV) y.tab.h $*.h

%.d: %.c
    $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $< | \
    $(SED) 's,\($(notdir $*)\.o\) *:,$(dir $@)\1 $@: ,' > $@.tmp
    $(MV) $@.tmp $@
\end{verbatim}
}

Использование одного включаемого файла для каждого модуля является
весьма работоспособным подходом и имеет свои преимущества, однако я не
могу с уверенностью сказать, что он является наилучшим. Мой
собственный опыт работы с проектом на \Java{} показывает, что
использование головного \Makefile{}'а, эффективно включающего файлы
модулей, является разумным решением. Этот проект включал 997 отдельных
модулей, около двух десятков библиотек и полдюжины приложений.
Для обработки несвязанных подмножеств кода использовались различные
\Makefile{}'ы. Эти файлы в совокупности содержали примерно 2500 строк.
Общий включаемый файл, содержащий глобальные переменные, функции,
определяемые пользователем, и шаблонные правила, содержал ещё примерно
2500 строк.

Выберите ли вы один единственный \Makefile{}, или же поместите информацию
о модулях в отдельные включаемые файлы, нерекурсивный \GNUmake{}
является хорошим подходом к сборке крупных проектов. Он также решает
много традиционных проблем, связанных с использованием рекурсивного
\GNUmake{}. Единственный недостаток этого подхода, о котором стоит
предупредить~-- для разработчиков, использовавших рекурсивный
\GNUmake{}, потребуется смена парадигмы.
