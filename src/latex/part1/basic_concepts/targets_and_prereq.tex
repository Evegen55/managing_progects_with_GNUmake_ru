%%--------------------------------------------------------------------
%% Targets and prerequisites
%%--------------------------------------------------------------------
\section{Цели и реквизиты}
По существу \Makefile{} содержит набор правил для сборки приложения.
\index{Правила!по умолчанию}
Первое правило, обнаруженное \GNUmake{}, становится \newword{правилом
по умолчанию}. Правила состоят из трёх составляющих: целей, реквизитов
и сценария сборки:

{\footnotesize
\begin{alltt}
\emph{цель: реквизит\subi{1} реквизит\subi{2}
    сценарий сборки
}
\end{alltt}
}

\index{Цели}
\newword{Цель}~--- это файл или некоторая сущность, требующая
обновления.
\index{Реквизиты}
\newword{Реквизиты}~--- это те файлы, которые должны существовать для
того, чтобы цель могла быть собрана.
\index{Сценарий сборки}
\newword{Сценарий сборки}~--- это команды интерпретатора, описывающие
способ создания цели из реквизитов.

Вот правила компиляции исходного файла на языке \Clang{}
\filename{foo.c} в объектный файл \filename{foo.o}:

{\footnotesize
\begin{verbatim}
foo.o: foo.c foo.h
    gcc -c foo.c
\end{verbatim}
}

Цель \filename{foo.o} указана слева от двоеточия, реквизиты
\filename{foo.c} и \filename{foo.h}~--- справа. Сценарий сборки обычно
начинается со следующей строки и предваряется символом табуляции.

Когда требуется выполнить правило, \GNUmake{} пытается найти все
файлы-реквизиты, ассоциированные с целью. Если хотя\hyp{}бы один из
реквизитов выступает в качестве цели какого\hyp{}либо правила, то
сначала выполняется правило для этого реквизита. Далее проверяются
даты последней модификации файла\hyp{}цели и реквизитов: если
какой-либо из реквизитов модифицировался позже цели, то выполняется
сценарий сборки. Каждая строка сценария выполняется в отдельном
процессе командного интерпретатора. Если хотя\hyp{}бы одна команда
приводит к ошибке, сборка цели завершается и \GNUmake{} прекращает
выполнение.

Ниже представлена программа подсчёта числа вхождений слов <<fee>>,
<<fie>>, <<foe>> и <<fum>> в содержимое стандартного потока ввода,
реализованная с помощью лексического анализатора \utility{flex}.

{\footnotesize
\begin{verbatim}
#include <stdio.h>

extern int fee_count, fie_count, foe_count, fum_count;

extern int yylex( void );

int main( int argc, char ** argv )
{
    yylex( );

    printf( "%d %d %d %d \n",
        fee_count, fie_count, foe_count, fum_count );

    exit( 0 );
}
\end{verbatim}
}

Код лексического анализатора очень прост:

{\footnotesize
\begin{verbatim}
        int fee_count = 0;
        int fie_count = 0;
        int foe_count = 0;
        int fum_count = 0;
%%
fee     fee_count++;
fie     fie_count++;
foe     foe_count++;
fum     fum_count++;
\end{verbatim}
}

Составление \Makefile{} для сборки этой программы также не вызывает
затруднений:

{\footnotesize
\begin{verbatim}
count_words: count_words.o lexer.o -lfl
        gcc count_words.o lexer.o -lfl -o count_words

count_words.o: count_words.c
        gcc -c count_words.c

lexer.o: lexer.c
        gcc -c lexer.c

lexer.c: lexer.l
        flex -t lexer.l > lexer.c
\end{verbatim}
}

Когда мы запустим \GNUmake{} впервые, мы увидим следующее:

{\footnotesize
\begin{alltt}
\$ \textbf{make}

gcc -c count\_words.c
flex -t lexer.l > lexer.c
gcc -c lexer.c
gcc counti\_words.o lexer.o -lfl -ocount\_words
\end{alltt}
}

Теперь мы имеем исполняемый файл программы. Естественно, реальные
приложения, как правило, состоят из большего числа модулей, чем наш
пример. Кроме того, позже мы увидим, что наш \Makefile{} не использует
большей части функциональности \GNUmake{} и потому гораздо более
объёмен чем мог бы быть. Тем не менее, это всё-же функциональный и
полезный \Makefile{}.

Как вы могли заметить, порядок, в котором команды реально выполняются,
и порядок их появления в \Makefile{}'е противоположны. Стиль
опеделения <<сверху вниз>> является общим стилем составления
спецификаций для \GNUmake{}. Обычно сначала описываются правила для
наиболее важных целей, а детали оставляются на потом. В \GNUmake{}
существует несколько механизмов поддержки такого стиля. Главными среди
\index{Переменные!рекурсивные}
них являются двухфазовая модель выполнения \GNUmake{} и рекурсивные
переменные. Мы обсудим эти важные детали в последующих главах.
