%%--------------------------------------------------------------------
%% Parsing commands
%%--------------------------------------------------------------------
\section{Синтаксический анализ команд}
\label{sec:parsing_commands}

Строки, начинающиеся с символа табуляции и следующие за спецификацией
цели, считаются командами (если только предыдущая строка не
завершалась символом обратного слэша). Встретив символ табуляции в
другом контексте, GNU \GNUmake{} старается догадаться, что вы имели
ввиду. Например, присваивания переменных, комментарии и директивы
включения могут начинаться с символа табуляции, если это не приводит к
неоднозначности. Если \GNUmake{} обнаруживает команду, которая не
следует за спецификацией цели, выводится сообщение об ошибке:

{\footnotesize
\begin{verbatim}
makefile:20: *** commands commence before first target. Stop.
\end{verbatim}
}

Формулировка этого сообщения немного удивляет, ведь оно часто
появляется в середине \Makefile{}'а, много позже спецификации
<<первой>> цели, однако теперь мы в состоянии понять это сообщение без
особых проблем. Пожалуй, лучшей формулировкой была бы следующая:
<<обнаружена команда вне контекста определения правила>>.

Когда синтаксический анализатор обнаруживает команду в подходящем
контексте, он включает <<режим разбора команды>>, строя сценарий
сборки по строке за раз. Добавление текста к сценарию прекращается,
когда обнаруживается строка, не могущая быть частью сценария.  В
сценарии могут появляться следующие строки:

\begin{itemize}
%---------------------------------------------------------------------
\item Строки, начинающиеся с символа табуляции, являются командами,
предназначенными для выполнения в командном интерпретаторе. Даже
строки, которые могли бы быть интерпретированы как конструкции
\GNUmake{} (например, директивы \directive{ifdef}, \directive{include}
или комментарии), в режиме разбора команд трактуются как команды.
%---------------------------------------------------------------------
\item Пустые строки игнорируются, их выполнение не осуществляется.
%---------------------------------------------------------------------
\item Строки, начинающиеся с символа \command{\#}, возможно, с
начальными пробелами (не символами табуляции!), воспринимаются как
комментарии \GNUmake{} и игнорируются.
%---------------------------------------------------------------------
\item Директивы условной обработки, такие как \directive{ifdef} и
\directive{ifeq}, распознаются и правильно обрабатываются в контексте
сценария сборки.
%---------------------------------------------------------------------
\end{itemize}

Встроенные функции \GNUmake{}, не предваряемые символом табуляции, не
приводят к выходу из режима разбора команд. Это значит, что их
значением должны быть допустимые команды интерпретатора или пустая
строка.  Значением функций \function{warning} или \function{eval}
является пустая строка.

Тот факт, что пустые строки или комментарии \GNUmake{} допустимы в
сценариях сборки, поначалу может удивлять. Следующий пример
показывает, как это работает:

{\footnotesize
\begin{verbatim}
long-command:
    @echo Строка 2:  далее пустая строка

    @echo Строка 4:  далее комментарий shell
    # Комментарий командного интерпретатора \
      (начинается с символа табуляции)
    @echo Строка 6:  далее комментарий make
# комментарий make в начале строки
    @echo Строка 8:  далее комментарий make
  # выровненный пробелами комментарий make
    # ещё один выровненный пробелами комментарий make
    @echo Строка 11: далее директива make
  ifdef COMSPEC
    @echo мы работаем под Windows
  endif
    @echo Строка 15: далее <<команда>> warning
    $(warning предупреждение)
    @echo Строка 17: далее <<команда>> eval
    $(eval $(shell echo Вывод shell 1>&2))
\end{verbatim}
}

Заметим, что строки 5 и 10 выглядят очень похоже, но по сути они очень
разные. Строка 5 содержит комментарий командного интерпретатора,
начинающийся с символа табуляции, в то время как строка 10 содержит
комментарий \GNUmake{}, начинающийся с отступа в 4 пробела.  Очевидно,
что форматирование своих \Makefile{}'ов подобным образом~--- не самая
лучшая идея (если только вы не собираетесь участвовать в конкурсе
самых запутанных \Makefile{}'ов). Как вы можете видеть из следующего
листинга, комментарии \GNUmake{} не выполняются и не выводятся, даже
если они появляются в контексте сценария сборки:

{\footnotesize
\begin{verbatim}
$ make
makefile:2: предупреждение
Вывод shell
Строка 2:  далее пустая строка
Строка 4:  далее коментарий shell
# комментарий командного интерпретатора (начинается...)
Строка 6:  далее комментарий make
Строка 8:  далее комментарий make
Строка 11: далее директива make
мы работаем под Windows
Строка 15: далее <<команда>> warning
Строка 17: далее <<команда>> eval
\end{verbatim}
}

Сначала может показаться, что вывод функций \function{warning} и
\function{eval} появился слишком рано, однако это не так (мы обсудим
порядок вычисления в этой главе в разделе
<<\nameref{sec:evaluating_commands})>>. Тот факт, что сценарий сборки
может содержать произвольное число пустых строк и комментариев, может
быть источником трудно находимых ошибок.  Предположим, вы случайно
добавили строку с начальным символом табуляции.  Если выше неё
располагается определение цели, за которым следуют только комментарии
и пустые строки, \GNUmake{} будет трактовать вашу строку со случайным
символом табуляции как команду, ассоциированную с предыдущей целью.
Как вы уже видели, это вполне допустимо и не вызовет ошибки или
предупреждения, пока та же цель не встретится в составе другого
правила в другом месте \Makefile{}'а (или во включаемом файле).

Если вам повезёт, ваш \Makefile{} будет содержать непустую строку, не
содержащую комментария, между вашей ошибочной строкой и предыдущим
сценарием сборки. В этом случае вы получите сообщение <<commands
commence before first target>>.

Сейчас самое время упомянуть об инструментальных средствах. Я думаю,
теперь все согласны с тем, что использование символа табуляции для
обозначения команды было не самым удачным решением, однако теперь уже
поздно что-либо менять. Использование современного, понимающего
синтаксис текстового редактора может помочь вам предотвратить
потенциальные проблемы с помощью цветового выделения сомнительных
конструкций. GNU \utility{emacs} имеет довольно удобный режим для
редактирования \Makefile{}'ов. Этот режим осуществляет подсветку
синтаксиса и находит простые синтаксические ошибки, такие как пробелы
после символа переноса строки или смешанные символы табуляции и
пробелы. Мы вернёмся к теме совместного использования редактора
\utility{emacs} и \GNUmake{} немного позже.

%---------------------------------------------------------------------
% Continuing long commands
%---------------------------------------------------------------------
\subsection{Продолжение длинных команд}

Поскольку каждая команда выполняется в отдельном процессе командного
интерпретатора, последовательности выражений, которые должны
выполняться совместно, должны обрабатываться особым образом.
Предположим для примера, что нам нужно создать файл, содержащий список
файлов. Компилятор \Java{} принимает такие файлы в случае, если нужно
скомпилировать много исходного кода. Для этой цели мы можем написать
следующее правило:

{\footnotesize
\begin{verbatim}
.INTERMEDIATE: file_list

file_list:
    for d in logic ui
    do
      echo $d/*.java
    done > $@
\end{verbatim}
}

Очевидно, что этот пример не будет работать и вызовет ошибку при
запуске:

{\footnotesize
\begin{alltt}
  \${} \textbf{make}
  for d in logic ui
  /bin/sh: -c: line 2: syntax error: unexpected end of file
  make: *** [file\_{}list] Error 2
\end{alltt}
}

В качестве решения можно попробовать добавить символы продолжения в
конце каждой строки:

{\footnotesize
\begin{verbatim}
.INTERMEDIATE: file_list

file_list:
    for d in logic ui \
    do                \
      echo $d/*.java  \
    done > $@
\end{verbatim}
}

Однако теперь при запуске появляется другая ошибка:

{\footnotesize
\begin{alltt}
\${} \textbf{make}
for d in logic ui \textbackslash{}
do                \textbackslash{}
  echo /*.java    \textbackslash{}
done > file\_list
/bin/sh: -c: line 1: syntax error near unexpected token `>'
/bin/sh: -c: line 1: `for d in logic ui do       echo /*.java
make: *** [file\_list] Error 2
\end{alltt}
}

Что же произошло? В коде есть две ошибки. Во-первых, ссылка на
переменную цикла, \variable{d}, должна быть экранирована. Во-вторых,
поскольку цикл передаётся в интерпретатор одной строкой, мы должны
добавить точку с запятой после списка файлов и выражения в теле цикла:

{\footnotesize
\begin{verbatim}
.INTERMEDIATE: file_list

file_list:
    for d in logic ui; \
    do                 \
      echo $d/*.java;  \
    done > $@
\end{verbatim}
}

Теперь мы получим именно то, что ожидали. Поскольку цель
\target{file\_list} помечена как \variable{.INTERMEDIATE}, \GNUmake{}
удалит её после завершения компиляции.

В более реалистичном примере список файлов будет храниться в
переменной \GNUmake{}. Если есть уверенность в том, что этот список
достаточно мал, мы можем осуществить ту же операцию без использования
цикла, используя только встроенные функции \GNUmake{}:

{\footnotesize
\begin{verbatim}
.INTERMEDIATE: file_list

file_list:
    echo $(addsuffix /*.java,$(COMPILATION_DIRS)) > $@
\end{verbatim}
}

Однако у версии с циклом меньше шансов столкнуться с проблемой
конечности длины командной строки, если список каталогов будет расти
со временем.

Ещё одной общей проблемой является смена текущего каталога:

{\footnotesize
\begin{verbatim}
TAGS:
    cd src
    ctags --recurse
\end{verbatim}
}

Очевидно, что предыдущий пример не выполнит программу \utility{ctags}
в каталоге \filename{src}. Чтобы добиться желаемого эффекта, мы должны
либо разместить оба выражения в одной строке, либо экранировать символ
новой строки (разделив выражения точкой с запятой):

{\footnotesize
\begin{verbatim}
TAGS:
    cd src; \
    ctags --recurse
\end{verbatim}
}

Ещё более разумно проверять статус выполнения программы \utility{cd}
перед выполнением \utility{ctags}:

{\footnotesize
\begin{verbatim}
TAGS:
    cd src && \
    ctags --recurse
\end{verbatim}
}

Заметим, что при некоторых обстоятельствах можно опустить точку с
запятой, не вызвав ошибки командного интерпретатора или \GNUmake{}:

{\footnotesize
\begin{verbatim}
disk-free = echo "Проверяем размер дискового пространства..." \
    df . | awk '{ print $$4 }'
\end{verbatim}
}

Этот пример выводит простое сообщение, за которым следует число
свободных блоков на текущем устройстве. Или нет? Мы случайно забыли
поставить точку с запятой после команды \utility{echo}, в результате
чего программа \utility{df} никогда не будет запущена. Вместо этого мы
направим сообщение <<\command{Проверяем размер дискового
пространства...  df .}>> на вход программы \utility{awk}, которая
напечатает четвёртое поле строки, т.е. \command{пространства...}.

Возможно, вам приходилось использовать директиву \directive{define},
предназначенную для создания многострочных последовательностей. К
сожалению, она не решает проблемы переносов строк. Когда происходит
подстановка макроса, каждая его строка вставляется в сценарий сборки с
начальным символом табуляции, и \GNUmake{} работает с каждой строкой
независимо. Разные строки макроса выполняются в разных экземплярах
командного интерпретатора, поэтому вам следуюет обращать внимание на
перенос строк даже в определениях макросов.

%---------------------------------------------------------------------
% Command modifiers
%---------------------------------------------------------------------
\subsection{Модификаторы команд}
\label{sec:command_modifiers}

\index{Модификаторы команд}
Команды могут быть модифицированы при помощи нескольких префиксов.  Мы
уже встречались с <<молчаливым>> префиксом, \command{@}, ниже приведён
полный список возможных префиксов с некоторыми комментариями:

\begin{description}
%---------------------------------------------------------------------
\item[\command{@}] \hfill \\
Подавляет вывод команды. Для исторической совместимости вы можете
поместить вашу команду в реквизиты специальной цели \target{.SILENT},
если хотите, чтобы все команды, ассоциированные с вашей целью, были
скрыты. Однако использование \texttt{@} предпочтительней, поскольку
этот модификатор может быть применён к отдельным командам в сценарии.
Если вы хотите применить модификатор ко всем целям, используйте
\index{Опции!silent@\command{-{}-silent (-s)}}
опцию \command{-{}-si\-lent} (или просто \command{-s}).

Сокрытие команд может сделать вывод \GNUmake{} приятнее для глаза,
однако это также ведёт к затруднениям при отладке. Если вы обнаружите,
что часто удаляете модификатор \command{@}, а затем возвращаете его на
место, разумно завести переменную (к примеру, \variable{QUIET}),
содержащую модификатор, и использовать её в командах:

{\footnotesize
\begin{verbatim}
QUIET = @
hairy_script:
    $(QUIET) сложный сценарий ...
\end{verbatim}
}

В этом случае при необходимости увидеть сложный сценарий в том виде, в
котором его выполняет \GNUmake{}, просто сбросьте значение переменной
\variable{QUIET} в командной строке:

{\footnotesize
\begin{alltt}
\${} \textbf{make QUIET= hairy\_script}
сложный сценарий ...
\end{alltt}
}

%---------------------------------------------------------------------
\item[\command{-}] \hfill \\
Этот префикс сообщает \GNUmake{}, что ошибки, возникающие при
выполнении помеченной команды, следует игнорировать. По умолчанию
\GNUmake{} проверяет код возврата каждой программы или конвейера
программ. Если какая-то программа завершается с ненулевым кодом,
\GNUmake{} прерывает выполнение оставшейся части сценария и завершает
своё выполнение. Этот модификатор заставляет \GNUmake{} игнорировать
код возврата модифицированной строки и продолжать выполнение в обычном
режиме. Мы обсудим эту тему подробнее в следующем разделе.

Для исторической совместимости вы можете игнорировать ошибки в части
сценария сборки, поместив соответствующую цель в реквизиты специальной
цели \target{.IGNORE}. Вы можете игнорировать все ошибки в
\index{Опции!ignore-errors@\command{-{}-ignore\hyp{}errors (-i)}}
\Makefile{}'е используя опцию \command{-{}-ig\-no\-re\hyp{}errors}
(или \command{-i}).  Однако полезность этой возможности вызывает
сомнения.

%---------------------------------------------------------------------
\item[\texttt{+}] \hfill \\
Этот модификатор сообщает \GNUmake{}, что помеченная им команда должна
выполняться даже в том случае, если в опциях командной строки
встречается \command{-{}-just\hyp{}print} (или \command{-n}). Этот
модификатор используется при составлении рекурсивных \Makefile{}'ов.
Мы обсудим эту тему в разделе <<\nameref{sec:recursive_make}>>
главы~\ref{chap:managing_large_proj}.
%---------------------------------------------------------------------
\end{description}

Все модификаторы должны встречаться в строке только один раз.
Очевидно, перед выполнением команд модификаторы вырезаются.

%-------------------------------------------------------------------
% Errors and interrupts
%-------------------------------------------------------------------
\subsection{Ошибки и прерывания}

Каждая команда, выполняемая \GNUmake{}, возвращает код ошибки. Нулевой
код соответствует успешному выполнению команды, ненулевой~--- ошибочной
ситуации. Некоторые программы используют код возврата для передачи
более полезной информации, чем просто факта возникновения ошибки.
Например, программа \utility{grep} возвращает 0 в случае обнаружения
соответствия шаблону, 1 в случае отсутствия соответствий и 2 в случае
возникновения ошибки какого-либо рода.

Обычно при ошибке выполнения команды (т.е. при возвращении ненулевого
кода ошибки) \GNUmake{} прекращает выполнение команд и завершает
выполнение с ненулевым кодом возврата. Иногда нужно, чтобы \GNUmake{}
продолжал работу, собрав столько целей, сколько возможно. Например,
вам может понадобиться скомпилировать максимально возможное число
исходных файлов, чтобы увидеть все ошибки компиляции в один проход.
Вы можете добиться такого поведения при помощи опции
\index{Опции!keep-going@\command{-{}-keep\hyp{}going (-k)}}
\command{-{}-keep\hyp{}going} (или \command{-k}).

Поскольку модификатор \command{-} заставляет \GNUmake{} игнорировать
ошибки в отдельных командах, я стараюсь избегать его использования,
поскольку это усложняет автоматическую обработку ошибок и привносит в
код небрежность.

Когда \GNUmake{} игнорирует ошибку, выводится сообщение об ошибке с
именем цели в квадратных скобках. Ниже приведён вывод, полученный при
попытке удаления несуществующего файла:

{\footnotesize
\begin{verbatim}
rm non-existent-file
rm: cannot remove `non-existent-file': No such file or directory
make: [clean] Error 1 (ignored)
\end{verbatim}
}

Некоторые команды (например, \utility{rm}) имеют опции для подавления
ошибочных кодов возврата. Опция \command{-f} заставит программу
\utility{rm} вернуть нулевой код ошибки и подавить вывод
предупреждений. Использование этой опции лучше, чем зависимость от
модификатора.

Бывают случаи, когда возврат программой нулевого кода ошибки считается
неудачей и наоборот. В таких случаях можно просто инвертировать код
возврата программы:

{\footnotesize
\begin{verbatim}
# Убедимся, что в коде не осталось отладочных сообщений.
.PHONY: no_debug_printf

no_debug_printf: $(sources)
    ! grep --line-number '"debug:' $^
\end{verbatim}
}

К сожалению, версия GNU \GNUmake{} 3.80 содержит ошибку, мешающую
непосредственному использованию этой возможности: \GNUmake{} не
распознаёт символ \command{!} как часть команды, требующей вызова
командного интерпретатора, и выполняет оставшуюся часть строки
самостоятельно, вызывая ошибку. В качестве простого обхода проблемы
можно использовать в команде специальные символы как намёк для
\GNUmake{}:

{\footnotesize
\begin{verbatim}
# Убедимся, что в коде не осталось отладочных сообщений.
.PHONY: no_debug_printf

no_debug_printf: $(sources)
    ! grep --line-number '"debug:' $^ < /dev/null
\end{verbatim}
}

Другим источником неожиданных ошибок в командах является оператор
\command{if} без ветки \command{else}:

{\footnotesize
\begin{verbatim}
$(config): $(config_template)
    if [ ! -d $(dir $@) ];  \
    then                    \
        $(MKDIR) $(dir $@); \
    fi
    $(M4) $^ > $@
\end{verbatim}
}

Первая команда проверяет, существует ли целевой каталог и в случае
необходимости вызывает программу \utility{mkdir} для его создания. К
сожалению, если каталог существует, команда \command{if} вернёт
ненулевой код ошибки (код возврата программы \utility{test}), что
приведёт к завершению работы сценария. Одним из решений этой проблемы
является добавление ветви \command{else}:

{\footnotesize
\begin{verbatim}
$(config): $(config_template)
    if [ ! -d $(dir $@) ];  \
    then                    \
        $(MKDIR) $(dir $@); \
    else                    \
        true;               \
    fi
    $(M4) $^ > $@
\end{verbatim}
}

Двоеточие (\command{:})~--- это команда интерпретатора, которая всегда
возвращает истину, поэтому её можно использовать вместо \command{true}.
Альтернативной рабочей реализацией является следующая:

{\footnotesize
\begin{verbatim}
$(config): $(config_template)
    [[ -d $(dir $@) ]] || $(MKDIR) $(dir $@)
    $(M4) $^ > $@
\end{verbatim}
}

 Теперь первое выражение истинно, если целевой каталог существует или
 выполнение программы \utility{mkdir} завершилось успешно. Другой
 альтернативой является использование ключа \command{-t} программы
 \utility{mkdir}. Это приведёт к успешному завершению \utility{mkdir}
 даже в том случае, если требуемый каталог уже сужествует.

Все предыдущие реализации вызывали интерпретатор даже в том случае,
если каталог уже существовал. Использование функции
\function{wildcard} позволяет избежать выполнения команд в случае
наличия каталога:

{\footnotesize
\begin{verbatim}
# $(call make-dir, directory)
make-dir = $(if $(wildcard $1),,$(MKDIR) -p $1)

$(config): $(config_template)
    $(call make-dir, $(dir $@))
    $(M4) $^ > $@
\end{verbatim}
}

Поскольку каждая команда выполняется в отдельном экземпляре командного
интерпретатора, общей практикой является использование многострочных
команд, разделённых точками с запятой. Остерегайтесь случаев, когда
ошибка в таких сценариях может не привести к завершению выполнения
сборки:

{\footnotesize
\begin{verbatim}
target:
    rm rm-неудачен; echo но следующая команда выполняется 
\end{verbatim}
}

Лучшей практикой является минимизация длины сценария, что даёт
\GNUmake{} шанс обработать код возврата самостоятельно. Например:

{\footnotesize
\begin{verbatim}
path-fixup = \
    -e "s;[a-zA-Z:/]*/src/;$(SOURCE_DIR)/;g" \
    -e "s;[a-zA-Z:/]*/bin/;$(OUTPUT_DIR)/;g"

# хорошая версия
define fix-project-paths
  sed $(path-fixup) $1 > $2.fixed && \
  mv $2.fixed $2
endef

# отличная версия
define fix-project-paths
  sed $(path-fixup) $1 > $2.fixed
  mv $2.fixed $2
endef
\end{verbatim}
}

Этот макрос преобразует пути в стиле DOS (с прямыми слэшами) в пути
назначения для определённой структуры каталогов исходного кода и
бинарных файлов. Макрос принимает имена двух файлов: входного и
выходного. Кроме того, принимаются дополнительные действия, чтобы
выходной файл был перезаписан только в том случае, если \utility{sed}
завершится корректно. В <<хорошей>> версии это достигается за счёт
соединения программ \utility{sed} и \utility{mv} операцией
\command{\&\&}, в результате чего они выполняются в одном экземпляре
командного интерпретатора. <<Лучшая>> версия выполняет их как две
отдельных команды, позволяя \GNUmake{} завершить выполнение сценария,
если программа \utility{sed} завершится неудачей. Однако <<лучшая>>
версия не является менее производительной (программа \utility{mv} не
требует вызова командного интерпретатора и выполняется непосредственно
\GNUmake{}), к тому же её легче понять, а в случае возникновения
ошибки полученное сообщение будет более информативным (поскольку
\GNUmake{} укажет, какая именно команда закончилась неудачей).

Заметим, что предыдущая ситуация не имеет отношения к общей проблеме
команды \utility{cd}:

{\footnotesize
\begin{verbatim}
TAGS:
    cd src && \
    ctags --recurse
\end{verbatim}
}

В этом случае оба выражения должны выполняться в одном процессе
командного интерпретатора, поэтому должен использоваться разделитель
команд, например, \command{;} или \command{\&\&}.

%---------------------------------------------------------------------
% Deleting and preserving target files
%---------------------------------------------------------------------
\subsubsection*{Удаление и сохранение целевых файлов}
Если происходит ошибка, \GNUmake{} подразумевает, что повторная сборка
цели не может быть осуществлена. В этом случае любая другая цель,
имеющая текущую в качестве реквизита, также не может быть собрана,
поэтому \GNUmake{} не будет даже пытаться осуществить её сборку. Если
использована опция \command{-{}-keep\hyp{}going} (\command{-k}), будет
произведена попытка сборки следующей цели, иначе \GNUmake{} закончит
своё выполнение. Если текущей целью является файл, его содержимое
может быть повреждено, если команда из сценария завершится, не
закончив своей работы. К сожалению, \GNUmake{} оставит этот
потенциально повреждённый файл на диске из соображений исторической
совместимости. Поскольку время последнего изменения файла будет
изменено, все последующие вызовы \GNUmake{} не смогут поместить в этот
файл корректные данные. Вы можете избежать этой проблемы и заставить
\GNUmake{} удалять эти подозрительные файлы в случае возникновения
ошибки, указав целевой файл реквизитом специальной цели
\index{Цели!специальные!.DELETE\_ON\_ERROR@\target{.DELETE\_ON\_ERROR}}
\target{.DELETE\_ON\_ERROR}. Если цель \target{.DELETE\_ON\_ERROR}
используется без реквизитов, ошибка при сборке любого файла приведёт к
его удалению.

Дополнительные проблемы связаны с ситуацией, когда выполнение
\GNUmake{} прерывается сигналом, например, по нажатию клавиш Ctrl-C. В
этом случае \GNUmake{} удалит текущий целевой файл, если он был
модифицирован. Иногда удаление целевого файла не является желаемой
реакцией. Возможно, создание целевого файла~--- чрезвычайно затратная
операция, или получение части его содержимого желательней полного
его отсутствия. В таком случае вы можете защитить целевой файл, сделав
\index{Цели!специальные!.PRECIOUS@\target{.PRECIOUS}}
его реквизитом специальной цели \target{.PRECIOUS}.
