%%--------------------------------------------------------------------
%% Advanced user-defined functions
%%--------------------------------------------------------------------
\section{Специальные функции}
\label{sec:advanced_user_def_func}

Мы потратим много времени на написание макросов-функций. К сожалению,
\GNUmake{} имеет довольно скудные возможности для их отладки. Давайте
попробуем написать простую функцию для вывода отладочной информации.

Как уже было замечено, функция \function{call} связывает свои
параметры с позиционными параметрами \variable{\$1}, \variable{\$2} и
т.д. На вход этой функции может быть передано произвольное число
переменных. Особым случаем является имя вызываемой функции (т.е. имя
переменной), доступ к которому может быть осуществлён с помощью
переменной \variable{\$0}. Используя эту информацию, мы можем
написан пару отладочных функций для вывода результатов подстановки
макросов:

{\footnotesize
\begin{verbatim}
# $(debug-enter)
debug-enter = \
    $(if $(debug_trace),\
      $(warning Entering $0($(echo-args))))

# $(debug-leave)
debug-leave = \
    $(if $(debug_trace),$(warning Leaving $0))

comma := ,

echo-args   = \
    $(subst ' ','$(comma) ',\
      $(foreach a,1 2 3 4 5 6 7 8 9,'$($a)'))
\end{verbatim}
}

Если мы хотим узнать, как вызываются функции \function{a} и
\function{b}, мы можем использовать описанные выше функции следующим
образом:

{\footnotesize
\begin{verbatim}
debug_trace = 1

define a
  $(debug-enter)
  @echo $1 $2 $3
  $(debug-leave)
endef

define b
  $(debug-enter)
  $(call a,$1,$2,hi)
  $(debug-leave)
endef

trace-macro:
    $(call b,5,$(MAKE))
\end{verbatim}
}

Разместив переменные \function{debug-enter} и \function{debug-leave}
в начале и конце ваших собственных функций, вы сможете получать
отладочную информацию о их вызове. Однако эти функции далеки от
совершенства. Функция \function{echo-args} выводит только первые
девять аргументов, хуже того, она не может определить фактическое
число переданных аргументов (конечно, ведь \GNUmake{} тоже не может этого
сделать!). Тем не менее, я использовал эти макросы <<как есть>>
при отладке собственных \Makefile{}'ов. После выполнения предыдущего
примера мы сможем увидеть следующий вывод:

{\footnotesize
\begin{alltt}
\${} \textbf{make}
makefile:14: Entering b( '5', 'make', '', ...)
makefile:14: Entering a( '5', 'make', 'hi', '', ...)
makefile:14: Leaving a
makefile:14: Leaving b
5 make hi
\end{alltt}
}
Как сказал недавно один мой друг, <<я никогда раньше не думал о make
как о языке программирования>>. GNU \GNUmake{}~--- это не тот
\GNUmake{}, которым пользовались наши прадеды.

%-------------------------------------------------------------------
% eval and value
%-------------------------------------------------------------------
\subsection{Функции \function{eval} и \function{value}}

Функция \function{eval} принципиально отличается от остальных
встроенных функций. Её назначением является передача текста
синтаксическому арализатору \GNUmake{}. Вот пример её использования:

{\footnotesize
\begin{verbatim}
$(eval sources := foo.c bar.c)
\end{verbatim}
}

Аргумент функции \function{eval} сначала проверяется на наличие
переменных и при необходимости осуществляется подстановка (тоже самое
осуществляется для аргументов всех функций), затем полученный текст
разбирается и выполняется так, будто он был написан в файле
спецификации.  Приведённый пример настолько прост, что вы могли
удивиться, зачем вам вообще нужна эта функция. Однако давайте
рассмотрим более сложный пример. Предположим, у вас есть один
\Makefile{} для сборки десятка различных программ, и вы хотите
определить несколько переменных для каждой из этих программ, например,
\variable{sources}, \variable{headers} и \variable{objects}. Вместо
повторения определений этих переменных снова и снова:

{\footnotesize
\begin{verbatim}
ls_sources := ls.c glob.c
ls_headers := ls.h glob.h
ls_objects := ls.o glob.o
...
\end{verbatim}
}

{\flushleft мы можем попробовать определить макрос для выполнения
рутинной работы:}

{\footnotesize
\begin{verbatim}
# $(call program-variables, variable-prefix, file-list)
define program-variables
  $1_sources = $(filter %.c,$2)
  $1_headers = $(filter %.h,$2)
  $1_objects = $(subst .c,.o,$(filter %.c,$2))
endef

$(call program-variables, ls, ls.c ls.h glob.c glob.h)
show-variables:
    # $(ls_sources)
    # $(ls_headers)
    # $(ls_objects)
\end{verbatim}
}

Макрос \function{program-variables} принимает два аргумента: префикс
для имени трёх переменных и список файлов, из которого макрос выбирает
файлы для определения каждой переменной. Но если мы попробуем
использовать этот макрос, мы получим ошибку:

{\footnotesize
\begin{alltt}
\$ \textbf{make}
Makefile:7: *** missing separator. Stop.
\end{alltt}
}

Этот способ не работает так, как ожидалось, из-за алгоритма работы
синтаксического анализатора \GNUmake{}. Макрос, вычисляемый на верхнем
уровне, результат подстановки которого занимает больше одной строки,
считается некорректным и приводит к синтаксической ошибке. В нашем
случае анализатор ожидает, что строка является правилом или частью
сценария сборки, но не обнаруживает подходящего разделителя. Довольно
непонятное сообщение об ошибке.  Функция \function{eval} была создана
для решения этой проблемы. Если мы заменим нашу строку, содержащую
\function{call}, на следующую:

{\footnotesize
\begin{verbatim}
$(eval $(call program-variables, ls, ls.c ls.h glob.c glob.h))
\end{verbatim}
}

{\flushleft то получим именно то, что ожидали:}

{\footnotesize
\begin{alltt}
\${} \textbf{make}
# ls.c glob.c
# ls.h glob.h
# ls.o glob.o
\end{alltt}
}

Использование \function{eval} решает проблему с синтаксическим
анализатором, так как функция \function{eval} обрабатывает
многострочные значения макросов и возвращает пустую строку.

Теперь у нас есть макрос, который определяет три переменных и не
требует набора большого количества текста вручную. Заметим, что имена
определяемых переменных в макросе составляются с помощью префикса,
переданного в качестве аргумента, и фиксированного суффикса,
\variable{\$1\_sources}. Это напоминает технику переменных с
вычисляемыми именами, описанную ранее.

Продолжая этот пример, можно заметить, что правила также могут быть
заключены в макрос:

{\footnotesize
\begin{verbatim}
# $(call program-variables,variable-prefix,file-list)
define program-variables
  $1_sources = $(filter %.c,$2)
  $1_headers = $(filter %.h,$2)
  $1_objects = $(subst .c,.o,$(filter %.c,$2))

  $($1_objects): $($1_headers)
endef

ls: $(ls_objects)

$(eval $(call program-variables,ls,ls.c ls.h glob.c glob.h))
\end{verbatim}
}

Обратите внимание, как две версии функции \function{program-variables}
иллюстрируют проблему пробелов в аргументах функции. В предыдущей
версии использование аргументов функции было устойчивым к начальным
пробелам, то есть поведение кода не изменялось при добавлении
начальных пробелов к переменным \variable{\$1} и \variable{\$2}.
Однако в новой версии были введены вычисляемые имена переменных
\variable{\$(\$1\_objects)} и \variable{\$(\$1\_headers)}.
Теперь добавление пробелов к первому аргументу функции (\command{ls})
приведёт к тому, что имена переменных будут вычислены неправильно,
вследствие чего вместо списка файлов будет подставлена пустая строка.
Обычно обнаружить подобную ошибку довольно сложно.

Когда мы запустим на выполнение наш \Makefile{}, обнаружится, что
\GNUmake{} игнорирует некоторые \filename{.h} реквизиты.  Чтобы понять
причину этой проблемы, исследуем внутреннюю базу данных \GNUmake{},
использовав ключ \command{-{}-print\hyp{}data\hyp{}base}:

{\footnotesize
\begin{alltt}
\${} \textbf{make --print-database | grep \^{}ls}
ls\_headers = ls.h glob.h
ls\_sources = ls.c glob.c
ls\_objects = ls.o glob.o
ls.c:
ls.o: ls.c
ls: ls.o
\end{alltt}
}

Все \filename{.h} реквизиты для \filename{ls.o} пропущены! В правило,
использующее вычисляемые имена переменных, вкралась какая-то ошибка.

Когда \GNUmake{} производит синтаксический анализ вызова функции
\function{call}, сначала производится вычисление функции, определённой
пользователем, \function{program-variables}. После подстановки первая
строка макроса выглядит так:

{\footnotesize
\begin{verbatim}
ls_sources = ls.c glob.c
\end{verbatim}
}

Заметим, что каждая строка макроса вычисляется сразу же, как и
ожидалось.  Остальные определения переменных обрабатываются также.
Затем происходит обработка правила:

{\footnotesize
\begin{verbatim}
$($1_objects): $($1_headers)
\end{verbatim}
}

Сначала вычисляются имена переменных:

{\footnotesize
\begin{verbatim}
$(ls_objects): $(ls_headers)
\end{verbatim}
}

Затем происходит подстановка значений переменных, что порождает
следующее выражение:

{\footnotesize
\begin{verbatim}
:
\end{verbatim}
}

Подождите! Куда делись значения наших переменных? Дело в том, что
предыдущие три определения были правильно вычислены, но не были
интерпретированы \GNUmake{}. Давайте посмотрим, как это работает.  Как
только был произведён вызов \function{program-variables}, \GNUmake{}
<<видит>> следующее:

{\footnotesize
\begin{verbatim}
$(eval ls_sources = ls.c glob.c
ls_headers = ls.h glob.h
ls_objects = ls.o glob.o

:)
\end{verbatim}
}

Затем выполняется функция \function{eval}, после чего определяются три
переменные. Итак, причина найдена: переменные в правиле используются
до того, как были определены.

Мы можем решить эту проблему, указав явно на необходимость отложить
вычисление переменных, используемых в правиле, до момента их
определения.  Это можно сделать, экранировав знак доллара в вызове
переменных с вычисляемым именем:

{\footnotesize
\begin{verbatim}
$$($1_objects): $$($1_headers)
\end{verbatim}
}

На этот раз база данных \GNUmake{} содержит те реквизиты, которые мы
ожидали:

{\footnotesize
\begin{alltt}
\${} \textbf{make -p | grep \^{}ls}
ls\_headers = ls.h glob.h
ls\_sources = ls.c glob.c
ls\_objects = ls.o glob.o
ls.c:
ls.o: ls.c ls.h glob.h
ls: ls.o
\end{alltt}
}

Итак, аргумент функции \function{eval} вычисляется дважды: сначала при
подготовке списка аргументов для \function{eval}, затем ещё раз
синтаксическим анализатором.

Мы решили предыдущую проблему, отложив вычисление переменных. Вторым
способом решения этой проблемы является обёртка каждого определения
переменной дополнительным вызовом функции \function{eval}:

{\footnotesize
\begin{verbatim}
# $(call program-variables,variable-prefix,file-list)
define program-variables
  $(eval $1_sources = $(filter %.c,$2))
  $(eval $1_headers = $(filter %.h,$2))
  $(eval $1_objects = $(subst .c,.o,$(filter %.c,$2)))

  $($1_objects): $($1_headers)
endef

ls: $(ls_objects)
    $(eval $(call program-variables,ls,ls.c ls.h\
	glob.c glob.h))
\end{verbatim}
}

Заключая каждое определене переменной в собственный вызов
\function{eval}, мы форсируем их вычисление в процессе подстановки
макроса \function{program-variables}, поэтому их можно использовать
непосредственно в теле макроса.

Лишь только мы улучшили наш \Makefile{}, нашлось ещё одно правило,
которое можно добавить в макрос. Исполняемый файл программы зависит от
объектных файлов. Поэтому, в завершение нашего параметризованного
\Makefile{}'а, мы добавим цель \target{all} и переменную, содержащую
список программ, сборкой которых может управлять наш \Makefile{}:

{\footnotesize
\begin{verbatim}
#$(call program-variables,variable-prefix,file-list)
define program-variables
  $(eval $1_sources = $(filter %.c,$2))
  $(eval $1_headers = $(filter %.h,$2))
  $(eval $1_objects = $(subst .c,.o,$(filter %.c,$2)))
  
  programs += $1

  $1: $($1_objects)

  ($1_objects): $($1_headers)
endef

# Объявляем цель по умолчанию
all:

$(eval $(call program-variables,ls,ls.c ls.h glob.c glob.h))
$(eval $(call program-variables,cp,...))
$(eval $(call program-variables,mv,...))
$(eval $(call program-variables,ln,...))
$(eval $(call program-variables,rm,...))

# Определяем реквизиты цели по умолчанию
all: $(programs)
\end{verbatim}
}

Обратите внимание на расположение цели \target{all} и её реквизитов.
Переменная \variable{programs} не имеет правильного значения до
осуществления пяти вызовов \function{eval}, но мы хотели бы объявить
\target{all} целью по умолчанию, поместив её объявление первым в
\Makefile{}'е. Мы можем удовлетворить всем ограничениям, объявив цель
\target{all} первой и добавив реквизиты позже.

Функция \function{program-variables} имеет недостатки, поскольку
некоторые переменные вычисляются слишком рано. Для решения этой
проблемы \GNUmake{} предоставляет функцию \function{value}, которая
получает имя переменной в качестве аргумента и возвращает её значение,
не осуществляя подстановок. Результат выполнения \function{value}
может быть передан для обработки функции \function{eval}. Возвращая
значение переменной, в котором не осуществлены подстановки, мы можем
избежать проблем, из-за которых нам пришлось экранировать знаки
доллара в нашем макросе.

К несчастью, функцию \function{value} нельзя использовать в макросе
\function{program-variables}, поскольку она следует принципу <<всё или
ничего>>, не осуществляя подстановки ни одной переменной в аргументе.
Более того, \function{value} не принимает параметров (а при
обнаружении не производит с ними никаких действий), поэтому имя нашей
программы и список файлов останутся нетронутыми.

Из-за этих ограничений вы не очень часто будете видеть функцию
\function{value} на страницах этой книги.

%---------------------------------------------------------------------
% Hooking functions
%---------------------------------------------------------------------
\subsection{Триггеры}

Функции, определяемые пользователем~--- это просто переменные,
содержащие текст. Функция \function{call} заменяет вхождения
позиционных параметров \variable{\${}1}, \variable{\${}2} и т.д.
значениями фактических параметров, то есть разрешает ссылки в значении
переменной, если они существуют. Если переменная не содержит
формальных параметров, \function{call} не обратит на это внимания.
Более того, если переменная вообще не содержит текста, \function{call}
не произведёт никаких действий.  Не будет вывода предупреждений или
сообщений об ошибках. Это может разочаровать, если вы случайно
допустили опечатку в имени вызываемой функции, однако иногда это очень
полезно.

По своей сути функции~--- воплощение идеи повторного использования
кода. Чем чаще вы используете какую-то функцию, тем более тщательно
стоит подойти к её реализации. Функции можно сделать более удобными
для повторного использования, если добавить к ним триггеры.
\index{Триггеры}
\newword{Триггер} (\newword{hook})~--- это ссылка на функцию, которая
может быть определена пользователем для осуществления его собственных
задач в процессе выполнения общих операций. 

Предположим, ваш \Makefile{} служит для сборки множества библиотек.
На одних платформах вы предпочли бы запуск \utility{ranlib}, на других
больше подходит \utility{chmod}. Вместо явного указания команд для
этих операций вы можете написать функцию и добавить к ней триггер:

{\footnotesize
\begin{verbatim}
# $(call build-library, object-files)
define build-library
  $(AR) $(ARFLAGS) $@ $1
  $(call build-library-hook,$@)
endef
\end{verbatim}
}

Для использования триггера объявите функцию
\function{build-library-hook}:

{\footnotesize
\begin{verbatim}
$(foo_lib): build-library-hook = $(RANLIB) $1
$(foo_lib): $(foo_objects)
    $(call build-library,$^)
$(bar_lib): build-library-hook = $(CHMOD) 444 $1
$(bar_lib): $(bar_objects)
    $(call build-library,$^)
\end{verbatim}
}

%---------------------------------------------------------------------
% Passing paramenters
%---------------------------------------------------------------------
\subsection{Передача аргументов}

Функция может получать информацию из четырёх <<источников>>:
параметры, переданные с вызовом \function{call}, глобальные
переменные, автоматические переменные и переменные, зависящие от цели.
Наиболее отвечающим принципу модульности способом передачи информации
являются формальные параметры, поскольку они предохраняют функцию от
изменений глобальных данных, однако иногда модульность~--- не самый
важный критерий.

Предположим, у вас есть несколько проектов, использующих общий набор
функций \GNUmake{}. Каждый проект может идентифицироваться префиксом
переменных, допустим, \variable{PROJECT1\_}, и имена всех критические
важных переменных составляются из этого префикс и общих для всех
проектов суффиксов. В предыдущих примерах вместо переменных наподобие
\variable{PROJECT\_SRC} могли бы использоваться переменные
\variable{PROJECT1\_SRC}, \variable{PROJECT1\_BIN} и
\variable{PROJECT1\_LIB}. Вместо написания функции, которая требует
наличия всех этих переменных мы могли бы использовать переменные с
вычисляемым именем и передавать дополнительный аргумент~--- префикс:

{\footnotesize
\begin{verbatim}
# $(call process-xml,project-prefix,file-name)
define process-xml
  $($1_LIB)/xmlto -o $($1_BIN)/xml/$2 $($1_SRC)/xml/$2
endef
\end{verbatim}
}

\index{Переменные!зависящие от цели}
Другим подходом передачи аргументов является использование переменных,
зависящих от цели. Это особенно удобно, когда б\'{о}льшая часть
вызовов использует стандартные значения, и лишь в некоторых случаях
требуется уделить этому особое внимание. Переменные, зависящие от
цели, предоставляют также гибкость в том случае, когда правило
определено в подключаемом файле, а выполнение правила осуществляется в
\Makefile{}'е, в котором определены переменные.

{\footnotesize
\begin{verbatim}
release: MAKING_RELEASE = 1
release: libraries executables
...
$(foo_lib):
$(call build-library,$^)
...
# $(call build-library, file-list)
define build-library
  $(AR) $(ARFLAGS) $@           \
    $(if $(MAKING_RELEASE),     \
      $(filter-out debug/%,$1), \
	  $1)
endef
\end{verbatim}
}

Предыдущий код использует переменные, зависящие от цели, чтобы
сообщить вызываемым функциям, что должна быть выполнена чистовая
сборка библиотеки.  В этом случае функция сборки не будет включать в
библиотеку отладочные модули.
