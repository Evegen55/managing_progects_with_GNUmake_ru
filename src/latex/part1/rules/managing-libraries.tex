%%--------------------------------------------------------------------
%% Managing libraries
%%--------------------------------------------------------------------
\section{Управление библиотеками}
\label{sec:managing_libs}

\index{Библиотечный архив} \index{archive!library}
\index{Элемент архива} \index{archive!member}
\newword{Библиотечный архив} (\newword{archive library}), обычно
называемый просто библиотекой или архивом,~--- это специальный файл,
содержащий в себе другие файлы, именуемые \newword{элементами архива}
(\newword{archive members}). Например, стандартная библиотека языка
\Clang{} \filename{libc.a} содержит низкоуровневые функции. Библиотеки
используются настолько часто, что \GNUmake{} имеет специализированную
функциональность для создания, поддержки и компоновки архивов. Архивы
\index{Программы!ar@\utility{ar}}
создаются и модифицируются при помощи программы \utility{ar}.

Давайте вернёмся к нашему примеру. Мы можем модифицировать нашу
программу подсчёта слов, упаковав все её компоненты, пригодные для
повторного использования, в библиотеку.  Наша библиотека будет
состоять из двух файлов: \filename{counter.o} и \filename{lexer.o}.
Для создания библиотеки вызовем команду \filename{ar}:

{\footnotesize
\begin{alltt}
\$ \textbf{ar rv libcounter.a counter.o lexer.o}
a - counter.o
a - lexer.
\end{alltt}
}

Опции \command{rv} означают, что мы хотим заменить элементы библиотеки
указанными объектными файлами, и что \utility{ar} должен выводить отчёт
о своих действиях. Мы можем использовать действие замены даже в том
случае, если указанная библиотека не существует. Первым аргументом
после опций является имя библиотеки, за ним следуют имена объектных
файлов (некоторые версии \filename{ar} требуют опции \utility{c} в
случае, если библиотека ещё не существует, но GNU \utility{ar} не
требует этого). Две строки, следующие за вызовом команды \utility{ar},
являются отчётом о том, что объектные файлы были добавлены в
библиотеку.

Использование опции замены позволяет создавать и изменять архив
последовательно:

{\footnotesize
\begin{alltt}
\$ \textbf{ar rv libcounter.a counter.o}
r - counter.o
\$ \textbf{ar rv libcounter.a lexer.o}
r - lexer.o
\end{alltt}
}

Теперь \utility{ar} предваряет имена файлов символом "r". Это значит,
что файлы в архиве были заменены.

Библиотека может быть скомпонована в исполняемый файл несколькими
способами. Самый простой способ~--- просто указать имя библиотеки в
списке аргументов компилятора.  В свою очередь, компилятор или
компоновщик будут использовать расширение для определения типа каждого
из указанных в командной строке файлов:

{\footnotesize
\begin{verbatim}
cc count_words.o libcounter.a /lib/libfl.a -o count_words
\end{verbatim}
}

Компилятор \utility{cc} распознает два файла \filename{libcounter.a} и
\filename{/lib/libfl.a} как библиотеки и будет искать в них
недостающие символы.  Ещё одним способом ссылки на библиотеку является
опция \command{-l}:

{\footnotesize
\begin{verbatim}
cc count_words.o -lcounter -lfl -o count_words
\end{verbatim}
}

Как вы можете видеть, при использовании этой опции опускается префикс
и суффикс имени библиотеки. Опция \command{-l} делает командную строку
более компактной и удобочитаемой, однако, при использовании этой опции
вы получаете гораздо более весомое преимущество. Когда компилятор
\utility{cc} видит опцию \command{-l}, он \emph{ищет} библиотеку в
стандартных каталогах системных библиотек. Это избавляет программиста
от необходимости знать точный путь к файлу библиотеки и делает команду
компоновки более переносимой. К тому же, в системах, поддерживающих
разделяемые библиотеки (библиотеки с расширением \filename{.so} на
системах семейства \UNIX{}), компоновщик будет искать сначала
разделяемые библиотеки, и только если подходящей не обнаружено, будет
осуществлён поиск библиотечного архива. Такой подход позволяет
программам пользоваться преимуществами разделяемых библиотек без их
явной спецификации. Таково стандартное поведение компилятора и
компоновщика GNU. Старые компоновщики и компиляторы могут не
осуществлять такой оптимизации.

Список каталогов, в которых компилятор должен осуществлять поиск
библиотек, может быть изменён с помощью опции \command{-L},
указывающей список и порядок каталогов, в которых нужно искать
библиотеки. Эти каталоги будут добавлены в список прямо перед
системными каталогами библиотеки и будут использоваться для всех опций
\command{-l} в командной строке. На самом деле, компиляции в
предыдущем примере не завершится успехом, поскольку текущий каталог не
входит в список каталогов библиотек \filename{cc}. Мы можем решить эту
проблему добавлением текущего каталога в список как показано ниже:

{\footnotesize
\begin{verbatim}
cc count_words.o -L. -lcounter -lfl -o count_words
\end{verbatim}
}

Библиотеки вносят некоторые трудности в процесс сборки программ. Какие
возможности предоставляет \GNUmake{} для упрощения этого процесса? GNU
\GNUmake{} включает функциональность как по созданию библиотек, так и
использованию библиотек при компоновке. Давайте посмотрим, как это
работает.

%---------------------------------------------------------------------
% Creating and updating libraries
%---------------------------------------------------------------------
\subsection{Создаём и изменяем библиотеки}

Библиотеки фигурируют в \Makefile{}'е в качестве обычных файлов. Ниже
представлено простое правило для создания нашей библиотеки:

{\footnotesize
\begin{verbatim}
libcounter.a: counter.o lexer.o
    $(AR) $(ARFLAGS) $@ $^
\end{verbatim}
}

Это правило использует встроенные переменные \variable{AR} и
\variable{ARFLAGS}, содержащие имя программы \utility{ar} и
стандартные опции \command{rv} соответственно. Для спецификации файла
архива используется автоматическая переменная \variable{\$@}, а для
спецификации реквизитов~--- автоматическая переменная \variable{\$\^}.

Теперь, если вы укажите файл \filename{libcounter.a} в качестве
реквизита цели \target{count\_words}, \GNUmake{} обновит нашу
библиотеку перед компоновкой исполняемого файла. Обратите внимание на
одну деталь. \emph{Все} элементы архива будут замещены, даже если
среди них есть не изменявшиеся с момента последнего обновления архива
элементы. Чтобы не терять время впустую, мы можем написать более
подходящее правило:

{\footnotesize
\begin{verbatim}
libcounter.a: counter.o lexer.o
    $(AR) $(ARFLAGS) $@ $?
\end{verbatim}
}

Если вы используете \variable{\$?} вместо \variable{\$\^},
\GNUmake{} будет подставлять в список аргументов только те объектные
файлы, которые имеют более позднюю дату модификации, чем цель.

Можем ли мы ещё улучшить это правило? Может быть да, а может и нет.
\GNUmake{} имеет встроенную поддержку обновления отдельных файлов в
архиве, но прежде, чем мы вдадимся в эти детали, стоит сделать
несколько важных замечаний относительно такого подхода к работе с
библиотеками. Одна из основных задач \GNUmake{} состоит в том, чтобы
эффективно использовать время процессора и собирать только те файлы,
которые действительно в этом нуждаются. К сожалению, вызов
\utility{ar} для каждого элемента архива по отдельности при наличии
несколько десятков файлов занимает настолько много времени, что
перевешивает преимущество элегантного синтаксиса, рассмотренного
далее. Используя простой метод, представленный выше, мы можем вызвать
\utility{ar} один раз для всех изменившихся файлов и избежать
множества ненужных системных вызовов \filename{fork/exec}. Кроме того,
на многих системах использование ключа \command{r} при вызове
\utility{ar} очень неэффективно. На моём компьютере 1.9 GHz Pentium 4
создание большого архива, содержащего 14216 элементов общим размером
55 MB, занимает 4 минуты 24 секунды, в то время как замена одного
элемента в этом архиве требует 28 секунд. Таким образом, создание
архива заново будет более быстрой альтернативой замене элементов при
наличии более 10 (из 14216!) изменившихся файлов. В такой ситуации
более разумным подходом будет единовременное обновление архива с
использованием автоматической переменной \variable{\$?}. Для небольших
библиотек и более быстрых компьютеров нет причин отказываться от
элегантного подхода, описанного ниже, в пользу более простого, но и
более быстрого.

В GNU \GNUmake{} элемент архива может быть специфицирован при помощи
следующей нотации:

{\footnotesize
\begin{verbatim}
libgraphics.a(bitblt.o): bitblt.o
    $(AR) $(ARFLAGS) $@ $<
\end{verbatim}
}

Здесь \filename{libgraphics.a}~--- это имя библиотеки, а
\filename{bitblt.o} (сокращение от \newword{bit block transfer,
передача битовых блоков})~--- имя её элемента. Синтаксис
\filename{libgraphics.a(bitblt.o)} означает модуль, содержащийся в
библиотеке. Реквизитом для цели является сам объектный файл, а
командой~--- добавление этого файла в архив. Автоматическая переменная
\variable{\$<} используется для получения первого реквизита. На самом
деле существует встроенное шаблонное правило, предоставляющее в
точности ту же функциональность.

Когда мы соединим всё это воедино, наш \Makefile{} будет выглядеть
следующим образом:

{\footnotesize
\begin{verbatim}
VPATH    = src include
CPPFLAGS = -I include

count_words: libcounter.a /lib/libfl.a

libcounter.a: libcounter.a(lexer.o) libcounter.a(counter.o)

libcounter.a(lexer.o): lexer.o
    $(AR) $(ARFLAGS) $@ $<

libcounter.a(counter.o): counter.o
    $(AR) $(ARFLAGS) $@ $<

count_words.o: counter.h

counter.o: counter.h lexer.h

lexer.o: lexer.h
\end{verbatim}
}

При запуске \GNUmake{} выводит следующее:

{\footnotesize
\begin{alltt}
\$ \textbf{make}
gcc -I include -c -o count\_words.o src/count\_words.c
flex -t src/lexer.l > lexer.c
gcc -I include -c -o lexer.o lexer.c
ar rv libcounter.a lexer.o
ar: creating libcounter.a
a - lexer.o
gcc -I include -c -o counter.o src/counter.c
ar rv libcounter.a counter.o
a - counter.o
gcc count\_words.o libcounter.a /lib/libfl.a -o count\_words
rm lexer.c
\end{alltt}
}

Обратите внимание на правило обновления архива. Автоматическая
переменная \variable{\$@} приняла значение имени библиотеки, несмотря
на то, что имя цели в \Makefile{}'е было
\filename{libcounter.a(lexer.o)}.

Наконец, нужно отметить, что библиотечный архив включает индекс всех
символов, содержащихся в нём. Новые программы архиваторов, такие как
GNU \utility{ar}, обновляют этот индекс автоматически при добавлении в
архив нового символа. Более старые версии архиваторов могут этого не
делать. Для создания и обновления индекса архива используется
\index{Программы!runlib}
программа \utility{ranlib}. В системах со старой версией архиватора
должно использоваться правило следующего вида:

{\footnotesize
\begin{verbatim}
libcounter.a: libcounter.a(lexer.o) libcounter.a(counter.o)
    $(RANLIB) $@
\end{verbatim}
}

Вы также можете использовать альтернативный подход для больших
архивов:

{\footnotesize
\begin{verbatim}
libcounter.a: counter.o lexer.o
    $(RM) $@
    $(AR) $(ARFLGS) $@ $^
    $(RANLIB) $@
\end{verbatim}
}

Конечно, синтаксис управления элементами архива может использоваться с
применением встроенных правил. GNU \GNUmake{} содержит встроенные
правила обновления архивов. Если мы используем эти правила, наш
\Makefile{} будет выглядеть следующим образом:

{\footnotesize
\begin{verbatim}
VPATH    = src include
CPPFLAGS = -I include

count_words: libcounter.a -lfl

libcounter.a: libcounter.a(lexer.o) libcounter.a(counter.o)

count_words.o: counter.h

counter.o: counter.h lexer.h

lexer.o: lexer.h
\end{verbatim}
}

%---------------------------------------------------------------------
% Using libraries as prerequisites
%---------------------------------------------------------------------
\subsection{Использование библиотек в качестве реквизитов}

Когда библиотеки появляются в качестве реквизитов, они могут быть
обозначены с помощью расширения файла или опции \command{-l}. Если
указать имя файла библиотеки:

{\footnotesize
\begin{verbatim}
xpong: $(OBJECTS) /lib/X11/libX11.a /lib/X11/libXaw.a
    $(LINK) $^ -o $@
\end{verbatim}
}

{\noindent то компоновщик просто прочитает библиотечные файлы из
командой строки.  При использовании опции \command{-l} реквизиты вовсе
не выглядят обычными файлами:}

{\footnotesize
\begin{verbatim}
xpong: $(OBJECTS) -lX11 -lXaw
    $(LINK) $^ -o $@
\end{verbatim}
}

Когда в реквизитах используется форма \command{-l}, \GNUmake{}
производит поиск библиотеки (предпочитая разделяемую версию) и
подставляет абсолютный путь в переменные \variable{\$\^} и
\variable{\$?}. Одно из преимуществ такого подхода состоит в
возможности производить автоматический поиск библиотек даже в том
случае, если компоновщик в вашей системе не поддерживает такой
возможности. Другим преимуществом является возможность настройки
путей поиска \GNUmake{}, что позволяет вам производить поиск
собственных библиотек наравне с системными. В приведённом примере
первая форма (с использованием абсолютных путей) будет игнорировать
разделяемые библиотеки. При использовании же второй формы \GNUmake{}
будет знать, что разделяемые библиотеки более предпочтительны, поэтому
сначала произведёт поиск разделяемой версии \filename{X11}, и только в
случае неудачи будет выбрана статическая библиотека. Шаблоны
для распознавания имён библиотек хранятся в виде реквизитов специальной
\index{Цели!специальные!LIBPATTERNS@\target{.LIBPATTERNS}}
цели \target{.LIBPATTERNS} и могут быть настроены для различных
форматов имён библиотек.

К сожалению, есть одна неприятная мелочь. Если в какая-либо цель в
\Makefile{}'е специфицирует библиотеку, на неё нельзя ссылаться в
реквизитах с помощью опции \command{-l}.  Например, запуск \GNUmake{}
с таким \Makefile{}'ом:

{\footnotesize
\begin{verbatim}
count_words: count_words.o -lcounter -lfl
    $(CC) $^ -o $@ libcounter.a: libcounter.a(lexer.o)

libcounter.a(counter.o)
\end{verbatim}
}

{\noindent завершится неудачей со следующей ошибкой:}

{\footnotesize
\begin{verbatim}
No rule to make target `-lcounter', needed by `count_words'
\end{verbatim}
}

Причиной ошибки является то, что \GNUmake{} не совершил подстановку
\filename{libcounter.a} вместо \filename{-lcounter} и поиск подходящей
цели. Вместо этого был осуществлён обычный поиск библиотеки. Таким
образом, для библиотек, собранных в \GNUmake{}, должно указывается
непосредственно имя файла.

Компоновка больших программ без возникновения ошибок подобна искусству
чёрной магии. Компоновщик производит поиск библиотек в том порядке, в
каком они указаны в командной строке. Таким образом, если библиотека
\filename{A} содержит неопределённый символ, например, \textit{open},
определённый в библиотеке \filename{B}, то \filename{A} должна быть
указана в командной строке \emph{перед} \filename{B} (именно так,
\filename{A} требует \filename{B}). Иначе, когда компоновщик прочитает
\filename{A} и не найдёт определения символа \filename{open}, будет
слишком поздно возвращаться назад к \filename{B}. Компоновщик никогда не
осуществляет поиск в уже просмотренных библиотеках. Таким образом,
порядок появления библиотек в командной строке играет фундаментальное
значение.

Когда реквизиты цели сохраняются в переменных \variable{\$\^} и
\variable{\$?}, порядок их следования также сохраняется. Это
справедливо даже для реквизитов, размещённых в нескольких правилах. В
этом случае реквизиты каждого правила добавляются к списку реквизитов
в том порядке, в котором они появляются.

Родственной проблемой является проблема перекрёстных ссылок между
\index{Циклические ссылки}
библиотеками,также известных как \newword{циклические ссылки}
\index{Зацикливания}
(\newword{circular references}) или \newword{зацикливания}
(\newword{circularities}). Предположим, что после некоторой
модификации библиотека \filename{B} использует символ из \filename{A}.
Мы уже знаем, что \filename{A} должна быть указана до \filename{B}, но
теперь ещё и \filename{B} должно быть указана до \filename{A}.
Решением является ссылка на \filename{A} и до, и после ссылки на
\filename{B}: \command{-lA -lB -lA}. В больших и сложных программах
библиотеки часто должны повторяться подобным образом, иногда более
одного раза.

Такая ситуация ставит небольшую проблему при использовании \GNUmake{},
поскольку автоматические переменные, как правило, не содержат
дубликатов. Например, предположим, что нам нужно повторить библиотеку
в реквизитах для устранения циклических ссылок:

{\footnotesize
\begin{verbatim}
xpong: xpong.o libui.a libdynamics.a libui.a -lX11
    $(CC) $^ -o $@
\end{verbatim}
}

Этот список реквизитов после подстановки переменных будет выглядеть
следующим образом:

{\footnotesize
\begin{verbatim}
gcc xpong.o libui.a libdynamics.a /usr/lib/X11R6/libX11.a -o xpong
\end{verbatim}
}

Для подавления последствий такого поведения переменной \variable{\$\^}
в \GNUmake{} была добавлена переменная \variable{\$+}. Эта переменная
идентична \variable{\$\^} с той лишь разницей, что в списке реквизитов
сохраняются дубликаты. Используем \variable{\$+}:

{\footnotesize
\begin{verbatim}
xpong: xpong.o libui.a libdynamics.a libui.a -lX11
    $(CC) $+ -o $@
\end{verbatim}
}

Теперь список реквизитов породит следующую команду компоновки:

\begin{verbatim}
gcc xpong.o libui.a libdynamics.a libui.a \
/usr/lib/X11R6/libX11.a -o xpong
\end{verbatim}

%---------------------------------------------------------------------
% Double-colon rules
%---------------------------------------------------------------------
\subsection{Правила с двойным двоеточием}

\index{Правила!с двойным двоеточием}
Правила с двойным двоеточием~--- это реализация функциональности,
позволяющей собирать одну и ту же цель с помощью разных сценариев, в
зависимости от того, какое из подмножеств реквизитов было
модифицировано. Обычно если цель появляется более одного раза, все её
реквизиты соединяются в один список, сценарий сборки же для одной цели
может быть указан только один раз. При использовании же правил с
двойным двоеточием каждое появление цели рассматривается как отдельное
правило и обрабатывается индивидуально. Это значит, что для какой-то
определённой цели все правила должны быть одного типа: либо с одним
двоеточием, либо с двумя.

По-настоящему полезные применения этой возможности придумать довольно
сложно, поэтому давайте рассмотрим следующий искусственный пример:

{\footnotesize
\begin{verbatim}
file-list:: generate-list-script
    chmod +x $<
    generate-list-script $(files) > file-list

file-list:: $(files)
    generate-list-script $(files) > file-list
\end{verbatim}
}

Мы можем создать цель \target{file-list} двумя способами. Если
сценарий составления списка файлов изменился, то добавим файлу
сценария права на запуск и выполним его. Если изменились исходные
файлы, мы просто запускаем сценарий.  Несмотря на свою надуманность,
пример наглядно демонстрирует, как можно использовать эту
функциональность.

Мы рассмотрели большую часть функциональности \GNUmake{}, связанной с
правилами, которые, наряду с переменными и сценариями, составляют
самую сущность \GNUmake{}. Мы фокусировали внимание главным образом на
специфику синтаксиса и поведение различных возможностей, практически
не останавливаясь на способах их применения в более сложных ситуациях.
Это будет главным объектом нашего внимания во второй части книги. А
сейчас продолжим обсуждение переменных и команд.
