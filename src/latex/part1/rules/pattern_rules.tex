%%--------------------------------------------------------------------
%% Pattern rules
%%--------------------------------------------------------------------
\section{Шаблонные правила}
\label{sec:pattern_rules}

\index{Правила!шаблонные}
Все примеры \Makefile{}'ов, рассмотренные нами, были слишком подробны.
Для маленькой программы, содержащей десяток файлов это не имеет
большого значения, но явная спецификация всех целей, реквизитов и
сценариев сборки для программы, содержащей сотни и тысячи файлов, не
представляется возможным. Более того, команды сами по себе вносят
дублирующийся код в наш \Makefile{}. Это может быть источником ошибок
и большой проблемой при поддержке.

Многие программы, читающие один тип файлов и выводящие другой следуют
стандартным соглашениям. Например, все компиляторы языка \Clang{}
предполагают, что файлы с расширением \filename{.c} содержат исходный
код на языке \Clang{}, а имена объектных файлов могут быть получены
заменой расширения \filename{.c} на расширение \filename{.o} (или
\filename{.obj} для некоторых компиляторов в Windows). В предыдущей
главе мы увидели, что исходные файлы генератора \utility{flex} имеют
расширение \filename{.l}, а расширением генерируемых им файлов
является \filename{.c}.

Эти и другие соглашения позволяют \GNUmake{} упростить создание правил
с помощью распознавания шаблонов и предоставления встроенных правил
сборки. Например, используя встроенные правила, мы можем сократить наш
\Makefile{} с семнадцати строк до шести:

{\footnotesize
\begin{verbatim}
VPATH = src include
CPPFLAGS = -I include

count_words: counter.o lexer.o -lfl
count_words.o: counter.h
counter.o: counter.h lexer.h
lexer.o: lexer.h
\end{verbatim}
}

\index{Правила!встроенные}
Все встроенные правила являются шаблонными. Шаблонные правила похожи
\index{Основа файла}
на обычные за тем исключением, что \newword{основа} имени файла
(часть, не содержащая расширение) представлена символом \command{\%}.
Наш \Makefile{} выполняет свою работу благодаря трём встроенным
правилам. Первое указывает, как произвести компиляцию файла с
расширением \filename{.o} из файла с расширением \filename{.c}:

{\footnotesize
\begin{verbatim}
%.o: %.c
    $(COMPILE.c) $(OUTPUT_OPTION) $<
\end{verbatim}
}

Второе правило указывает, как получить файлы с расширением
\filename{.c} из файлов с расширением \filename{.l}:

{\footnotesize
\begin{verbatim}
%.c: %.l
    @$(RM) $@
    $(LEX.l) $< > $@
\end{verbatim}
}

Наконец, существует специальное правило получения файла без расширения
(он всегда считается исполняемым) из файлов с расширением
\filename{.o}:

{\footnotesize
\begin{verbatim}
%: %.o
    $(LINK.o) $^ $(LOADLIBES) $(LDLIBS) -o $@
\end{verbatim}
}

Прежде, чем углубиться в детали синтаксиса, давайте внимательно
рассмотрим вывод \GNUmake{} и разберёмся, как он применяет встроенные
правила.

Если запустить \GNUmake{} с нашим исправленным \Makefile{}'ом, вывод
будет следующим:

{\footnotesize
\begin{alltt}
\$ \textbf{make}
gcc  -I include  -c -o count\_words.o src/count\_words.c
gcc  -I include  -c -o counter.o src/counter.c
flex  -t src/lexer.l > lexer.c
gcc  -I include  -c -o lexer.o lexer.c
gcc   count\_words.o counter.o lexer.o /lib/libfl.a -o count\_words
rm lexer.c
\end{alltt}
}

Сначала \GNUmake{} читает \Makefile{} и выставляет целью по умолчанию
файл \filename{count\_words}, поскольку аргументы командной строки не
заданы. Рассматривая цель по умолчанию, \GNUmake{} определяет
её реквизиты: \filename{count\_words.o} (этот реквизит не указан в
\Makefile{}, он следует из неявного правила), \filename{counter.o},
\filename{lexer.o} и \filename{-lfl}. Далее \GNUmake{} пытается
собрать каждый из этих реквизитов.

Когда \GNUmake{} рассматривает первый реквизит,
\filename{count\_words.o}, он не находит явного правила, однако
обнаруживает неявное. Не найдя исходного файла в текущем каталоге,
\index{Переменные!встроенные!VPATH@\variable{VPATH}}
он просматривает директории, указанные в \variable{VPATH}, и
обнаруживает исходный файл в каталоге \filename{src}. Поскольку файл
\filename{src/count\_words.c} не имеет реквизитов, \GNUmake{}
запускает сценарий компиляции \filename{count\_words.o},
ассоциированный с неявным правилом.  Таким же образом получается файл
\filename{counter.o}. Когда \GNUmake{} рассматривает
\filename{lexer.o}, соответствующий исходный файл не обнаруживается,
поэтому \GNUmake{} предполагает, что \filename{lexer.c} является
промежуточным файлом, и ищет подходящее правило для его получения.
Обнаружив правило создания файла с расширением \filename{.c} из файла
с расширением \filename{.l}, \GNUmake{} замечает, что файл
\filename{lexer.l} существует. Поскольку \filename{lexer.l} не имеет
реквизитов, вызывается сценарий генерации файла \filename{lexer.c},
содержащий вызов команды \utility{flex}. Затем происходит компиляция с
получением объектного файла. Использование последовательностей правил
\index{Цепочка правил}
для сборки цели, подобных предыдущим, называется \newword{цепочкой
правил}.

Далее, \GNUmake{} исследует спецификацию библиотеки \filename{-lfl}.
Осуществляется поиск в каталогах из списка стандартных каталогов
библиотек, результатом которого является файл \filename{/lib/libfl.a}.

Теперь \GNUmake{} имеет все реквизиты для получения
\filename{count\_words}, запускается команда компоновки \utility{gcc}.
Наконец, \GNUmake{} вспоминает, что был создан промежуточный файл,
который больше не нужно хранить, и осуществляет удаление этого файла.

Как мы убедились, использование правил в \Makefile{}'ах позволяет
избежать спецификации многих деталей. Правила могут иметь сложные
отношения, которые порождают чрезвычайно широкие возможности. В
частности, наличие встроенной базы данных общих правил значительно
упрощает спецификацию многих \Makefile{}'ов.

Встроенные правила могут быть настроены путём изменения значений
переменных, фигурирующих в сценариях сборки. Типичные сценарии имеют
множество переменных, начиная с имени команды, подлежащей выполнению,
и заканчивая большими группами опций командной строки, такими, как имя
выходного файла, флаги оптимизации, включение символьной информации и
т.д. Вы можете увидеть стандартную базу данных \GNUmake{} с помощью
команды \command{make --print\hyp{}data\hyp{}base}.

%---------------------------------------------------------------------
% The patterns
%---------------------------------------------------------------------
\subsection{Шаблоны}
\index{Шаблоны}
Символ процента в шаблонном правиле практически эквивалентен
специальному символу \command{*} командного интерпретатора \UNIX{}. Он
соответствует произвольному числу символов. Знак процента может
появиться в любом месте шаблона ровно один раз. Вот примеры
допустимого использования этого символа.

{\footnotesize
\begin{verbatim}
%,v
s%.o
wrapper_%
\end{verbatim}
}

Символы, входящие в шаблон и отличные от процента, соответствуют самим
себе.  Шаблон может содержать префикс, суффикс или и то, и другое.
Когда \GNUmake{} ищет соответствие шаблонному правилу, сначала
проверяется соответствие шаблону цели. Шаблон цели должен начинаться с
префикса и заканчиваться суффиксом (если они есть). Если соответствие
найдено, символы между префиксом и суффиксом становятся основой имени
файла. Затем \GNUmake{} производит поиск реквизитов шаблонного
правила, подставляя основу имени файла в шаблон реквизита. Если
результирующий файл существует или может быть получен с помощью
другого правила, соответствие считается установленным и правило
применяется. Основа файла должна содержать хотя бы один символ.

Допускается также иметь шаблоны с одним только символом процента.
Наиболее частое использование этого шаблона~--- сборка исполняемых
файлов \UNIX{}. Например, вот несколько встроенных шаблонных правил,
использующихся \GNUmake{} для сборки программ:

{\footnotesize
\begin{verbatim}
%: %.mod
    $(COMPILE.mod) -o $@ -e $@ $^

%: %.cpp

    $(LINK.cpp) $^ $(LOADLIBES) $(LDLIBS) -o $@

%: %.sh
    cat $< >$@
    chmod a+x $@
\end{verbatim}
}

Эти правила будут использованы для сборки программы из исходных файлов
Modula, исходных файлов \Clang{}, обработанных препроцессором, или
командных сценариев интерпретатора Bourne shell соответственно. Мы
рассмотрим другие неявные правила в разделе
<<\nameref{sec:implicit_rule_db}>>.

%---------------------------------------------------------------------
% Static pattern rules
%---------------------------------------------------------------------
\subsection{Статические шаблонные правила}
Статические шаблонные правила применяются только к определённому
списку целей.

{\footnotesize
\begin{verbatim}
$(OBJECTS): %.o: %c
        $(CC) -c $(CFLAGS) $< -o $@
\end{verbatim}
}

Единственная разница между этим правилом и обычным шаблонным
правилом~--- наличие спецификации \command{\$(OBJECTS):}. Эта
спецификация ограничивает область действия правила файлами,
перечисленными в переменной \variable{\$(OBJECTS)}. Каждый объектный
файл из этой переменной проверяется на соответствие шаблону
\command{\%.c}, извлекается основа его имени, которая затем
подставляется в шаблон \command{\%.c}, порождая имя реквизита цели.
Если файл из списка не соответствует шаблону цели, \GNUmake{} выдаст
предупреждение.

Используйте статические шаблонные правила везде, где легче перечислить
файлы целей явно, нежели определять их по расширению или шаблону.

%---------------------------------------------------------------------
% Suffix rules
%---------------------------------------------------------------------
\subsection{Суффиксные правила} \label{sec:suffix_rules}
\index{Правила!суффиксные}
Суффиксные правила~--- это первоначальный (и ныне устаревший) способ
определения неявных правил. Поскольку другие версии \GNUmake{} могут
не поддерживать синтаксис шаблонов GNU \GNUmake{}, вы ещё можете
встретить такие правила в \Makefile{}'ах дистрибутивов,
предназначенных для широкого распространения, поэтому важно
уметь читать и понимать их синтаксис. Итак, несмотря на то, что
компиляция GNU \GNUmake{} для целевой платформы является
предпочтительным методом переноса \Makefile{}'ов, при некоторых
обстоятельствах вам, возможно, придётся писать суффиксные правила.

Суффиксные правила выглядят как два написанных слитно суффикса,
выступающие в роли правила:

{\footnotesize
\begin{verbatim}
.c.o:
    $(COMPILE.c) $(OUTPUT_OPTION) $<
\end{verbatim}
}

Тот факт, что первым указывается суффикс реквизита, а вторым~---
суффикс цели, может внести некоторую путаницу. Предыдущему правилу
соответствуют в точности те же цели и реквизиты, что и следующему:

{\footnotesize
\begin{verbatim}
%.o: %.c
    $(COMPILE.c) $(OUTPUT_OPTION) $<
\end{verbatim}
}

Суффиксные правила формируют основу имени файла путём удаления
суффикса; имя файла реквизита получается в результате замены суффикса
цели суффиксом реквизита. Суффиксное правило распознаётся \GNUmake{}
только в том случае, если оба суффикса находятся в списке известных
суффиксов.

Предыдущее суффиксное правило называется также двусуффиксным,
поскольку оно содержит два суффикса. Существуют также односуффиксные
правила. Такие правила содержат только один суффикс~--- суффикс
реквизита. Эти правила используются для сборки исполняемых файлов
\UNIX{}, не имеющих расширения:

{\footnotesize
\begin{verbatim}
.p:
    $(LINK.p) $^ $(LOADLIBES) $(LDLIBS) -o $@
\end{verbatim}
}

Предыдущее правило описывает создание исполняемого файла из исходного
файла Pascal. Оно полностью эквивалентно следующему правилу:

{\footnotesize
\begin{verbatim}
%: %.p
    $(LINK.p) $^ $(LOADLIBES) $(LDLIBS) -o $@
\end{verbatim}
}

Список известных суффиксов является наиболее необычной частью
синтаксиса. Для определения этого списка используется специальная
цель \target{.SUFFIXES}. Вот первая часть стандартного определения
\target{.SUFFIXES}:

{\footnotesize
\begin{verbatim}
.SUFFIXES: .out .a .ln .o .c .cc .C .cpp .p .f .F .r .y .l
\end{verbatim}
}

Вы можете добавить собственные суффиксы, добавив правило
\target{.SUFFIXES} в ваш \Makefile{}:

{\footnotesize
\begin{verbatim}
.SUFFIXES: .pdf .fo .html .xml
\end{verbatim}
}

Если вы хотите удалить все известные суффиксы (например, они
перекрываются с вашими специальными суффиксами), определите цель
\target{.SUFFIXES} как не имеющую реквизитов:

{\footnotesize
\begin{verbatim}
.SUFFIXES:
\end{verbatim}
}

Вы также можете использовать опцию командной строки
\index{Опции!no-builtin-rules@\command{-{}-no\hyp{}builtin\hyp{}rules (-r)}}
\command{-{}-no\hyp{}builtin\hyp{}rules} (или \command{-r}).

Мы не будем использовать суффиксные правила в этой книге, поскольку
шаблонные правила GNU \GNUmake{} более выразительны и \'{о}бщны.
