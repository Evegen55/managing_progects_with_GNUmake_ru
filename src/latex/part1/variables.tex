%%%-------------------------------------------------------------------
%%% Variables and Macros
%%%-------------------------------------------------------------------
\chapter{Переменные и макросы}
\label{chap:vars}

Мы уже видели переменные в \Makefile{}'ах и множество примеров их
использования как во встроенных, так и в определённых пользователем
правилах. Однако те примеры, которые мы видели, являются лишь вершиной
айсберга. Переменные и макросы могут быть гораздо более сложными.
Именно они придают GNU \GNUmake{} часть его невероятной мощи.

Прежде, чем мы продолжим, важно осознать, что \GNUmake{} является
смешением двух языков. Первый язык описывает граф зависимостей,
состоящий из целей и реквизитов (этот язык был подробно рассмотрен в
\index{Макроязык}
главе~\ref{chap:rules}). Второй язык является макроязыком для
осуществления текстовых подстановок. Быть может, вы знакомы и с
другими макроязыками: препроцессор \Clang{}, \utility{m4}, \TeX{} и
макроассемблеры.  Как и эти макроязыки, \GNUmake{} позволяет
определять условные обозначения для длинной последовательности
символов и использовать их в вашей программе. Макропроцессор
распознает их в тексте программы и заменит на соответствующую
последовательность. Несмотря на то, что удобно думать о переменных в
\Makefile{}'е как о переменных в традиционных языках программирования,
есть существенное отличие между макропеременными и <<традиционными>>
переменными. Значения макропеременных подставляются сразу при встрече
их имени в тексте программы, порождая строку, которая затем также
сканируется на наличие макросов. Это отличие станет более ясным, когда
мы рассмотрим переменные \GNUmake{} подробнее.

Имена переменных могут содержать почти любые символы, включая многие
знаки пунктуации. Разрешаются даже пробелы, но, если вы считаете себя
здравомыслящим человеком, избегайте их. Не разрешается использовать в
составе имени переменных следующие символы: \command{:}, \command{\#}
и \command{=}.

Регистр букв в имени переменных имеет значение, то есть переменные
\variable{cc} и \variable{CC} являются различными переменными. Для
получения значения переменной нужно заключить её имя внутрь круглых
скобок, предваряемых символом доллара (\variable{\$( )}). Из этого
правила есть одно исключение: если имя переменной состоит из одного
символа, то круглые скобки можно опустить и писать просто
\index{Переменные!автоматические}
\command{\${}\textit{символ}}. Вот почему автоматически переменные
могут использоваться без круглых скобок. Как правило вам стоит
предпочитать форму со скобками и избегать переменных, имя которых
состоит из одного символа.

Значение переменной также может быть получено с использованием
фигурных скобок, например, \variable{\${}\{CC\}}. Эта форма
встречается довольно часто, в частности, в старых \Makefile{}'ах.
Трудно найти причину, по которой использование одной из этих форм было
бы предпочтительным.  Выберите для себя какую-то одну и
придерживайтесь её. Некоторые люди используют фигурные скобки для
ссылки на переменную, а круглые~--- для вызовов функций, подражая
синтаксису командного интерпретатора Bourne shell. В современных
\Makefile{}'ах используются круглые скобки, вот почему мы будем
придерживаться именно этого стиля в этой книге.

Существуют определённые соглашения относительно имён переменных. Все
буквы имени переменных, представляющих значения, не изменяемые в ходе
работы \GNUmake{} (констант), и которые могут быть указаны
пользователем через интерфейсы командной строки или переменных
окружения, должны быть заглавными. Слова внутри имён таких переменных
обычно разделяются подчёркиваниями. Имена переменных, которые
встречаются только внутри \Makefile{}'а, содержат только прописные
буквы, слова в них также разделяются подчёркиваниями. Наконец, в этой
книге имена всех функций, определяемых пользователем с помощью
переменных или макросов, состоят из прописных букв, слова внутри имён
разделяются знаками тире.  Другие соглашения относительно имён будут
оглашаться тогда, когда в этом будет необходимость. Следующие примеры
используют функциональность, которую мы ещё не обсуждали. Поскольку
они иллюстрируют применение соглашений именования, не старайтесь
вникать в детали:

{\footnotesize
\begin{verbatim}
# Обычные константы.
CC    := gcc
MKDIR := mkdir -p

# Внутренние переменные.
sources = *.c
objects = $(subst .c,.o,$(sources))

# Пара функций.
maybe-make-dir  = $(if $(wildcard $1),,$(MKDIR) $1)
assert-not-null = $(if $1,,$(error Illegal null value.))
\end{verbatim}
}

Значение переменной состоит из всех слов, находящихся справа от знака
присваивания без учёта начального пробела. Пробелы в конце строки
также входят в состав значения. Иногда это может вызывать проблемы,
например, при использовании переменных, чьи значения оканчиваются
пробелами, в сценариях командного интерпретатора:

{\footnotesize
\begin{verbatim}
LIBRARY = libio.a # LIBRARY заканчивается пробелом

missing_file:
    touch $(LIBRARY)
    ls -l | grep '$(LIBRARY)'
\end{verbatim}
}

Присваивание переменной содержит пробел, который становится более
заметным за счёт комментария (однако на самом деле комментария может и
не быть). После запуска \GNUmake{} мы увидим следующий вывод:

{\footnotesize
\begin{alltt}
\$ \textbf{make}

touch libio.a 
ls -l | grep 'libio.a '
make: *** [missing\_file] Error 1
\end{alltt}
}

Поскольку шаблон поиска, переданный программе \utility{grep}, также
содержит пробел, поиск его вхождения в выводе команды \utility{ls}
закончился неудачей. Позднее мы обсудим проблемы, связанные с
пробелами, более детально. А пока давайте рассмотрим поближе
переменные \GNUmake{}.

\input{./src/latex/part1/variables/what-variables-are-used-for.tex}
\input{./src/latex/part1/variables/variable-types.tex}
\input{./src/latex/part1/variables/macros.tex}
\input{./src/latex/part1/variables/when-variables-are-expanded.tex}
\input{./src/latex/part1/variables/target-and-pattern-specific-variables.tex}
\input{./src/latex/part1/variables/where-variables-come-from.tex}
\input{./src/latex/part1/variables/conditional-and-include-processing.tex}
\input{./src/latex/part1/variables/standard-make-variables.tex}
