%%--------------------------------------------------------------------
%% Standard make variables
%%--------------------------------------------------------------------
\section{Стандартные переменные \GNUmake{}}
\label{sec:std_make_vars}

\index{Переменные!стандартные}
Вдобавок к автоматическим переменным, \GNUmake{} содержит переменные,
предназначенные для получения текущего состояния \GNUmake{} и
настройки встроенных правил:

\begin{description}
%---------------------------------------------------------------------
% MAKE_VERSION
%---------------------------------------------------------------------
\item[\variable{MAKE\_VERSION}] \hfill \\
\index{Переменные!стандартные!MAKE\_VERSION@\variable{MAKE\_VERSION}}
Значением этой переменной является номер текущей версии GNU
\GNUmake{}.  Во время написания этой книги этим значением было
\command{3.80}, а CVS хранилище содержало версию \texttt{3.81rc1.}

Предыдущая версия \GNUmake{}, \command{3.79.1}, не поддерживающая
функций \function{eval} и \function{value}, имеет довольно широкое
распространение. Так что когда пишу свои \Makefile{}'ы, требующие
подобной функциональности, я использую эту переменную для проверки
версии \GNUmake{}. Мы увидим примеры такого использования в разделе
<<\nameref{sec:flow_ctrl_func}>> главы~\ref{chap:functions}.

%---------------------------------------------------------------------
% CURDIR
%---------------------------------------------------------------------
\item[\variable{CURDIR}] \hfill \\
\index{Переменные!стандартные!CURDIR@\variable{CURDIR}}
\index{Текущий каталог}
\index{current working directory}
Эта переменная содержит текущий рабочий каталог (current working
directory, cwd) исполняемого процесса \GNUmake{}. Это тот же самый
каталог, в котором была выполнена команда \GNUmake{} (и тот же самый
каталог, что хранится в переменной командного интерпретатора
\variable{PWD}), если только не использовалась опция
\index{Опции!directory@\command{-{}-directory (-C)}}
\command{-{}-di\-rec\-to\-ry} (\command{-C}). Опция
\command{-{}-di\-rec\-to\-ry} сообщает \GNUmake{}, что нужно изменить
текущий каталог перед тем, как начать искать \Makefile{}. Полная форма
опции выглядит следующим образом:
\command{-{}-di\-rec\-to\-ry=\emph{имя\hyp{}каталога}} или
\command{-C \emph{имя\hyp{}каталога}}. Если использовалась опция
\command{-{}-di\-rec\-to\-ry}, то переменная \variable{CURDIR} будет
содержать аргумент этой опции.

Обычно я вызываю \GNUmake{} из редактора \utility{emacs} во время
редактирования кода. Например, мой текущий проект написан на \Java{} и
использует единственный \Makefile{} в корневом каталоге проекта (не
обязательно в каталоге, содержащем исходный код). В моём случае
использование опции \command{-{}-di\-rec\-to\-ry} позволяет мне
запускать \GNUmake{} из любого каталога с исходными файлами и иметь
доступ к \Makefile{}'у. Внутри \Makefile{}'а все пути являются
относительными и вычисляются от каталога, в котором располагается
\Makefile{}. Абсолютные пути используются очень редко, доступ к ним
осуществляется при помощи переменной \variable{CURDIR}.

%---------------------------------------------------------------------
% MAKEFILE_LIST
%---------------------------------------------------------------------
\item[\variable{MAKEFILE\_LIST}] \hfill \\
\index{Переменные!стандартные!MAKEFEILE\_LIST@\variable{MAKEFEILE\_LIST}}
Значение этой переменной содержит список всех файлов, прочитанных
\GNUmake{}, включая стандартный \Makefile{}, все \Makefile{}'ы,
указанные в опциях командной строки, и файлы, подключённые директивой
\directive{include}. Перед чтением каждого файла \GNUmake{} добавляет
его имя к значению переменной \variable{MAKEFILE\_LIST}. Итак,
\Makefile{} всегда может определить собственное имя, прочитав
последнее слово в этом списке.

%---------------------------------------------------------------------
% MAKECMDGOALS
%---------------------------------------------------------------------
\item[\variable{MAKECMDGOALS}] \hfill \\
\index{Переменные!стандартные!MAKECMDGOALS@\variable{MAKECMDGOALS}}
Значение \variable{MAKECMDGOALS} содержит список всех целей, указанных
в командной строке для текущего процесса \GNUmake{}. Оно не включает
опций и определений переменных. Например:

{\footnotesize
\begin{alltt}
\$ \textbf{make -f- FOO=bar -k goal <<< 'goal:;\#{} \$(MAKECMDGOALS)'}
\#{} goal
\end{alltt}
}

Предыдущий пример использует возможность \GNUmake{} читать \Makefile{}
из стандартного потока ввода, включающуюся опцией \command{-f-}
\index{Опции!file@\command{-{}-file (-f-)}} (или
\command{-{}-fi\-le}). Происходит перенаправление стандартного потока
ввода на командную строку с помощью синтаксиса командного
интерпретатора \utility{bash} \verb|<<<|\footnote{ Если вы хотите
выполнить этот пример в другом интерпретаторе, наберите:

\begin{alltt}
\$ echo 'goal:;\#{} \$(MAKECMDGOALS)' | make -f- FOO=bar -k goal
\end{alltt}
}.

Сам \Makefile{} состоит из спецификации цели по умолчанию
\target{goal}. Командный сценарий указан на той же строке и
отделяется от определения цели точкой с запятой. Сценарий состоит из
одной строки:

{\footnotesize
\begin{verbatim}
# $(MAKECMDGOALS)
\end{verbatim}
}

Переменная \variable{MAKECMDGOALS} обычно используется в том случае,
когда цель требует особой обработки. Выразительным примером является
цель \target{clean}. Когда происходит сборка \target{clean},
\GNUmake{} не должен осуществлять стандартную проверку изменения
подключаемых файлов (обсуждавшуюся в разделе
<<\nameref{sec:cond_inc_processing}>> главы~\ref{chap:vars}).  Для
подавления этой проверки можно применить директиву \directive{ifneq} и
переменную \variable{MAKECMDGOALS}:

{\footnotesize
\begin{verbatim}
ifneq "$(MAKECMDGOALS)" "clean"
  -include $(subst .xml,.d,$(xml_src))
endif
\end{verbatim}
}

\item[\variable{.VARIABLES}] \hfill \\
\index{Переменные!стандартные!VARIABLES@\variable{.VARIABLES}}
Значение этой переменной содержит имена всех переменных, определённых
\index{Переменные!зависящие от цели}.
в \Makefile{}'е на данный момент, исключая переменные, зависящие от
цели. Эта переменная доступна только для чтения и любое её
переопределение игнорируется.

{\footnotesize
\begin{verbatim}
list:
    @echo "$(.VARIABLES)" | tr ' ' '\015' | grep MAKEF
\end{verbatim}
}

{\footnotesize
\begin{alltt}
\$ \textbf{make}
MAKEFLAGS
MAKEFILE\_LIST
MAKEFILES
\end{alltt}
}
\end{description}

Как вы уже видели, переменные также используются для настройки
встроенных неявных правил \GNUmake{}. Правила для компиляции и
компоновки исходных файлов \Clang{}/\Cplusplus{} демонстрируют
типичную форму, принимаемую переменными для произвольных языков
программирования.  Рисунок~\ref{fig:vars_for_c_comp} изображает
переменные, контролирующие трансформацию одного типа файлов в другой.

\begin{figure}[!ht]
\centering
\input{./src/latex/figures/vars_for_c_comp.tex}
\caption{Переменные для компиляции исходных файлов
\Clang{}/\Cplusplus{}.} \label{fig:vars_for_c_comp}
\end{figure}

Все эти переменные имеют одинаковую форму:
\ItalicMono{ДЕЙСТВИЕ.суффикс}. \ItalicMono{ДЕЙСТВИЕ} может быть
\variable{COMPILE} для создания объектного файла, \variable{LINK} для
создания исполняемого файла, или одной из <<специальных>> операций
\variable{PREPROCESS}, \variable{YACC} или \variable{LEX} (для запуска
препроцессора языка \Clang{}, \utility{yacc} и \utility{lex}
соответственно). Тип обрабатываемых файлов указывается с помощью части
\ItalicMono{суффикс}.

Стандартный <<путь>> через эти переменные, например, для \Cplusplus{},
проходит через два правила. Сначала происходит компиляция исходных
файлов \Cplusplus{} в объектные файлы, которые затем компонуются в
исполняемый файл.

{\footnotesize
\begin{verbatim}
%.o: %.C
    $(COMPILE.C) $(OUTPUT_OPTION) $<

%: %.o
    $(LINK.o) $\ $(LOADLIBES) $(LDLIBS) -o $@
\end{verbatim}
}

Первое правило использует следующие определения переменных:

{\footnotesize
\begin{verbatim}
COMPILE.C     = $(COMPILE.cc)
COMPILE.cc    = $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c
CXX           = g++
OUTPUT_OPTION = -o $@
\end{verbatim}
}

GNU \GNUmake{} поддерживает два расширения исходных файлов
\Cplusplus{}: \filename{.C} и \filename{.cc}. Значением переменной
\variable{CXX} является имя компилятора \Cplusplus{}, по умолчанию это
\index{Переменные!стандартные!CXXFLAGS@\variable{CXXFLAGS}}
\index{Переменные!стандартные!CPPFLAGS@\variable{CPPFLAGS}}
\index{Переменные!стандартные!TARGETARCH@\variable{TARGET\_ARCH}}
\utility{g++}. Переменные \variable{CXXFLAGS}, \variable{CPPFLAGS} и
\variable{TARGET\_ARCH} (опции компилятора \Cplusplus{}, опции
препроцессора \Clang{} и опции, специфичные для архитектуры,
соответственно) не имеют значения по умолчанию. Они нужны для
настройки процесса сборки конечным пользователем. Переменная
\index{Переменные!стандартные!OUTPUT\_OPTION@\variable{OUTPUT\_OPTION}}
\variable{OUTPUT\_OPTION} содержит имя выходного файла.

Правило компоновки немного проще:

{\footnotesize
\begin{verbatim}
LINK.o = $(CC) $(LDFLAGS) $(TARGET_ARCH)
CC     = gcc
\end{verbatim}
}

\index{Переменные!стандартные!LDFLAGS@\variable{LDFLAGS}}
\index{Переменные!стандартные!TARGET\_ARCH@\variable{TARGET\_ARCH}}
\index{Переменные!стандартные!LDLIBS@\variable{LDLIBS}}
\index{Переменные!стандартные!LOADLIBES@\variable{LOADLIBES}}
Это правило использует компилятор языка \Clang{} для компоновки
объектных файлов в исполняемые. Компилятором языка \Clang{} по
умолчанию является \utility{gcc}. Переменные \variable{LDFLAGS} и
\variable{TARGET\_ARCH} не имеют значений по умолчанию. Значение
\variable{LDFLAGS} содержит опции компоновки, например, флаги
\command{-L}. Переменные \variable{LOADLIBES} и \variable{LDLIBS}
содержат список библиотек для компоновки. Такая избыточность была
введена из соображений переносимости.

Итак, мы завершили наш краткий обзор переменных \GNUmake{}. На самом
деле их гораздо больше, однако того, что мы рассмотрели, достаточно
для того, чтобы понять связь переменных и правил. Например, существует
группа переменных, предназначенных для работы с \TeX{}, и набор
соответствующих правил. Рекурсивный вызов \GNUmake{}~--- ещё одна
тема, для обсуждения которой нам понадобятся переменные. Мы вернёмся к
ней в главе~\ref{chap:managing_large_proj}.
