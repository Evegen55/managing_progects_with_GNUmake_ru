%%--------------------------------------------------------------------
%% Variable types
%%--------------------------------------------------------------------
\section{Типы переменных}
\label{var_types}

\index{variables!simple expanded}
\index{variables!recursively expanded}
В \GNUmake{} существует два типа переменных: упрощённо вычисляемые
(simple expanded variables) и рекурсивно вычисляемые (recursively
expanded variables). \newword{Упрощённо вычисляемые} переменные (или
\index{Переменные!простые}
\newword{простые переменные}) определяются при помощи оператора
присваивания <<\command{:=}>>:

{\footnotesize
\begin{verbatim}
MAKE_DEPEND := $(CC) -M
\end{verbatim}
}

Такие переменные называются <<упрощённо вычисляемыми>> потому, что
правая часть присваивания вычисляется непосредственно при чтении
\Makefile{}'а. При этом подставляется значение всех переменных
\GNUmake{}, входящих в правую часть, и результирующий текст
сохраняется в качестве значения переменной. Это поведение идентично
поведению большинства языков программирования и командных сценариев.
Например, вычисление предыдущей переменной, скорее всего, породит
текст \command{gcc -M}. Однако если переменная \variable{CC} не
определена, то переменная \variable{MAKE\_DEPEND} примет значение
\command{<пробел>-M}. В этом случае выражение \command{\$(CC)}
вычисляется как пустая строка, поскольку переменная \variable{CC} ещё
не определена. Отсутствие определения переменной не является ошибкой.
На самом деле это очень удобно. Большинство неявных правил содержат
неопределённые переменные, необходимые для настройки поведения правил
пользователями. Если пользователь не определяют никаких настроек,
переменные просто содержат пустые строки. Теперь рассмотрим пробел в
начале полученного значения. Правая часть присваивания после
отбрасывания начального пробела выглядит следующим образом:
\command{\${CC} -M}. После того, как ссылка на переменную
вычисляется как пустая строка, \GNUmake{} не производит повторного
сканирования и не удаляет начальные пробелы.

\index{Переменные!рекурсивные}
\newword{Рекурсивно вычисляемые} переменные (или просто рекурсивные
переменные) определяются при помощи оператора присваивания
<<\command{=}>>:

{\footnotesize
\begin{verbatim}
MAKE_DEPEND = $(CC) -M
\end{verbatim}
}

Второй тип переменных называется <<рекурсивно вычисляемые переменные>>
потому, что правая часть присваивания просто копируется \GNUmake{} и
сохраняется как значение переменной без вычисления. Вместо этого
вычисление происходит каждый раз, когда переменная
\emph{используется}. Быть может, более подходящим названием для таких
переменных~--- \newword{лениво вычисляемые} переменные, поскольку
вычисления откладываются до тех пор, пока не потребуется их результат.
Одним из удивительных следствий такого рода вычислений заключается в
том, что присваивания могут осуществляться <<в неправильном порядке>>:

{\footnotesize
\begin{verbatim}
MAKE_DEPEND = $(CC) -M
...
# Чуть позже
CC = gcc
\end{verbatim}
}

Теперь значение \variable{MAKE\_DEPEND} будет равно \command{gcc -M},
несмотря на то что значение \variable{CC} не определено в момент
присваивания значения переменной \variable{MAKE\_DEPEND}.

На самом деле рекурсивные переменные не являются просто ленивыми
присваиваниями (по крайней мере, обычными ленивыми присваиваниями).
Каждый раз при обращении к рекурсивной переменной её значение
вычисляется заново. Для переменных, определённых в терминах простых
констант, таких как \variable{MAKE\_DEPEND}, эта разница бессмысленна,
поскольку все переменные справа от оператора присваивания также
являются простыми константами. Однако представим, что переменная в
присваиваемом выражении представляет собой результат выполнения
некоторой программы, например, \utility{date}.  Каждый раз, когда
подобная рекурсивная переменная будет вычисляться, будет происходить
запуск программы \utility{date} и переменная будет получать новое
значение (в предположении, что повторное вычисление происходит по
крайней мере через секунду). Иногда это чрезвычайно полезно. А
иногда весьма раздражает!

%---------------------------------------------------------------------
% Other types of assignment
%---------------------------------------------------------------------
\subsection*{Другие виды присваивания}
\label{sec:other_types_of_assign}

В предыдущем примере мы видели два типа присваивания: <<\command{=}>>
для определения рекурсивных переменных и <<\command{:=}>> для
определения простых переменных. \GNUmake{} имеет ещё два оператора
присваивания.

\index{Операторы!условного присваивания}
Оператор <<\command{?=}>> называется \newword{оператором условного
присваивания переменной}. Для краткости мы будем называть его просто
условным присваиванием. Этот оператор осуществляет присваивание
переменной только в том случае, если её значение ещё не определено.

{\footnotesize
\begin{verbatim}
# Положить полученные файлы в каталог $(PROJECT_DIR)/out.
OUTPUT_DIR ?= \(PROJECT_DIR)/out
\end{verbatim}
}

В этом примере мы присвоим значение переменной \variable{OUTPUT\_DIR}
только в том случае, если оно ещё не было определено. Такое поведение
очень удобно для работы с переменными окружения. Мы обсудим этот
вопрос более подробно в разделе
<<\nameref{sec:where_vars_come_from}>>.

Другой оператор присваивания, \command{+=}, обычно называют
\emph{добавлением}. Как можно предположить из названия, этот оператор
добавляет текст к значению переменной. Может быть не очевидно, что это
довольно важная функциональность, необходимая при использовании
рекурсивных переменных. Значение справа от этого оператора
присваивания добавляется к значению переменной, \emph{не изменяя
в переменной первоначального значения}. <<Подумаешь,>>~--- скажете
вы,~--- <<Разве не так обычно работает добавление?>>. Да, но здесь
есть одна маленькая хитрость.

Добавление текста к простой переменной реализуется очевидным образом.
Оператор \command{+=} может быть реализован так:

{\footnotesize
\begin{alltt}
простая\_переменная := \$(простая\_переменная) что-то ещё
\end{alltt}
}

Поскольку значение простой переменной уже было вычислено, \GNUmake{}
может просто вычислить выражение \command{\$(простая\_переменная)},
добавить требуемый текст и закончить присваивание. Но рекурсивные
переменные порождают проблему. Следующая реализация недопустима:

{\footnotesize
\begin{alltt}
рекурсивная\_переменная = \$(рекурсивная\_переменная) что-то ещё
\end{alltt}
}

Это выражение является ошибкой, потому что для \GNUmake{} не
существует корректного способа его обработки. Если \GNUmake{} сохранит
текущее значение рекурсивной переменной плюс текст <<что-то ещё>>, то
не сможет вычислить правильное значение позднее. Более того, попытка
вычислить рекурсивную переменную, содержащую ссылку на себя, приводит
к бесконечному циклу:

{\footnotesize
\begin{alltt}
\$ \textbf{make}

makefile:2: *** Recursive variable `recursive' references
itself (eventually).  Stop.
\end{alltt}
}

Таким образом, оператор <<\command{+=}>> был создан специально для
возможности добавления текста к рекурсивным переменным. В частности,
этот оператор полезен при инкрементом определении значения переменной.
