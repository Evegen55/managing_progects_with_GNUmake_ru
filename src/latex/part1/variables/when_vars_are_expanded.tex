%%--------------------------------------------------------------------
%% When variables are expanded
%%--------------------------------------------------------------------
\section{Когда переменные получают свои значения}
\label{sec:when_vars_are_expanded}

В предыдущем разделе мы начали рассматривать <<закулисье>> вычисления
значения переменных. Результат во многом зависит от того, что уже было
определено, и где это было определено. Вы можете получить неожиданный
результат, даже если \GNUmake{} не может найти ошибки в вашей
спецификации. Так каковы же правила вычисления переменных? Как на
самом деле всё это работает?

После запуска \GNUmake{} выполняет свою работу в две фазы. Во время
первой фазы \GNUmake{} читает \Makefile{} и все включаемые им файлы.
На этом этапе переменные и правила загружаются во внутреннюю базу
данных \GNUmake{}, после чего создаётся граф зависимостей. Во время
второй фазы \GNUmake{} анализирует граф зависимостей и определяет
цели, которые нуждаются в сборке, затем выполняет командные сценарии
для сборки реквизитов.

Когда \GNUmake{} встречает директиву \directive{define} или
определение рекурсивной переменной, строки значения переменной или
тела макроса сохраняются вместе с символами новой строки без
каких-либо вычислений. Самый последний символ новой строки в теле
макроса не сохраняется в тексте определения. Иначе при вычислении
макроса читался бы один лишний символ новой строки.

При вычислении макроса полученный текст сразу же сканируется на
содержание других макросов или переменных, подлежащих вычислению, этот
процесс продолжается рекурсивно. Если макрос вычисляется в контексте
командного сценария, в начало каждой строки добавляется символ
табуляции.

Итак, вычисление переменных и макросов \GNUmake{} подчиняется
следующим правилам:
\begin{itemize}
%---------------------------------------------------------------------
\item
В случае присваивания переменной значения левая часть присваивания
всегда вычисляется сразу на первой фазе работы \GNUmake{}.
%---------------------------------------------------------------------
\item Вычисление правой части операторов \command{=} и \command{?=}
откладывается до тех пор, пока не потребуется значение соответствующей
переменной.
%---------------------------------------------------------------------
\item Правая часть оператора \command{:=} вычисляется сразу.
%---------------------------------------------------------------------
\item Правая часть оператора \command{+=} вычисляется сразу, если
переменная в левой части изначально была определена как простая, иначе
вычисление откладывается.
%---------------------------------------------------------------------
\item В определении макроса (использующего директиву
\directive{define}) имя определяемого макроса вычисляется сразу,
вычисление тела макроса откладывается.
%---------------------------------------------------------------------
\item Имена целей и реквизитов всегда вычисляются сразу, вычисление
команд всегда откладывается.
%---------------------------------------------------------------------
\end{itemize}

Таблица~\ref{tab:rules_for_imm_and_der_exp} содержит правила порядка
вычисления выражений при определении переменных.

%\begin{center}
\begin{table}
\begin{tabular}{|l|l|l|}
\hline
\multicolumn{1}{|c|}{\textbf{Определение}} &
\multicolumn{1}{c}{\textbf{\emph{A} вычисляется}} &
\multicolumn{1}{|c|}{\textbf{\emph{B} вычисляется}} \\
\hline
\(A = B\) & Сразу & При использовании \\
\hline
\(A ?= B\) & Сразу & При использовании\\
\hline
\(A := B\) & Сразу & Сразу \\
\hline
\(A += B\) & Сразу & Сразу или при использовании\\
\hline
\parbox{2.3cm}{
\begin{alltt}
define \emph{A}\\
\emph{B} \ldots\\
\emph{B} \ldots\\
endef
\end{alltt}
}
& Сразу & При использовании \\
\hline
\end{tabular}
\caption{Правила для незамедлительного и отложенного вычислений}
\label{tab:rules_for_imm_and_der_exp}
\end{table}
%\end{center}

Примите за правило определять переменные и макросы перед их
использованием. В частности, требуется, чтобы переменная,
используемая в описании цели или реквизита была определена.

Думаю, пример многое прояснит. Предположим, мы решили переделать наш
макрос \variable{free-space}. Сначала рассмотрим отдельные части
примера, затем соберём всё вместе.

{\footnotesize
\begin{verbatim}
BIN    := /usr/bin
PRINTF := $(BIN)/printf
DF     := $(BIN)/df
AWK    := $(BIN)/awk
\end{verbatim}
}

Мы определяем три переменных, содержащие имена программ, которые будут
использоваться в нашем макросе. Поскольку все переменные являются
простыми, их значения должны быть вычислены во время чтения
\Makefile{}'а.  Так как переменная \variable{BIN} определена раньше
остальных, её значение может быть использовано в определениях других
переменных.

Далее определим макрос \variable{free-space}.

{\footnotesize
\begin{verbatim}
define free-space
  $(PRINTF) "Free disk space "
  $(DF) . | $(AWK) 'NR == 2 { print $$4 }'
endef
\end{verbatim}
}

За директивой \directive{define} следует имя переменной, которое сразу
вычисляется. В нашем случае вычисления не требуется. Тело макроса
считывается и сохраняется не вычисленным.

Наконец, используем наш макрос внутри правила.

{\footnotesize
\begin{verbatim}
OUTPUT_DIR := /tmp

$(OUTPUT_DIR)/very_big_file:
    $(free-space)
\end{verbatim}
}

Когда считывается цель \target{\$(OUTPUT\_DIR)/very\_big\_file},
происходит подстановка значений всех переменных. Значение выражения
\command{\$(OUTPUT\_DIR)} вычисляется как \command{/tmp}, формируя
цель \target{/tmp/very\_big\_file}. Затем считывается командный
сценарий, ассоциированный с этой целью. Строки с командами
распознаются благодаря наличию символа табуляции, считываются и
сохраняются, но подстановка значений переменных и макросов не
происходит.

Теперь соберём отрывки воедино. Изменим порядок их следования для
иллюстрации алгоритма вычисления \GNUmake{}:

{\footnotesize
\begin{verbatim}
OUTPUT_DIR := /tmp

$(OUTPUT_DIR)/very_big_file:
    $(free-space)

define free-space
  $(PRINTF) "Free disk space "
  $(DF) . | $(AWK) 'NR == 2 { print $$4 }'
endef

BIN    := /usr/bin
PRINTF := $(BIN)/printf
DF     := $(BIN)/df
AWK    := $(BIN)/awk
\end{verbatim}
}

Заметим, что несмотря на то, что порядок строк кажется обратным,
выполнение происходит успешно. В этом заключается один из
замечательных эффектов рекурсивных переменных. Они могут быть
невероятно полезны и совершенно непонятны одновременно. Наш
\Makefile{} работает как нужно благодаря тому, что вычисление
командных сценариев и тел макросов откладываются до тех пор, пока
результаты этих вычислений не потребуются. Таким образом, порядок, в
котором появляются определения, не влияет на выполнение.

На второй фазе выполнения, когда \Makefile{} уже прочитан, \GNUmake{}
определяет цели, анализирует граф зависимостей и выполняет действия,
ассоциированные с каждым правилом. Поскольку мы специфицировали только
одну цель, не имеющую реквизитов
(\command{\$(OUTPUT\_DIR)/very\_big\_file}), \GNUmake{} просто выполнит
действия, с ассоциированные с ней (предположим, такой файл не
существует)~--- команду \command{\$(free-space)}. После вычислений
\GNUmake{} получит следующее:

{\footnotesize
\begin{verbatim}
/tmp/very_big_file:
    /usr/bin/printf "Free disk space "
    /usr/bin/df . | /usr/bin/awk 'NR == 2 { print $$4 }'
\end{verbatim}
}

Как только значения всех переменных вычислены, \GNUmake{} выполняет
команды одну за другой. Давайте рассмотрим две части \Makefile{}'а, в
которых порядок имеет значение. Как упоминалось ранее, имя цели
\command{\$(OUTPUT\_DIR)/very\_big\_file} вычисляется сразу. Если бы
определение переменной \variable{OUTPUT\_DIR} находилось после
спецификации правила, результатом вычисления имени стала бы строка
\command{/very\_big\_file}. Скорее всего, это не то, чего хотел
пользователь. Если бы определение \variable{BIN} было помещено после
определения \variable{AWK}, наши переменные получили бы значения
\command{/printf}, \command{/df} и \command{/awk}, так как оператор
\command{:=} вызывает немедленное вычисление правой части
присваивания. Однако в этом случае мы можем избежать проблемы,
использовав для определения переменных \variable{PRINTF},
\variable{DF} и \variable{AWK} оператор \command{=} вместо оператора
\command{:=} и сделав тем самым эти переменные рекурсивными.

Наконец, обратите внимание на одну деталь. Объявление переменных
\variable{OUTPUT\_DIR} и \variable{BIN} как рекурсивных не решило бы
рассмотренных проблем порядка спецификаций. Важно здесь то, что в
момент вычисления значения переменной
\command{\$(OUTPUT\_DIR)/very\_big\_file} и правых частей определений
\variable{PRINTF}, \variable{DF} и \variable{AWK} значения переменных,
на которые ссылаются эти выражения, должны быть уже определены.
