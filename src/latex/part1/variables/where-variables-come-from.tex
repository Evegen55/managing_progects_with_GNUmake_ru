%%--------------------------------------------------------------------
%% Where variables come from
%%--------------------------------------------------------------------
\section{Где определяются переменные}
\label{sec:where_vars_come_from}

Пока все переменные в наших \Makefile{}'ах определялись явно. На самом
деле они могут иметь и более сложное происхождение. Например, мы уже
видели, что переменные могут определяться через интерфейс командной
строки \GNUmake{}. На самом деле переменные могут определяться в
следующих источниках:

\begin{description}
%---------------------------------------------------------------------
\item[\emph{Файл}] \hfill \\
Естественно, переменные могут быть определены в \Makefile{}'е или в
файле, им подключенным.
%---------------------------------------------------------------------
\item[\emph{Командная строка}] \hfill \\
Переменные могут быть определены или переопределены прямо из командной
строки \GNUmake{}:

{\footnotesize
\begin{alltt}
\$ \textbf{make CFLAGS=-g CPPFLAGS='-DBSD -DDEBUG'}
\end{alltt}
}

Аргументы командной строки, содержащие символ \command{=}, являются
определениями переменных. Каждое такое определение должно быть
отдельным аргументом. Если значение переменной (или, упаси вас Боже,
её имя) содержит пробелы, нужно либо экранировать пробел, либо
заключить этот аргумент в кавычки.

Значение, полученное переменной через интерфейс командной строки,
переопределяет любое другое определение, сделанное в \Makefile{}'е или
содержащееся в окружении. Присваивания в командной строке могут
определять как простые, так и рекурсивные переменные с помощью
операторов \command{:=} и \command{=} соответственно. Однако всё же
существует возможность повысить приоритет определения переменной в
\index{Директивы!override@\directive{override}}
\Makefile{}'е, для этого нужно использовать директиву
\directive{override}.

{\footnotesize
\begin{verbatim}
# Для успешной компоновки необходим порядок байтов от старшего к
# младшим.
override LDFLAGS = -EB
\end{verbatim}
}

Разумеется, игнорировать явные определения пользователя стоит только в
чрезвычайных обстоятельствах.
%---------------------------------------------------------------------
\item[\emph{Окружение}] \hfill \\
\index{Переменные!окружения}
После старта \GNUmake{} все переменные окружения автоматически
становятся переменными \GNUmake{}. Эти переменные имеют очень низкий
приоритет, поэтому присваивание значения этим переменным, сделанное в
\Makefile{}'е или через командную строку, переопределит переменную
окружения. Вы можете форсировать переопределение переменных в
\Makefile{}'е переменными окружения при помощи опции
\index{Опции!environment-overrides@\command{-{}-environment\hyp{}overrides (-e)}}
\command{-{}-environment\hyp{}overrides} (или просто \command{-e}).

Когда \GNUmake{} вызывается рекурсивно, некоторые переменные из
родительского процесса \GNUmake{} передаются через окружение дочернему
процессу. По умолчанию только переменные, изначально определённые в
окружении, попадают в окружение дочернего процесса. Однако любая
переменная может быть помещена в окружение с помощью директивы
\index{Директивы!export@\directive{export}}
\directive{export}:

{\footnotesize
\begin{verbatim}
export CLASSPATH := \$(HOME)/classes:\$(PROJECT)/classes
SHELLOPTS = -x
export SHELLOPTS
\end{verbatim}
}

Вы также можете экспортировать все переменные:

{\footnotesize
\begin{verbatim}
export
\end{verbatim}
}

Обратите внимание на то, что \GNUmake{} может экспортировать даже те
переменные, имена которых содержат недопустимые с точки зрения
командного интерпретатора символы.  Например, результатом запуска
следующего \Makefile{}'а:

{\footnotesize
\begin{verbatim}
export valid-variable-in-make = Neat!
show-vars:
    env | grep '^valid-'
    valid_variable_in_shell=Great
    invalid-variable-in-shell=Sorry
\end{verbatim}
}

{\flushleft будет вывод:}

{\footnotesize
\begin{alltt}
\$ \textbf{make}
env | grep '\^{}valid-'
valid-variable-in-make=Neat!
valid\_variable\_in\_shell=Great
invalid-variable-in-shell=Sorry
/bin/sh: line 1: invalid-variable-in-shell=Sorry: command not found
make: *** [show-vars] Error 127
\end{alltt}
}

<<Недопустимая>> переменная командного интерпретатора была создана при
помощи экспорта из \GNUmake{} переменной
\variable{valid-variable-in-make}. Эта переменная не будет доступна
стандартными средствами интерпретатора, только при помощи трюков
наподобие применения программы \utility{grep} ко всему окружению. Тем
не менее, эта переменная будет доступна в дочернем процессе
\GNUmake{}. Мы рассмотрим применение рекурсивных вызовов \GNUmake{} во
второй части книги.

Вы также можете запретить экспорт переменной в окружение дочернего
процесса:

{\footnotesize
\begin{verbatim}
unexport DISPLAY
\end{verbatim}
}

\index{Директивы!export@\directive{export}}
\index{Директивы!unexport@\directive{unexport}} Директивы
\directive{export} и \directive{unexport} работают так же, как и
их аналоги из интерпретатора \utility{sh}.

\index{Операторы!условного присваивания}
Оператор условного присваивания очень удобен при работе с переменными
окружения. Допустим, вы определили в своём \Makefile{}'е стандартный
каталог для хранения создаваемых файлов и хотите предоставить
пользователю возможность легко его изменить. Условное присваивание
идеально подходит для таких ситуаций:

{\footnotesize
\begin{verbatim}
# Пусть каталогом по умолчанию будет $(PROJECT_DIR)/out.
OUTPUT_DIR ?= $(PROJECT_DIR)/out
\end{verbatim}
}

В этом случае присваивание произойдёт только в том случае, если
значение переменной \variable{OUTPUT\_DIR} ещё не определено. Мы можем
добиться того же эффекта более <<многословным>> способом:

{\footnotesize
\begin{verbatim}
ifndef OUTPUT_DIR
  # Пусть каталогом по умолчанию будет $(PROJECT_DIR)/out.
  OUTPUT_DIR = $(PROJECT_DIR)/out
endif
\end{verbatim}
}

Разница между этими двумя определениями заключается в том, что
оператор условного присваивания не будет выполнен, если переменная
\variable{OUTPUT\_DIR} определена, пусть даже имеет пустое значение,
\index{Директивы!условной обработки!ifdef@\directive{ifdef}}
тогда как операторы \directive{ifdef} и \directive{ifndef} проверяют
свой аргумент на пустоту. Таким образом, выражение
\command{OUTPUT\_DIR=} с точки зрения оператора условного присваивания
будет считаться определением, а с точки зрения оператора
\directive{ifdef}~--- нет.

Следует отметить, что чрезмерное использование переменных окружения
делает ваши \Makefile{}'ы менее переносимыми, поскольку разные
пользователи, как правило, имеют разное окружение. На самом деле, я
редко использую переменные окружения именно по этой причине.
%---------------------------------------------------------------------
\item[\emph{Автоматические переменные}] \hfill \\
\index{Переменные!автоматические}
Наконец, \GNUmake{} создаёт автоматические переменные непосредственно
перед выполнением сценария, ассоциированного с правилом.
\end{description}

Традиционно переменные окружения используются для упрощения управления
разницей в настройке машин разработчиков. Например, общей практикой
является создание среды разработки (инструментов разработки, исходного
кода и дерева полученных компиляцией файлов) на основании переменных
окружения, используемых в \Makefile{}'е. При таком подходе \Makefile{}
определяет одну переменную для корня каждого дерева каталогов. Если
корень дерева исходных файлов содержится в переменной
\variable{PROJECT\_SRC}, корень дерева объектных файлов~--- в
переменной \variable{PROJECT\_BIN}, а каталог библиотек~--- в
переменной \variable{PROJECT\_LIB}, то разработчик вправе определить
эти каталоги так, как он считает нужным.

Потенциальной проблемой такого подхода (и вообще использования
переменных окружения) является ситуация, когда упомянутые выше
переменные не определены. Одним из решений является определение
значений по умолчанию в \Makefile{}'е с помощью оператора условного
присваивания:

{\footnotesize
\begin{verbatim}
PROJECT_SRC ?= /dev/$(USER)/src
PROJECT_BIN ?= $(patsubst %/src,%/bin,$(PROJECT_SRC))
PROJECT_LIB ?= /net/server/project/lib
\end{verbatim}
}

Используя эти переменные для доступа к компонентам проекта, вы можете
создать среду разработки, адаптируемую под различные настройки машин
разработчиков (мы увидим более развёрнутые примеры во второй части
книги). Однако опасайтесь чрезмерного использования переменных
окружения. Как правило, \Makefile{} следует составлять так, чтобы как
можно меньше использовать окружение разработчика, предоставлять
разумные настройки по умолчанию и проверять наличие критически важных
компонентов.
