%%--------------------------------------------------------------------
%% Reference builds, libraries, and installers
%%--------------------------------------------------------------------
\section{Справочные сборки, библиотеки и инсталляторы}

Мы уже рассмотрели все средства, необходимые для реализации справочных
сборок. Настройка головного \Makefile{}'а для добавления этого
функционала не займёт много усилий. Просто заменим простые
присваивания значений переменных \variable{SOURCE\_DIR} и
\variable{BINARY\_DIR} условными (\command{?=}). Сценарий,
выполняемый программой \utility{cron}, может быть построен с
использованием следующего подхода:

\begin{enumerate}
%---------------------------------------------------------------------
\item Перенаправить поток вывода и определить имена файлов журналов.
%---------------------------------------------------------------------
\item Очистить каталоги старых сборок и удалить лишние файлы из
справочного дерева каталогов исходных файлов.
%---------------------------------------------------------------------
\item Сделать рабочую копию свежей версии исходного кода.
%---------------------------------------------------------------------
\item Определить переменные, отвечающие за расположение исходных и
бинарных файлов.
%---------------------------------------------------------------------
\item Осуществить вызов \GNUmake{}.
%---------------------------------------------------------------------
\item Проверить, содержат ли файлы журналов ошибки.
%---------------------------------------------------------------------
\item Составить файл символов (TAGS-файл), и, при необходимости,
\index{locate database} \index{База данных!файлов}
обновить базу данных файлов (locate database)\footnote{
База данных файлов~--- это совокупность всех имён файлов, существующих
в файловой системе. Использование такой базы позволяет быстро находить
файлы по имени. Трудно переоценить полезность такой базы при
управлении большими проектами. Я предпочитаю реализовывать
автоматическое обновление этой базы после ночной сборки.}.
%---------------------------------------------------------------------
\item Послать письмо с отчётом об успешном (или неудачном) завершении
сборки.
%---------------------------------------------------------------------
\end{enumerate}

В модели разработки с применением справочных сборок удобно
поддерживать несколько старых сборок на случай, если чьё-то
злонамеренное вмешательство повредит дерево каталогов. Я обычно храню
7 или 14 ночных сборок. Разумеется, сценарий, осуществляющий ночные
сборки, описывает свои действия в файле журнала и удаляет устаревшие
сборки и файлы журналов. Поиск ошибок в файле журнала обычно
осуществляется при помощи сценария \utility{awk}. Наконец, я использую
сценарий, обновляющий файл \filename{latest}, являющийся символической
ссылкой на последнюю сборку. Для определения успешности сборки я
включаю в каждый \Makefile{} цель \target{validate}. Сценарий,
ассоциированный с этой целью, осуществляет проверку наличия всех
необходимых целевых файлов:

{\footnotesize
\begin{verbatim}
.PHONY: validate_build
validate_build:
    test $(foreach f,$(RELEASE_FILES),-s $f -a) -e .
\end{verbatim}
}

Этот сценарий проверяет, что файлы, которые должны появиться в
результате сборки, существуют и не пусты. Разумеется, такой подход
никогда не заменит тестирования, однако он является удобной базовой
проверкой целостности сборки. Если этот тест не пройден, \GNUmake{}
завершается с ошибкой, и сценарий, осуществляющий ночную сборку,
сохраняет ссылку \filename{latest} указывающей на предыдущую сборку.

\index{Библиотека!сторонних разработчиков}
Сторонние библиотеки всегда немного мешают управлению проектом. Я
согласен с распространённым убеждением, что хранение больших бинарных
файлов в CVS является не лучшей идеей. Причина кроется в том, что CVS
не может хранить отличия бинарных файлов с помощью
дельта\hyp{}кодирования, в результате чего файлы системы RCS, лежащей
в основе CVS, могут вырасти до огромных размеров. Хранение файлов
больших размеров в репозитории CVS существенно замедляет многие
базовые операции CVS, что сказывается на всём цикле разработки.

Если библиотеки сторонних разработчиков не хранятся в CVS, нужно
управлять ими каким-то другим способом. Моим предложением является
создание в справочном дереве каталога библиотек и включение версии
каждой библиотеки в имя соответствующего каталога, как показано на
рисунке~\ref{fig:third_party_libs}.

\begin{figure}[b]
\begin{verbatim}
reftree
`--third-party
   |--oracle-8.0.7sp2
   `--oracle-9.0.1.1
\end{verbatim}
\caption{Структура каталогов, используемая для управления библиотеками
сторонних разработчиков.}
\label{fig:third_party_libs}
\end{figure}

Имена этих каталогов могут использоваться в \Makefile{}'е:

{\footnotesize
\begin{verbatim}
ORACLE_9011_DIR ?= /reftree/third_party/oracle-9.0.1.1/Ora90
ORACLE_9011_JAR ?= $(ORACLE_9011_DIR)/jdbc/lib/classes12.jar
\end{verbatim}
}

\index{Инсталлятор}
Когда поставщик изменит версию своей библиотеки, создайте новый
каталог в справочном дереве и объявите новую переменную в
\Makefile{}'е. При использовании этого подхода \Makefile{}, должным
образом поддерживаемый при помощи меток и ветвей системы контроля
версий, всегда будет явно отражать версию используемой библиотеки.

Создание и поддержка инсталляторов также является сложной проблемой. Я
уверен, что отделение базового процесса сборки от процесса создания
инсталлятора является правильным решением. Инструменты для создания
инсталляторов, существующие на момент написания этой книги, сложны и
неустойчивы. Соединение этих инструментов с системой сборки (часто
также являющейся сложной и неустойчивой) породит чрезвычайно сложную в
поддержке систему. Вместо этого сценарий базовой сборки может помещать
бинарные файлы в каталог продукта, содержащий все (или почти все)
данные, необходимые инструменту создания инсталляторов. Управления
этим инструментом может осуществляться при помощи собственного
\Makefile{}'а, в конечном счёте производящего исполняемый файл
установки.
