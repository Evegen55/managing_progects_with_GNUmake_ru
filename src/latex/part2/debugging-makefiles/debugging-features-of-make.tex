%%--------------------------------------------------------------------
%% Debugging Features of Make
%%--------------------------------------------------------------------
\section{Отладочные возможности \GNUmake{}}

\index{Функции!встроенные!warning@\function{warning}}
Функция \function{warning} очень полезна для отладки
\makefile{ов}. Поскольку результатом вычисления этой функции является
пустая строка, её можно помещать в любом месте \makefile{а}: на самом
верхнем уровне, в списке реквизитов или в секции команд правила. Это
позволяет вам печатать значения переменных в том месте, где это
наиболее удобно. Например:

\begin{verbatim}
$(warning Предупреждение верхнего уровня)

FOO := $(warning Правая часть простой переменной)bar
BAZ = $(warning Правая часть рекурсивной переменной)boo

$(warning Цель)target: $(warning Список реквизитов)makefile $(BAZ)
    $(warning Командный сценарий)
    ls

$(BAZ):
\end{verbatim}

Производит следующий вывод:

\begin{verbatim}
$ make
makefile:1: Предупреждение верхнего уровня
makefile:2: Правая часть простой переменной
makefile:5: Цель
makefile:5: Список реквизитов
makefile:5: Правая часть рекурсивной переменной
makefile:8: Правая часть рекурсивной переменной
makefile:6: Командный сценарий
ls
makefile
\end{verbatim}

Обратите внимание на вычисление функции \function{warning} следует
обычной схеме аппликативных и отложенных вычислений
\GNUmake{}. Несмотря на то, что вычисление \variable{BAZ} содержит
вызов \function{warning}, соответствующее сообщение не будет
напечатано до вычисление \variable{BAZ} в списке реквизитов.

Возможность внедрять \function{warning} в любое место состовляет
по сути основной отладочный механизм.

\subsection{Опции командной строки}

Следующие три опции командной строки я нахожу наиболее удобными для
отладки: \command{-{}-just-print (-n)}, \command{-{}-print-data-base
  (-p)}, \command{-{}-warn-undefined-variables}.

\subsubsection{\function{-{}-just-print}}
\index{Опции!just-print@\command{-{}-just-print (-n)}}

Первым тестом, выполняемым мной для новой цели \makefile{а}, это вызов
\GNUmake{} с опцией \command{-{}-just-print (-n)}. Эта опция вынуждает
\GNUmake{} читать \Makefile{} и печатать все команды, которую он бы
выполнял при сборке цели, без их непосредственного выполнения. Для
удобства \GNUmake{} также печатает все команды \command{echo},
помеченные модификатором подавления вывода \command{(@)}.

Эта опция подавляет выполнение всех команд. Однако вам нужно быть
осторожным: хоть \GNUmake{} и не будет выполнять сценарии правил,
вызовы функции \function{shell} в аппликативном контексте всё же будут
выполнены. Например:

\begin{verbatim}
REQUIRED_DIRS = ...
_MKDIRS := $(shell for d in $(REQUIRED_DIRS); \
             do                               \
               [[ -d $$d ]] || mkdir -p $$d;  \
             done)

$(objects) : $(sources)
\end{verbatim}

Как мы уже видели раньше, назначение простой переменной
\variable{\_MKDIRS}~--- создание необходимых каталогов. При выполнении
с опцией \command{-{}-just-print} \GNUmake{} вызовет функцию
\function{shell} во время чтения \makefile{а}. Уже после этого
\GNUmake{} будет печатать (не выполняя) команды компиляции,
необходимые для сборки файлов из списка \command{\$(objects)}.
