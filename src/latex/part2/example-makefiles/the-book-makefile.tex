%%--------------------------------------------------------------------
%% The Book Makefile
%%--------------------------------------------------------------------
\section{\Makefile{} этой книги}

Написание книги о программировании само по себе является интересным
упражнением в построении систем сборки. Текст книги состоит из
множества файлов, каждый из которых требует соответствующей
обработки. Примеры являются реальными программами, каждую из которых
нужно запустить, получить из вывод, обработать его и включить в
основной текст (благодаря этому вывод не нужно копировать и вставлять
в текст, что избавляет от риска внесения ошибок). В процессе написания
книги полезно иметь возможность просмотреть текст в различных
форматах. Наконец, доставка рабочего материала требует
архивирования. Разумеется, все шаги должны быть воспроизводимыми и
относительно простыми в поддержке.

Похоже, это работа для \GNUmake{}! Возможность применения для
удивительно разнородных потребностей ~--- одна из самых замечательных
особенностей \GNUmake{}. Эта книга была написана в формате DocBook
(т.е. XML). \GNUmake{}~--- это стандартный выбор при работе с \TeX{},
\LaTeX{} и \command{troff}.

Следующий пример содержит полный \Makefile{} этой книги. В нём
примерно 440 строк. \Makefile{} разделяется на следующие базовые
задачи:

\begin{itemize}
  \item{} Управление примерами.
  \item{} Предварительная обработка XML.
  \item{} Генерация документов в различных форматах.
  \item{} Проверка исходного кода.
  \item{} Базовые задачи поддержки.
\end{itemize}

\begin{verbatim}
# Сборка книги.
#
# Основные цели этого файла:
#
# show_pdf  Генерация pdf и запуск программы просмотра
# pdf       Генерация pdf
# print     Печать pdf
# show_html Генерация html и запуск программы просмотра
# html      Генерация html
# xml       Генерация xml
# release   Создание архива с релизом
# clean     Удаление файлов, созданных в процессе сборки
#

BOOK_DIR     := /test/book
SOURCE_DIR   := text
OUTPUT_DIR   := out
EXAMPLES_DIR := examples

QUIET = @

SHELL       =  shell
AWK         := awk
CP          := cp
EGREP       := egrep
HTML_VIEWER := cygstart
KILL        := /bin/kill
M4          := m4
MV          := mv
PDF_VIEWER  := cygstart
RM          := rm -f
MKDIR       := mkdir -p
LNDIR       := lndir
SED         := sed
SORT        := sort
TOUCH       := touch
XMLTO       := xmlto
XMLTO_FLAGS =  -o $(OUTPUT_DIR) $(XML_VERBOSE)
process-pgm := bin/process-include
make-depend := bin/make-depend

m4-macros := text/macros.m4

# $(call process-includes, input-file, output-file)
# Осуществляет замену символов табуляции пробелами,
# подстановку макросов и обработку директив включения.
define process-includes
  expand $1 |                                             \
  $(M4) --prefix-builtins --include=text $(m4-macros) - | \
  $(process-pgm) > $2
endef

# $(call file-exists, file-name)
# Возвращает ненулевое значение в случае существования
# файла с заданным именем
file-exists = $(wildcard $1)

# $(call maybe-mkdir, directory-name-opt)
# Создаёт каталог, если он ещё не существует.
# Если параметр directory-name-opt опущен, в качестве имени
# каталога используется значение $@.
maybe-mkdir = $(if $(call file-exists,        \
                     $(if $1,$1,$(dir $@))),, \
                $(MKDIR) $(if $1,$1,$(dir $@)))

# $(kill-acroread)
# Завершает процесс Acrobat Reader
define kill-acroread
  $(QUIET) ps -W |                                 \
  $(AWK) 'BEGIN { FIELDWIDTHS = "9 47 100" }       \
          /AcroRd32/ {                             \
                       print "Killing " $$3;       \
                       system( "$(KILL) -f " $$1 ) \
                     }'
endef

# $(call source-to-output, file-name)
# Преобразует имя исходного файла в имя выходного файла.
define source-to-output
$(subst $(SOURCE_DIR),$(OUTPUT_DIR),$1)
endef

# $(call run-script-example, script-name, output-file)
# Запускает makefile примера.
define run-script-example
  ( cd $(dir $1);                                   \
    $(notdir $1) 2>&1 |                             \
    if $(EGREP) --silent '\$$\(MAKE\)' [mM]akefile; \
    then                                            \
      $(SED) -e 's/^++*/$$/';                       \
    else                                            \
      $(SED) -e 's/^++*/$$/'                        \
             -e '/ing directory /d'                 \
             -e 's/\[[0-9]\]//';                    \
    fi )                                            \
  > $(TMP)/out.$$$$ &                               \
  $(MV) $(TMP)/out.$$$$ $2
endef

# $(call generic-program-example,example-directory)
# Создаёт общие правила сборки примера.
define generic-program-example
  $(eval $1_dir      := $(OUTPUT_DIR)/$1)
  $(eval $1_make_out := $($1_dir)/make.out)
  $(eval $1_run_out  := $($1_dir)/run.out)
  $(eval $1_clean    := $($1_dir)/clean)
  $(eval $1_run_make := $($1_dir)/run-make)
  $(eval $1_run_run  := $($1_dir)/run-run)
  $(eval $1_sources  := $(filter-out %/CVS, \
                          $(wildcard $(EXAMPLES_DIR)/$1/*)))
  $($1_run_out): $($1_make_out) $($1_run_run)
      $$(call run-script-example, $($1_run_run), $$@)

  $($1_make_out): $($1_clean) $($1_run_make)
      $$(call run-script-example, $($1_run_make), $$@)

  $($1_clean): $($1_sources) Makefile
      $(RM) -r $($1_dir)
      $(MKDIR) $($1_dir)
      $(LNDIR) -silent ../../$(EXAMPLES_DIR)/$1 $($1_dir)
      $(TOUCH) $$@

  $($1_run_make):
      printf "#! /bin/bash -x\nmake\n" > $$@
endef

# Конечные форматы книги
BOOK_XML_OUT     := $(OUTPUT_DIR)/book.xml
BOOK_HTML_OUT    := $(subst xml,html,$(BOOK_XML_OUT))
BOOK_FO_OUT      := $(subst xml,fo,$(BOOK_XML_OUT))
BOOK_PDF_OUT     := $(subst xml,pdf,$(BOOK_XML_OUT))
ALL_XML_SRC      := $(wildcard $(SOURCE_DIR)/*.xml)
ALL_XML_OUT      := $(call source-to-output,$(ALL_XML_SRC))
DEPENDENCY_FILES := $(call source-to-output,\
                           $(subst .xml,.d,$(ALL_XML_SRC)))
# xml/html/pdf - Производит желаемые конечные форматы книги.
.PHONY: xml html pdf
xml:  $(OUTPUT_DIR)/validate
html: $(BOOK_HTML_OUT)
pdf:  $(BOOK_PDF_OUT)

# show_pdf - Формирует pdf документ и отображает его.
.PHONY: show_pdf show_html print
show_pdf: $(BOOK_PDF_OUT)
    $(kill-acroread)
    $(PDF_VIEWER) $(BOOK_PDF_OUT)

# show_html - Создаёт html файл и отображает его.
show_html: $(BOOK_HTML_OUT)
    $(HTML_VIEWER) $(BOOK_HTML_OUT)

# print - Печатает заданные страницы книги.
print: $(BOOK_FO_OUT)
    $(kill-acroread)
    java -Dstart=15 -Dend=15 $(FOP) $< -print > /dev/null

# $(BOOK_PDF_OUT) - Формирует pdf файл.
$(BOOK_PDF_OUT): $(BOOK_FO_OUT) Makefile

# $(BOOK_HTML_OUT) - Формирует html файл.
$(BOOK_HTML_OUT): $(ALL_XML_OUT) $(OUTPUT_DIR)/validate Makefile

# $(BOOK_FO_OUT) - Формирует временный fo-файл.
.INTERMEDIATE: $(BOOK_FO_OUT)
    $(BOOK_FO_OUT): $(ALL_XML_OUT) $(OUTPUT_DIR)/validate Makefile

# $(BOOK_XML_OUT) - Обрабатывает все входные xml файлы.
$(BOOK_XML_OUT): Makefile

#################################################################
# Поддержка FOP
#
FOP := org.apache.fop.apps.Fop

# DEBUG_FOP - Определите этот макрос для просмотра вывода fop.
ifndef DEBUG_FOP
  FOP_FLAGS := -q
  FOP_OUTPUT := | $(SED) -e '/not implemented/d'       \
                         -e '/relative-align/d'        \
                         -e '/xsl-footnote-separator/d'
endif

# CLASSPATH - Compute the appropriate CLASSPATH for fop.
export CLASSPATH
CLASSPATH = $(patsubst %;,%,                                \
              $(subst ; ,;,                                 \
                $(addprefix c:/usr/xslt-process-2.2/java/,  \
                  $(addsuffix .jar;,                        \
                    xalan                                   \
                    xercesImpl                              \
                    batik                                   \
                    fop                                     \
                    jimi-1.0                                \
                    avalon-framework-cvs-20020315))))

# %.pdf - Шаблонное правило создания pdf из fo.
%.pdf: %.fo
    $(kill-acroread)
    java -Xmx128M $(FOP) $(FOP_FLAGS) $< $@ $(FOP_OUTPUT)

# %.fo - Шаблонное правило для создания fo из xml.
PAPER_SIZE := letter
%.fo: %.xml
    XSLT_FLAGS="--stringparam paper.type $(PAPER_SIZE)" \
    $(XMLTO) $(XMLTO_FLAGS) fo $<

# %.html - Шаблонное правило для создания html из xml.
%.html: %.xml
    $(XMLTO) $(XMLTO_FLAGS) html-nochunks $<

# fop_help - Отображение справки по использованию fop.
.PHONY: fop_help
fop_help:
    -java org.apache.fop.apps.Fop -help
    -java org.apache.fop.apps.Fop -print help

#################################################################
# release - Создаёт релиз книги
#
RELEASE_TAR   := mpwm-$(shell date +%F).tar.gz
RELEASE_FILES := README Makefile *.pdf bin examples out text
.PHONY: release
release: $(BOOK_PDF_OUT)
    ln -sf $(BOOK_PDF_OUT) .
    tar --create                 \
        --gzip                   \
        --file=$(RELEASE_TAR)    \
        --exclude=CVS            \
        --exclude=semantic.cache \
        --exclude=*~             \
        $(RELEASE_FILES)
    ls -l $(RELEASE_TAR)

#################################################################
# Правила для примеров из первой главы.
#
# Все каталоги с примерами.
EXAMPLES :=
    ch01-bogus-tab
    ch01-cw1
    ch01-hello
    ch01-cw2
    ch01-cw2a
    ch02-cw3
    ch02-cw4
    ch02-cw4a
    ch02-cw5
    ch02-cw5a
    ch02-cw5b
    ch02-cw6
    ch02-make-clean
    ch03-assert-not-null
    ch03-debug-trace
    ch03-debug-trace-1
    ch03-debug-trace-2
    ch03-filter-failure
    ch03-find-program-1
    ch03-find-program-2
    ch03-findstring-1
    ch03-grep
    ch03-include
    ch03-invalid-variable
    ch03-kill-acroread
    ch03-kill-program
    ch03-letters
    ch03-program-variables-1
    ch03-program-variables-2
    ch03-program-variables-3
    ch03-program-variables-5
    ch03-scoping-issue
    ch03-shell
    ch03-trailing-space
    ch04-extent
    ch04-for-loop-1
    ch04-for-loop-2
    ch04-for-loop-3
    ch06-simple
    appb-defstruct
    appb-arithmetic

# Я бы с удовольствием использовал этот цикл foreach, но ошибка
# в версии 3.80 приводит к аварийному останову.
#$(foreach e,$(EXAMPLES),$(eval $(call generic-program-example,$e)))

# Вместо этого приходитя раскрывать цикл вручную:
$(eval $(call generic-program-example,ch01-bogus-tab))
$(eval $(call generic-program-example,ch01-cw1))
$(eval $(call generic-program-example,ch01-hello))
$(eval $(call generic-program-example,ch01-cw2))
$(eval $(call generic-program-example,ch01-cw2a))
$(eval $(call generic-program-example,ch02-cw3))
$(eval $(call generic-program-example,ch02-cw4))
$(eval $(call generic-program-example,ch02-cw4a))
$(eval $(call generic-program-example,ch02-cw5))
$(eval $(call generic-program-example,ch02-cw5a))
$(eval $(call generic-program-example,ch02-cw5b))
$(eval $(call generic-program-example,ch02-cw6))
$(eval $(call generic-program-example,ch02-make-clean))
$(eval $(call generic-program-example,ch03-assert-not-null))
$(eval $(call generic-program-example,ch03-debug-trace))
$(eval $(call generic-program-example,ch03-debug-trace-1))
$(eval $(call generic-program-example,ch03-debug-trace-2))
$(eval $(call generic-program-example,ch03-filter-failure))
$(eval $(call generic-program-example,ch03-find-program-1))
$(eval $(call generic-program-example,ch03-find-program-2))
$(eval $(call generic-program-example,ch03-findstring-1))
$(eval $(call generic-program-example,ch03-grep))
$(eval $(call generic-program-example,ch03-include))
$(eval $(call generic-program-example,ch03-invalid-variable))
$(eval $(call generic-program-example,ch03-kill-acroread))
$(eval $(call generic-program-example,ch03-kill-program))
$(eval $(call generic-program-example,ch03-letters))
$(eval $(call generic-program-example,ch03-program-variables-1))
$(eval $(call generic-program-example,ch03-program-variables-2))
$(eval $(call generic-program-example,ch03-program-variables-3))
$(eval $(call generic-program-example,ch03-program-variables-5))
$(eval $(call generic-program-example,ch03-scoping-issue))
$(eval $(call generic-program-example,ch03-shell))
$(eval $(call generic-program-example,ch03-trailing-space))
$(eval $(call generic-program-example,ch04-extent))
$(eval $(call generic-program-example,ch04-for-loop-1))
$(eval $(call generic-program-example,ch04-for-loop-2))
$(eval $(call generic-program-example,ch04-for-loop-3))
$(eval $(call generic-program-example,ch06-simple))
$(eval $(call generic-program-example,ch10-echo-bash))
$(eval $(call generic-program-example,appb-defstruct))
$(eval $(call generic-program-example,appb-arithmetic))

#################################################################
# validate
#
# Производит проверку
# a) неподставленных макросов m4;
# b) символов табуляций;
# c) комментариев FIXME;
# d) RM: мои ответы Энди;
# e) дубликатов макросов m4.
#
validation_checks := $(OUTPUT_DIR)/chk_macros_tabs      \
                     $(OUTPUT_DIR)/chk_fixme            \
                     $(OUTPUT_DIR)/chk_duplicate_macros \
                     $(OUTPUT_DIR)/chk_orphaned_examples

.PHONY: validate-only
validate-only: $(OUTPUT_DIR)/validate
$(OUTPUT_DIR)/validate: $(validation_checks)
    $(TOUCH) $@

$(OUTPUT_DIR)/chk_macros_tabs: $(ALL_XML_OUT)
    # Ищем макросы и символы табуляции...
    $(QUIET)! $(EGREP) --ignore-case          \
                       --line-number          \
                       --regexp='\b(m4_|mp_)' \
                       --regexp='\011'
                       $^
    $(TOUCH) $@

$(OUTPUT_DIR)/chk_fixme: $(ALL_XML_OUT)
    # Ищем комментарии RM: и FIXME...
    $(QUIET)$(AWK)                                                \
            '/FIXME/  { printf "%s:%s: %s\n", FILENAME, NR, $$0 } \
             /^ *RM:/ {                                           \
                        if ( $$0 !~ /RM: Done/ )                  \
                        printf "%s:%s: %s\n", FILENAME, NR, $$0   \
                      }' $(subst $(OUTPUT_DIR)/,$(SOURCE_DIR)/,$^) 
    $(TOUCH) $@ 

$(OUTPUT_DIR)/chk_duplicate_macros: $(SOURCE_DIR)/macros.m4
    # Ищем повторные определения макросов...
    $(QUIET)! $(EGREP) --only-matching              \
        "\`[^']+'," $< |                            \
    $(SORT) |                                       \
    uniq -c |                                       \
    $(AWK) '$$1 > 1 { printf "$<:0: %s\n", $$0 }' | \
    $(EGREP) "^"
    $(TOUCH) $@

ALL_EXAMPLES := $(TMP)/all_examples

$(OUTPUT_DIR)/chk_orphaned_examples: $(ALL_EXAMPLES) $(DEPENDENCY_FILES)
    $(QUIET)$(AWK) -F/ '/(EXAMPLES|OUTPUT)_DIR/ { print $$3 }' \
            $(filter %.d,$^) |                                 \
    $(SORT) -u |                                               \
    comm -13 - $(filter-out %.d,$^)
    $(TOUCH) $@

.INTERMEDIATE: $(ALL_EXAMPLES)
$(ALL_EXAMPLES):
    # Ищем неиспользуемые примеры...
    $(QUIET) ls -p $(EXAMPLES_DIR) | \
    $(AWK) '/CVS/ { next }           \
            /\// { print substr($$0, 1, length - 1) }' > $@
#################################################################
# clean
#
clean:
    $(kill-acroread)
    $(RM) -r $(OUTPUT_DIR)
    $(RM) $(SOURCE_DIR)/*~ $(SOURCE_DIR)/*.log semantic.cache
    $(RM) book.pdf

#################################################################
# Управление зависимостями
#
# Если выполняется цель clean, не генерируем и не читаем
# включаемые файлы.
#
ifneq "$(MAKECMDGOALS)" "clean"
  -include $(DEPENDENCY_FILES)
endif

vpath %.xml $(SOURCE_DIR)
vpath %.tif $(SOURCE_DIR)
vpath %.eps $(SOURCE_DIR)

$(OUTPUT_DIR)/%.xml: %.xml $(process-pgm) $(m4-macros)
    $(call process-includes, $<, $@)

$(OUTPUT_DIR)/%.tif: %.tif
    $(CP) $< $@

$(OUTPUT_DIR)/%.eps: %.eps
    $(CP) $< $@

$(OUTPUT_DIR)/%.d: %.xml $(make-depend)
    $(make-depend) $< > $@

#################################################################
# Создание каталогов для вывода
#
# Создаём каталоги для вывода по мере необходимости.
#
DOCBOOK_IMAGES := $(OUTPUT_DIR)/release/images
DRAFT_PNG      := /usr/share/docbook-xsl/images/draft.png

ifneq "$(MAKECMDGOALS)" "clean"
  _CREATE_OUTPUT_DIR :=                                                 \
    $(shell                                                             \
      $(MKDIR) $(DOCBOOK_IMAGES) &                                      \
      $(CP) $(DRAFT_PNG) $(DOCBOOK_IMAGES);                             \
      if ! [[ $(foreach d,                                              \
                $(notdir                                                \
                  $(wildcard $(EXAMPLES_DIR)/ch*)),                     \
                -e $(OUTPUT_DIR)/$d &) -e . ]];                         \
      then                                                              \
        echo Компоновка примеров... > /dev/stderr;                \
        $(LNDIR) $(BOOK_DIR)/$(EXAMPLES_DIR) $(BOOK_DIR)/$(OUTPUT_DIR); \
      fi)
endif
\end{verbatim}

Этот \Makefile{} написан для запуска в Cygwin без серьёзных претензий
на переносимость в \UNIX{}. Тем не менее, я уверен, что в нём очень
мало несовместимостей с \UNIX{} (если вообще есть), которые нельзя
было бы решить переопределением значений переменных или, возможно,
введением новых переменных.

Раздел глобальных переменных определяет расположение корневого
каталога и относительные пути к каталогам с текстом книги, примерами и
каталогу для вывода. Имя каждой нетривиальной программы, используемой
в \makefile{е}, определяется соответствующей переменной.

%---------------------------------------------------------------------
% Managing Examples
%---------------------------------------------------------------------
\subsection{Управление примерами}

Первая задача (управление примерами) является самой сложной. Каждый
пример располагается в собственном подкаталоге каталога
\filename{book/examples/chn-<title>}. Каждый пример содержит
собственный \Makefile{}. Для обработки примера мы сначала создаём
каталог, содержащий символические ссылки на деревья каталогов выходных
файлов, и работаем в нём. Потому артифакты, созданные в процессе
работы \GNUmake{}, не попадают в дерево каталогов с исходным
кодом. Более того, б\'{о}льшая часть примеров для корректной работы
требует, чтобы текущим рабочим каталогом был каталог с их
\makefile{ом}. После создания символических ссылок на каталоги с
исходным кодом мы выполняем сценарий командного интерпретатора,
\command{run-make}, вызывающий \Makefile{} с правильными
аргументами. Если в каталоге с исходным кодом нет такого сценария, мы
выполняем стандартную версию сценария. Вывод сценария
\command{run-make} сохраняется в файле \filename{make.out}. Некоторые
примеры порождают исполняемые файлы, которые также нужно
выполнить. Эта работа выполняется сценарием \command{run-run}, его
вывод сохраняется в файле \filename{run.out}.

Создание каталога с символическими ссылками осуществляется следующим
кодом, находящимся в конце \makefile{а}:

\begin{verbatim}
ifneq "$(MAKECMDGOALS)" "clean"
  _CREATE_OUTPUT_DIR :=                                                 \
    $(shell                                                             \
      $(MKDIR) $(DOCBOOK_IMAGES) &                                      \
      $(CP) $(DRAFT_PNG) $(DOCBOOK_IMAGES);                             \
      if ! [[ $(foreach d,                                              \
                $(notdir                                                \
                  $(wildcard $(EXAMPLES_DIR)/ch*)),                     \
                -e $(OUTPUT_DIR)/$d &) -e . ]];                         \
      then                                                              \
        echo Компоновка примеров... > /dev/stderr;                \
        $(LNDIR) $(BOOK_DIR)/$(EXAMPLES_DIR) $(BOOK_DIR)/$(OUTPUT_DIR); \
      fi)
endif
\end{verbatim}

Этот код осуществляет одно присваивание простой переменной, обёрнутое
в директиву условной обработки \directive{ifneq}. Условная директива
нужна для того, чтобы \GNUmake{} не создавал структуру каталогов в
случае запуска команды \command{make clean}. На самом деле, переменная
является фиктивной: её значение никогда не используется. Тем не менее,
функция \function{shell} справа от оператора присваивания выполняется
в процессе чтения \makefile{а}. Эта функция проверяет существование
каталога каждого примера в дереве выходных файлов. В случае отсутствия
какого-либо каталога вызывается команда \utility{lndir}, обновляющая
каталог с символическими ссылками.

Тест, выполняемый командой \command{if}, заслуживает более тщательного
анализа. Он состоит из одной проверки \command{-e} (существует ли
каталог?) для каталога каждого из примеров. Реальный код выглядит
примерно следующим образом: для нахождения всех примеров используется
функция \function{wildcard}, затем имена каталогов примеров отсекаются
функцией \function{notdir}, после чего для каждого каталога создаётся
текст \command{-e \$(OUTPUT\_DIR)/\textit{каталог} \&\&}. Все эти
элементы объединяются и подставляются в условие \command{bash
  [[\ldots{}]]}. Наконец, результат проверки условия
инвертируется. Одно дополнительное условие, \command{-e .}, включается
в качестве граничного условия, чтобы позволить циклу
\function{foreach} просто добавить \command{\&\&} к каждому выражению.

Этого достаточно для того, чтобы убедится в том, что новые каталоги
всегда будут включены в процесс сборки при обнаружении.

Следующим шагом является создание правил, обновляющие два выходных
файла, \filename{make.out} и \filename{run.out}. Это осуществляется
для \filename{.out} файлов всех примеров при помощи следущей функции:

\begin{verbatim}
# $(call generic-program-example,example-directory)
# Создаёт общие правила сборки примера.
define generic-program-example
  $(eval $1_dir      := $(OUTPUT_DIR)/$1)
  $(eval $1_make_out := $($1_dir)/make.out)
  $(eval $1_run_out  := $($1_dir)/run.out)
  $(eval $1_clean    := $($1_dir)/clean)
  $(eval $1_run_make := $($1_dir)/run-make)
  $(eval $1_run_run  := $($1_dir)/run-run)
  $(eval $1_sources  := $(filter-out %/CVS, \
                          $(wildcard $(EXAMPLES_DIR)/$1/*)))
  $($1_run_out): $($1_make_out) $($1_run_run)
      $$(call run-script-example, $($1_run_run), $$@)

  $($1_make_out): $($1_clean) $($1_run_make)
      $$(call run-script-example, $($1_run_make), $$@)

  $($1_clean): $($1_sources) Makefile
      $(RM) -r $($1_dir)
      $(MKDIR) $($1_dir)
      $(LNDIR) -silent ../../$(EXAMPLES_DIR)/$1 $($1_dir)
      $(TOUCH) $$@

  $($1_run_make):
      printf "#! /bin/bash -x\nmake\n" > $$@
endef
\end{verbatim}

Эта функция должна быть вызвана единожды с именем каталога каждого
примера в качестве аргумента:

\begin{verbatim}
$(eval $(call generic-program-example,ch01-bogus-tab))
$(eval $(call generic-program-example,ch01-cw1))
$(eval $(call generic-program-example,ch01-hello))
$(eval $(call generic-program-example,ch01-cw2))
\end{verbatim}

%---------------------------------------------------------------------
% XML Processing
%---------------------------------------------------------------------
\subsection{Обработка XML}

Рискуя выставить себя перед потомками в дурном свете, хочу сообщить,
что я не очень люблю формат XML. Я нахожу его неуклюжим и
многословным. Поэтому когда я узнал, что рукопись должна быть написана
в DocBook, я начал поиск более традиционных инструментов, которые
смогли бы упростить мою работу. Препроцессор \utility{m4} и
\utility{awk}~--- два инструмента, которые мне очень помогли.

Есть две проблемы, связанные с DocBook и XML, с которыми \utility{m4}
отлично справляется: неудобство многословного синтаксиса XML и
необходимость управления идентификаторами, используемыми в
перекрёстных ссылках. К примеру, чтобы выделить слово в DocBook, вам
нужно написать:

\begin{verbatim}
<emphasis>not</emphasis>
\end{verbatim}

Используя \utility{m4}, я написал простой макрос, позволяющий записать
тоже самое следующим образом:

\begin{verbatim}
mp_em(not)
\end{verbatim}

Да, так уже лучше. В добавок я ввёл множество символических стилей
форматирования, таких как \command{mp\_variable} и
\command{mp\_target}. Это позволило мне выбрать тривиальный формат для
этих сущностей (к примеру, отсутсвие выделения) и изменять его позже
по желанию редактора без необходимости осуществлять поиск и замену по
всему документу.

Возможно, поклонники XML завалят меня письмами с описанием решения
этой задачи средствами XML (с помощью XML-сущностей или чего-нибудь в
этом роде). Однако не стоит забывать, что \UNIX{} нужен, чтобы решать
текущие задачи теми инструментами, которые у тебя есть. Как любит
говорить Ларри Уолл (Larry Wall), <<Есть более одного способа сделать
это>>(<<There is more then one way to do it>>). Кроме того, я
опасаюсь, что чрезмерное изучение XML заморочит мне голову.

Вторая задача для \utility{m4}~--- управление XML-идентификаторами,
используемыми в перекрёстных ссылках. Каждая глава, раздел, пример и
таблица имеют свой идентификатор:

\begin{verbatim}
<sect1 id="MPWM-CH-7-SECT-1">
\end{verbatim}

Ссылки на раздел должны использовать этот идентификатор. С точки
зрения программирования эта проблема довольно ясна. Идентификаторы
являются сложными константами, расбросанными по всему <<коду>>. Более
того, символы сами по себе не имеют значения. Я не имею понятия, о чём
может идти речь в первом разделе седьмой главы. Используя
\utility{m4}, я могу избежать дублирования сложных идентификаторов,
используя вместо них имеющие смысл имена:

\begin{verbatim}
<sect1 id="mp_se_makedepend">
\end{verbatim}

Что более важно, при смене нумерации разделов или глав (что в процессе
написания книги происходило много раз) идентификатор нужно будет
поменять только в одном файле. Это преимущество наиболее ощутимо при
смене нумерации разделов в главе. Если бы я не ввёл символические
ссылки, подобная операция могла бы потребовать полудюжены операций
поиска и замены по всем тексту книги.

Вот несколько примеров макросов \utility{m4}\AuthorFootnote{Префикс
  \command{mp} является сокращением Managing Projects (название
  книги), слова macro processor (макро-процессор) или make pretty
  (буквально <<сделай красивым>>). Выберите наиболее понравившийся вам
  вариант}:
\begin{verbatim}
m4_define(`mp_tag',    `<$1>`$2'</$1>')
m4_define(`mp_lit',    `mp_tag(literal, `$1')')
m4_define(`mp_cmd',    `mp_tag(command,`$1')')
m4_define(`mp_target', `mp_lit($1)')
m4_define(`mp_all',    `mp_target(all)')
m4_define(`mp_bash',   `mp_cmd(bash)')
m4_define(`mp_ch_examples',     `MPWM-CH-11')
m4_define(`mp_se_book',         `MPWM-CH-11.1')
m4_define(`mp_ex_book_makefile',`MPWM-CH-11-EX-1')
\end{verbatim}

Ещё одной задачей предварительной обработки была реализация
возможности включения текста примеров. Этот текст требует замены
символов табуляций пробелами (посколько конвертер DocBook O'Reilly не
может обрабатывать символы табуляции, а в \makefile{ах} их полно),
обёртки содержимого в \verb|<![CDATA[...]]>| для экранирования
специальных символов, и, наконец, отсечения лишних символов переноса
строки в начале и конце текста примеров. Я смог решить эту задачу
благодаря следующей небольшой программе на \utility{awk}, которую я
назвал \utility{process-includes}:

\begin{verbatim}
#! /usr/bin/awk -f
function expand_cdata( dir )
{
  start_place = match( $1, "include-" )
  if ( start_place > 0 )
  {
    prefix = substr( $1, 1, start_place - 1 )
  }
  else
  {
    print "Bogus include '" $0 "'" > "/dev/stderr"
  }
  end_place = match( $2, "(</(programlisting|screen)>.*)$", tag )

  if ( end_place > 0 )
  {
    file = dir substr( $2, 1, end_place - 1 )
  }
  else
  {
    print "Bogus include '" $0 "'" > "/dev/stderr"
  }

  command = "expand " file

  printf "%s>&33;&91;CDATA[", prefix
  tail = 0
  previous_line = ""
  while ( (command | getline line) > 0 )
  {
    if ( tail )
      print previous_line;

    tail = 1
    previous_line = line
  }

  printf "%s&93;&93;&62;%s\n", previous_line, tag[1]
  close( command )
}

/include-program/ {
  expand_cdata( "examples/" )
  next;
}

/include-output/ {
  expand_cdata( "out/" )
  next;
}

/<(programlisting|screen)> *$/ {
  # Find the current indentation.
  offset = match( $0, "<(programlisting|screen)>" )

  # Strip newline from tag.
  printf $0

  # Read the program...
  tail = 0
  previous_line = ""
  while ( (getline line) > 0 )
  {
    if ( line ~ "</(programlisting|screen)>" )
    {
      gsub( /^ */, "", line )
      break
    }
    if ( tail )
      print previous_line

    tail = 1
    previous_line = substr( line, offset + 1 )
  }

  printf "%s%s\n", previous_line, line

  next
}

{
  print
}
\end{verbatim}

Мы копируем XML-файлы из дерева каталогов с исходными файлами в
каталог с выходными файлами, заменяем символы табуляции пробелами,
производим подстановку макросов и производим включение файлов
примеров:

\begin{verbatim}
process-pgm := bin/process-include
m4-macros   := text/macros.m4

# $(call process-includes, input-file, output-file)
# Осуществляет замену символов табуляции пробелами,
# подстановку макросов и обработку директив включения.
define process-includes
  expand $1 |                                             \
  $(M4) --prefix-builtins --include=text $(m4-macros) - | \
  $(process-pgm) > $2
endef

vpath %.xml $(SOURCE_DIR)

$(OUTPUT_DIR)/%.xml: %.xml $(process-pgm) $(m4-macros)
    $(call process-includes, $<, $@)
\end{verbatim}

Шаблонное правило определяет способ составления выходного XML-файла из
исходного XML-файла. Оно также декларирует, что все выходные XML-файлы
должны быть составлены заново, если макросы или файл сценария
включения изменились.

%---------------------------------------------------------------------
% Generating Output
%---------------------------------------------------------------------
\subsection{Генерация документов}

Пока весь код, который мы разобрали, не выполняет непосредственного
форматирования текста и не производит документов, которые можно было
бы напечатать или отобразить на экране. Очевидно, самой важной
функцией \makefile{а} является создание книги. Я заинтересован в двух
выходных форматах: HTML и PDF.

Сначала мы рассмотрим, как происходит формарование HTML. Для этой
задачи я использовал замечательную программу \utility{xsltproc} и
небольшой вспомогательный сценарий \utility{xmlto}. Эти инструменты
делают процесс трансформации достаточно простым:

\begin{verbatim}
# Выходные форматы книги
BOOK_XML_OUT  := $(OUTPUT_DIR)/book.xml
BOOK_HTML_OUT := $(subst xml,html,$(BOOK_XML_OUT))

ALL_XML_SRC   := $(wildcard $(SOURCE_DIR)/*.xml)
ALL_XML_OUT   := $(call source-to-output,$(ALL_XML_SRC))

# html - Создаёт книгу в предпочтительном формате.
.PHONY: html
html: $(BOOK_HTML_OUT)

# show_html - Создаёт html-файл и отображает его.
.PHONY: show_html
show_html: $(BOOK_HTML_OUT)
    $(HTML_VIEWER) $(BOOK_HTML_OUT)

# $(BOOK_HTML_OUT) - Создаёт html file
$(BOOK_HTML_OUT): $(ALL_XML_OUT) $(OUTPUT_DIR)/validate Makefile

# %.html - Шаблонное правило для создания html из xml.
%.html: %.xml
    $(XMLTO) $(XMLTO_FLAGS) html-nochunks $<
\end{verbatim}

Шаблонное правило выполняет основную работу по конвертированию
XML-файла в HTML-файл. Книга организована в виде одного главного
файла, \filename{book.xml}, который включает файлы каждой главы. Имя
главного файла содержится в переменной
\variable{BOOK\_XML\_OUT}. HTML-аналогом является файл
\variable{BOOK\_HTML\_OUT}, являющийся целью в \makefile{е}. XML-файлы
являются реквизитами \variable{BOOK\_HMLT\_OUT}. Для удобства
определены две абстрактные цели: \target{html} и \target{show\_html}.
Первая цель создаёт HTML-файл, а вторая отображает его в браузере.

Несмотря на простоту идеи, создание PDF-файлов~--- значительно более
сложная операция. Программа \utility{xsltproc} может создавать
PDF-файлы непосредственно, но у меня так и не получилось реализовать
такой сценарий. Вся работа осуществлялась под управлением Cygwin в
Windows, а Cygwin-версия \utility{xsltproc} работает только с
\POSIX{}-путями. Специфическая версия DocBook, используемая мной, а
также вся рукопись, использовали специфичные для Windows пути. Это
отличие, насколько я понимаю, помешало \utility{xsltproc} выполнить
свою работу. Вместо этого я решил использовать \utility{xsltproc} для
генерации FO-XML файлов, которые Java-программа FOP
(\url{http://xml.apache.org/fop}) может конвертировать в PDF.

Поэтому код генерации PDF немного длиннее:

\begin{verbatim}
# Выходные форматы
BOOK_XML_OUT := $(OUTPUT_DIR)/book.xml
BOOK_FO_OUT  := $(subst xml,fo,$(BOOK_XML_OUT))
BOOK_PDF_OUT := $(subst xml,pdf,$(BOOK_XML_OUT))
ALL_XML_SRC  := $(wildcard $(SOURCE_DIR)/*.xml)
ALL_XML_OUT  := $(call source-to-output,$(ALL_XML_SRC))

# pdf - Верстает книгу в предпочтительном формате.
.PHONY: pdf
pdf: $(BOOK_PDF_OUT)

# show_pdf - Формирует pdf документ и отображает его.
.PHONY: show_pdf
show_pdf: $(BOOK_PDF_OUT)
    $(kill-acroread)
    $(PDF_VIEWER) $(BOOK_PDF_OUT)

# $(BOOK_PDF_OUT) - Формирует pdf-файл.
$(BOOK_PDF_OUT): $(BOOK_FO_OUT) Makefile

# $(BOOK_FO_OUT) - Формирует промежуточный fo-файл.
.INTERMEDIATE: $(BOOK_FO_OUT)
$(BOOK_FO_OUT): $(ALL_XML_OUT) $(OUTPUT_DIR)/validate Makefile

#################################################################
# Поддержка FOP
#
FOP := org.apache.fop.apps.Fop

# DEBUG_FOP - Определите этот макрос для просмотра вывода fop.
ifndef DEBUG_FOP
  FOP_FLAGS := -q
  FOP_OUTPUT := | $(SED) -e '/not implemented/d'       \
                         -e '/relative-align/d'        \
                         -e '/xsl-footnote-separator/d'
endif

# CLASSPATH - Compute the appropriate CLASSPATH for fop.
export CLASSPATH
CLASSPATH = $(patsubst %;,%,                                \
              $(subst ; ,;,                                 \
                $(addprefix c:/usr/xslt-process-2.2/java/,  \
                  $(addsuffix .jar;,                        \
                    xalan                                   \
                    xercesImpl                              \
                    batik                                   \
                    fop                                     \
                    jimi-1.0                                \
                    avalon-framework-cvs-20020315))))

# %.pdf - Шаблонное правило создания pdf из fo.
%.pdf: %.fo
    $(kill-acroread)
    java -Xmx128M $(FOP) $(FOP_FLAGS) $< $@ $(FOP_OUTPUT)

# %.fo - Шаблонное правило для создания fo из xml.
PAPER_SIZE := letter
%.fo: %.xml
    XSLT_FLAGS="--stringparam paper.type $(PAPER_SIZE)" \
    $(XMLTO) $(XMLTO_FLAGS) fo $<

# fop_help - Отображение справки по использованию fop.
.PHONY: fop_help
fop_help:
    -java org.apache.fop.apps.Fop -help
    -java org.apache.fop.apps.Fop -print help
\end{verbatim}

Как вы можете видеть, для отображения двух-фазового процесса сборки
используется два шаблонных правила. Правило \filename{.xml}
$\rightarrow$ \filename{.fo} вызывает \utility{xmlto}, правило
\filename{.fo} $\rightarrow$ \filename{.pdf} сначала закрывает все
открытые окна приложения \utility{Acrobat reader} (поскольку это
приложение блокирует PDF-файлы, не позволяя приложению FOP
перезаписать их), а затем запускает FOP. Поскольку программа FOP
весьма <<болтлива>>, а просмотр сотен строк бессмысленных
предупреждений меня быстро утомил, я добавил простой
\utility{sed}-фильтр, \variable{FOP\_OUTPUT}, чтобы удалить эти
разражающие предупреждения. Тем не менее, иногда эти сообщения
содержали что-то действительно полезное, поэтому я добавил отладочную
переменную \variable{DEBUG\_FOP}, которая отключает мой
фильтр. Наконец, как и в случае с HTML-версией, я включил пару удобных
целей, \target{pdf} и \target{show\_pdf}.


%---------------------------------------------------------------------
% Validating the Source
%---------------------------------------------------------------------
\subsection{Проверка исходного кода}

Учитывая аллергию DocBook на символы табуляции, инструкции
макропроцессора и комментарии редакторов, проверка корректности
исходного текста становится нетривиальной задачей. Чтобы упростить
этот процесс, я реализовал четыре цели, задачей которых является
проверка различных аспектов корректности документов.

\begin{verbatim}
validation_checks := $(OUTPUT_DIR)/chk_macros_tabs      \
                     $(OUTPUT_DIR)/chk_fixme            \
                     $(OUTPUT_DIR)/chk_duplicate_macros \
                     $(OUTPUT_DIR)/chk_orphaned_examples

.PHONY: validate-only
validate-only: $(OUTPUT_DIR)/validate
$(OUTPUT_DIR)/validate: $(validation_checks)
    $(TOUCH) $@
\end{verbatim}

Каждая цель создаёт собственный файл с временной меткой, все такие
файлы являются реквизитами основного файла \filename{validate}.

\begin{verbatim}
$(OUTPUT_DIR)/chk_macros_tabs: $(ALL_XML_OUT)
    # Ищем макросы и символы табуляции...
    $(QUIET)! $(EGREP) --ignore-case          \
                       --line-number          \
                       --regexp='\b(m4_|mp_)' \
                       --regexp='\011'        \
                       $^
    $(TOUCH) $@
\end{verbatim}

Первая проверка производит поиск макросов \utility{m4}, подстановка
которых по каким-то причинам не была осуществлена на этапе
предварительной обработки. Это указывает либо на ошибку в имени
макроса, либо на то, что макрос не был определён. Также производится
поиск символов табуляции. Разумеется, ни одна их этих ситуаций не
должна произойти, но прецеденты были. Одной из интересных деталей
является использование восклицательного знака после
\command{\$(QUIET)}. Назначение этого восклицательного знака~---
инвертировать код возврата команды \utility{egrep}. \GNUmake{} должен
считать команду ошибочной, если \utility{egrep} \emph{обнаружит}
вхождение шаблона.

\begin{verbatim}
$(OUTPUT_DIR)/chk_fixme: $(ALL_XML_OUT)
    # Ищем комментарии RM: и FIXME...
    $(QUIET)$(AWK)
            '/FIXME/ { printf "%s:%s: %s\n", FILENAME, NR, $$0 } \
             /^ *RM:/ {                                          \
                      if ( $$0 !~ /RM: Done/ )                   \
                      printf "%s:%s: %s\n", FILENAME, NR, $$0    \
                    }' $(subst $(OUTPUT_DIR)/,$(SOURCE_DIR)/,$^)
    $(TOUCH) $@
\end{verbatim}

Этот отрывок осуществяет поиск не исправленных мною заметок. Очевидно,
любой текст, помеченный тегом \command{FIXME}, должен быть исправлен,
а метка должна быть удалена. В добавок к этому, система должна
оповещать при обнаружении вхождений метки \command{RM:}, за которой не
следует сразу метка \command{Done}. Обратите внимание, что формат
выдачи \function{printf} соответствует стандартному формату выдачи
ошибок компиляции. Благодаря этому стандартные инструменты
распознавания ошибок компиляции будут правильно обрабатывать эти
предупреждения.

\begin{verbatim}
$(OUTPUT_DIR)/chk_duplicate_macros: $(SOURCE_DIR)/macros.m4
    # Ищем повторные определения макросов...
    $(QUIET)! $(EGREP) --only-matching              \
        "\[^]+'," $< |                              \
    $(SORT) |                                       \
    uniq -c |                                       \
    $(AWK) '$$1 > 1 { printf "$>:0: %s\n", $$0 }' | \
    $(EGREP) "^"
    $(TOUCH) $@
\end{verbatim}

Этот отрывок осуществляет поиск повторных определений в файле
\filename{macros.m4}. Процессор макросов не считает повторное
определение макроса ошибкой, поэтому я решил выполнять эту проверку
самостоятельно. Проверка представляет из себя следующий конвеер: поиск
объявлений макросов, сортировка имён по алфавиту, вычисление
количества дубликатов, отсев строк, встречающихся только один раз,
прогон через \utility{egrep} исключительно ради кода возврата. Ещё раз
обратите внимание на инвертирование кода возврата: \GNUmake{} должен
сообщить об ошибке только только в том случае, если дубликаты будут
обнаружены.

\begin{verbatim}
ALL_EXAMPLES := $(TMP)/all_examples

$(OUTPUT_DIR)/chk_orphaned_examples: $(ALL_EXAMPLES) $(DEPENDENCY_FILES)
    $(QUIET)$(AWK) -F/ '/(EXAMPLES|OUTPUT)_DIR/ { print $$3 }' \
            $(filter %.d,$^) |                                 \
    $(SORT) -u |                                               \
    comm -13 - $(filter-out %.d,$^)
    $(TOUCH) $@

.INTERMEDIATE: $(ALL_EXAMPLES)
$(ALL_EXAMPLES):
    # Ищем неиспользованные примеры...
    $(QUIET) ls -p $(EXAMPLES_DIR) |  \
    $(AWK) '/CVS/ { next }            \
            /\// { print substr($$0, 1, length - 1) }' > $@
\end{verbatim}

Последняя проверка осуществляет поиск примеров, на которые нет ссылок
в тексте. Эта цель использует интересный приём. Она требует наличия
двух наборов файлов: каталогов всех примеров и файлов зависимостей
XML-файлов. Список реквизитов разбивается на два набора с помощью
функций \function{filter} и \function{filter-out}. Список каталогов с
примерами генерируется с помощью вызова \command{ls -p} (это команда
добавляет слеш к именам каталогов) и поиска слешей в её
выводе. Сначала осуществляется поиск файлов зависимостей в списке
реквизитов, затем производится вывод найденных каталогов и удаление
дубликатов. Это примеры, ссылки на которые есть в тексте. Полученный
список отправляется на стандартных вход программе \utility{comm}, а
список всех известных каталогов с примерами помещается во второй
файл. Опция \command{-13} означает, что \utility{comm} должна печатать
только строки из второй колонки (т.е. каталоги, на которые нет ссылок
в файле зависимостей).
