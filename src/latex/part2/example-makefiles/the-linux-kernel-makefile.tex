%%--------------------------------------------------------------------
%% The Linux Kernel Makefile
%%--------------------------------------------------------------------
\section{\Makefile{} ядра Linux}

\Makefile{} ядра Linux является отличным примером использования
\GNUmake{} для сборки в рамках сложной инфраструктуры. Поскольку целью
этой книги не является описание сруктуры и процесса сборки ядра Linux,
мы рассмотим лишь несколько интересных применений \GNUmake{} внутри
системы сборки ядра. Более подробное обсуждением системы сборки ядра
версий 2.5/2.6 и эволюции этой системы по сравнению с версией 2.4 вы
можете найти по адресу
\url{http://macarchive.linuxsymposium.org/ols2003/Proceedings/All-Reprints/Reprint-Germaschewski-OLS2003.pdf}.

Поскольку упомянутый \Makefile{} имеет так много аспектов, мы обсудим
лишь некоторые из тех, что могут быть использованы в различных
приложениях. Сначала мы рассмотрим, как однобуквенные переменные
\GNUmake{} используются для симуляции ключей командной строки. Мы
также увидим, как деревья каталогов с исходными и с бинарными файлами
разделяются таким образом, что пользователи могут вызывать \GNUmake{}
из каталога с исходным кодом. Затем мы исследуем методику, позволяющую
\makefile{у} контролировать степень детализации вывода. Далее, мы
рассмотрим наиболее интересные функции, определяемые пользователем, и
увидим, как они сокращают дублирование кода, улучшают читаемость кода
и предоставляют инкапсуляцию. Наконец, мы рассмотрим базовый
функционал справки, реализованный с помощью \GNUmake{}.

Ядро Linux следует известному шаблону \textit{конфигурация, сборка,
  установка}, применяемому большинством проектов свободного
программного обеспечения. В то время как множество открытых проектов
используют отдельный сценарий \filename{con\-fi\-gure} (обычно
созданный при помощи \utility{autoconf}), ядро Linux реализует стадию
конфигурации с помощью \GNUmake{}, вызывая внешние сценарии и
вспомогательные программы неявно.

Когда стадия конфигурации завершена, команда \command{make} или
\command{make all} собирает ядро, все модули и создаёт сжатый образ
ядра (цели \target{vmlinux}, \target{modules} и
\target{bzImage}, соответственно). Каждой сборке ядра присваивается
уникальный номер, хранящийся в файле \filename{version.o},
прилинкованный к ядру. Это число (и файл \filename{version.o})
обновляются средствами самого \makefile{а}.

%---------------------------------------------------------------------
% Command-Line Options
%---------------------------------------------------------------------
\subsection{Опции командной строки}
Первая часть \makefile{а} содержит код, устанавливающий общие опции
сборки, полученные из командной строки. Ниже приведена выдержка,
осуществляющая контроль флага детальности вывода:

\begin{verbatim}
# Чтобы предупреждения были более заметными, по-умолчанию
# отображается минимум сообщений
# Для более детального вывода используйте 'make V=1'
ifdef V
  ifeq ("$(origin V)", "command line")
    KBUILD_VERBOSE = $(V)
  endif
endif
ifndef KBUILD_VERBOSE
  KBUILD_VERBOSE = 0
endif
\end{verbatim}

Вложенная пара \directive{ifdef}/\directive{ifeq} проверяет, что
переменная \variable{KBUILD\_VERBOSE} выставляется только в том
случае, когда переменная \variable{V} была определена в командной
строке. Определение \variable{V} в окружении или внутри \makefile{а}
не возымеет эффекта. Следующая директива \directive{ifndef} выключает
флаг \variable{KBUILD\_VERBOSE}, если его значение ещё не было
определено. Чтобы включить флаг из окружения или \makefile{а}, вам
нужно явно определить значение переменной \variable{KBUILD\_VERBOSE},
а не \variable{V}.

Заметим, однако, что определение опции \variable{KBUILD\_VERBOSE} явно
в командной строке разрешено и работает именно так, как вы
ожидаете. Это может быть удобно для написания сценарев командного
интерпретатора (или псевдонимов команд) для вызова \makefile{а}. Такие
сценарии будут более самодокументурующими и похожими на использование
длинный опций GNU.

Другие опции командной строки, проверка анализатором \utility{sparse}
(\command{C}) и внешние модули (\command{M}), используют такую же
проверку, чтобы избежать случайного их переопределения внутри
\makefile{а}.

Следующая секция \makefile{а} производит оработку опции,
устанавливающей каталога вывода (\command{O}). Это довольно сложный
участок кода. Чтобы прояснить его структуру, мы заменим некоторые
части этого отрывка многоточиями:

\begin{verbatim}
# Система kbuild поддерживает сохранение выходных файлов в отдельном
# каталоге.
# Есть два пути воспользоваться этой возможностью. В обоих случаях
# рабочим каталогом должен быть каталог с исходным кодом ядра.
# 1) O=
# Используйте опцию O: "make O=dir/to/store/output/files/"
#
# 2) Определите  KBUILD_OUTPUT
# Определите переменную окружения KBUILD_OUTPUT так, чтобы она
# указывала на каталог, в который следует поместить выходные файлы.
# export KBUILD_OUTPUT=dir/to/store/output/files/
# make
#
# Опция O= имеет более высокий приоритет, чем переменная окружения
# KBUILD_OUTPUT.
# Переменная KBUILD_SRC выставляется в значение OBJ после старта make
# На данный момент не предполагается, что KBUILD_SRC будет
# использоваться пользователями без прав суперпользователя.
ifeq ($(KBUILD_SRC),)
  # OK, Make called in directory where kernel src resides
  # Do we want to locate output files in a separate directory?
  ifdef O
    ifeq ("$(origin O)", "command line")
      KBUILD_OUTPUT := $(O)
    endif
  endif
  ...
  ifneq ($(KBUILD_OUTPUT),)
    ...
    .PHONY: $(MAKECMDGOALS)
    $(filter-out _all,$(MAKECMDGOALS)) _all:
        $(if $(KBUILD_VERBOSE:1=),@)$(MAKE) -C $(KBUILD_OUTPUT)       \
        KBUILD_SRC=$(CURDIR)         KBUILD_VERBOSE=$(KBUILD_VERBOSE) \
        KBUILD_CHECK=$(KBUILD_CHECK) KBUILD_EXTMOD="$(KBUILD_EXTMOD)" \
        -f $(CURDIR)/Makefile $@
    # Leave processing to above invocation of make
    skip-makefile := 1
  endif # ifneq ($(KBUILD_OUTPUT),)
endif # ifeq ($(KBUILD_SRC),)

# Оставшаяся часть makefile обрабатывается только в том случае, если
# текущий вызов make - последний.
ifeq ($(skip-makefile),)
  ...the rest of the makefile here...
endif
# skip-makefile
\end{verbatim}

Вкратце, этот участок кода проверяет, определена ли переменная
\variable{KBUILD\_OUTPUT}, и, если это так, вызывает \GNUmake{}
рекурсивно в каталоге, являющимся значением переменной
\variable{KBUILD\_OUTPUT}, определяя переменную \variable{KBUILD\_SRC}
так, чтобы она содержала путь к каталогу, в котором \GNUmake{} был
выполнен в первый раз, используя исходный \Makefile{}. Также
выставляется флаг \variable{skip-makefile}, из-за чего оставшаяся
часть \makefile{а} не будет видна \GNUmake{}. Рекурсивный \GNUmake{}
прочтёт тот же самый \Makefile{} ещё раз, только в этот раз переменная
\variable{KBUILD\_SRC} будет определена, поэтому флаг
\variable{skip-makefile} не будет определён, и остаток \makefile{а}
будет прочитан и обработан.

На этом мы закончим рассмотрение опций командной строки. Большая часть
\makefile{а} находится в секции \command{ifeq(\$(skip-makefile),)}.

%---------------------------------------------------------------------
% Configuration Versus Building
%---------------------------------------------------------------------
\subsection{Конфигурация или сборка?}
\Makefile{} содержит цели для конфирурации и сборки. Конфигурационные
цели имеют форму \target{menuconfig}, \target{defconfig}, и
т.д. Вспомогательные цели, такие как \target{clean}, также трактуются
как конфигурационные цели. Другие цели, такие как \target{all},
\target{vmlinux} и \target{modules}, являются целями сборки. Главным
результатом вызова конфигурационных целей являются два файла:
\filename{.config} и \filename{.config.cmd}. Эти два файла включаются
\makefile{ом} для целей сборки и не включаются для конфигурационных
целей (поскольку именно конфигурационные цели создают эти
файлы). Возможно также смешивать конфигурационные цели и цели сборки в
одном вызове \GNUmake{}:

\begin{verbatim}
\$ make oldconfig all
\end{verbatim}

В этом случае \Makefile{} вызывает \GNUmake{} рекурсивно для
индивидуальной обработки каждой цели, таким образом обрабатывая
конфигурационные цели отдельно от целей сборки.

Ниже приводится начало участка кода, управляющего конфигурацией,
сборкой и смешением целей.

\begin{verbatim}
# Чтобы убедиться в том, что мы не включаем файл .config для
# конфигурационный целей, мы обрабатываем их заранее, передавая
# их scripts/kconfig/Makefile
# При вызове \GNUmake{} разрешается указывать несколько целей, а также
# смешивать конфигурационные цели и цели сборки.
# Пример: 'make oldconfig all'.
# Ситуацию со смешением целей нужно обрабатывать особым образом:
# производить повторный вызов make так, чтобы файл .config не
# включался для конфигурационных целей и в этом случае.

no-dot-config-targets := clean mrproper distclean \
                         cscope TAGS tags help %docs check%

config-targets := 0
mixed-targets  := 0
dot-config     := 1
\end{verbatim}

%---------------------------------------------------------------------
% Managing Command Echo
%---------------------------------------------------------------------
\subsection{Управление командой \command{echo}}

%---------------------------------------------------------------------
% User-Defined Functions
%---------------------------------------------------------------------
\subsection{Функции, опредённые пользователем}
