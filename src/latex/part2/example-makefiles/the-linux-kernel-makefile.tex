  %%--------------------------------------------------------------------
%% The Linux Kernel Makefile
%%--------------------------------------------------------------------
\section{\Makefile{} ядра Linux}

\Makefile{} ядра Linux является отличным примером использования
\GNUmake{} для сборки в рамках сложной инфраструктуры. Поскольку целью
этой книги не является описание сруктуры и процесса сборки ядра Linux,
мы рассмотим лишь несколько интересных применений \GNUmake{} внутри
системы сборки ядра. Более подробное обсуждением системы сборки ядра
версий 2.5/2.6 и эволюции этой системы по сравнению с версией 2.4 вы
можете найти по адресу
\url{http://macarchive.linuxsymposium.org/ols2003/Proceedings/All-Reprints/Reprint-Germaschewski-OLS2003.pdf}.

Поскольку упомянутый \Makefile{} имеет так много аспектов, мы обсудим
лишь некоторые из тех, что могут быть использованы в различных
приложениях. Сначала мы рассмотрим, как однобуквенные переменные
\GNUmake{} используются для симуляции ключей командной строки. Мы
увидим, как разделить деревья каталогов с исходными и с бинарными
файлами разделяются, чтобы пользователи смогли вызывать \GNUmake{}
прямо из каталога с исходным кодом. Затем мы исследуем методику,
позволяющую \makefile{у} контролировать степень детализации
вывода. Далее, мы рассмотрим наиболее интересные функции, определяемые
пользователем, и увидим, как они препятствуют дублированию кода,
улучшают читаемость кода и инкапсулируют сложность. Наконец, мы
рассмотрим базовый функционал справки, реализованный с помощью
\GNUmake{}.

Ядро Linux следует известному шаблону \textit{конфигурация, сборка,
  установка} (configure, build, install), применяемому большинством
проектов свободного программного обеспечения. В то время как множество
открытых проектов используют отдельный сценарий
\filename{con\-fi\-gure} (обычно созданный при помощи
\utility{autoconf}), ядро Linux реализует стадию конфигурации с
помощью \GNUmake{}, вызывая внешние сценарии и вспомогательные
программы неявно.

Когда стадия конфигурации завершена, команда \command{make} или
\command{make all} собирает ядро, все модули и создаёт сжатый образ
ядра (цели \target{vmlinux}, \target{modules} и
\target{bzImage}, соответственно). Каждой сборке ядра присваивается
уникальный номер, хранящийся в файле \filename{version.o},
прилинкованном к ядру. Это число (и файл \filename{version.o})
обновляются средствами самого \makefile{а}.

%---------------------------------------------------------------------
% Command-Line Options
%---------------------------------------------------------------------
\subsection{Опции командной строки}
Первая часть \makefile{а} содержит код, устанавливающий общие опции
сборки, полученные из командной строки. Ниже приведена выдержка,
осуществляющая контроль флага детализации вывода:

\begin{verbatim}
# Чтобы предупреждения были более заметными, по-умолчанию
# отображается минимум сообщений.
# Для более детального вывода используйте 'make V=1'.
ifdef V
  ifeq ("$(origin V)", "command line")
    KBUILD_VERBOSE = $(V)
  endif
endif
ifndef KBUILD_VERBOSE
  KBUILD_VERBOSE = 0
endif
\end{verbatim}

Вложенная пара \directive{ifdef}/\directive{ifeq} проверяет, что
переменная \variable{KBUILD\_VERBOSE} выставляется только в том
случае, когда переменная \variable{V} была определена в командной
строке. Определение \variable{V} в окружении или внутри \makefile{а}
не возымеет эффекта. Следующая директива \directive{ifndef} выключает
флаг \variable{KBUILD\_VERBOSE}, если его значение ещё не было
определено. Чтобы включить детальный вывод из окружения или
\makefile{а}, вам нужно явно определить значение переменной
\variable{KBUILD\_VERBOSE}, а не \variable{V}.

Заметим, однако, что определение опции \variable{KBUILD\_VERBOSE} явно
в командной строке разрешено и работает именно так, как вы
ожидаете. Это может быть удобно для написания сценарев командного
интерпретатора (или псевдонимов команд) для вызова
\makefile{а}. Использование полного имени будет более
самодокументируемым и похожим на длинные опции GNU.

Другие опции командной строки, запрос запуска анализатора
\utility{sparse} (\command{C}) и требование сборки внешних модулей
(\command{M}), используют аналогичную проверку, чтобы избежать
случайного их переопределения внутри \makefile{а}.

Следующая секция \makefile{а} производит оработку опции,
устанавливающей каталога вывода (\command{O}). Это довольно сложный
участок кода. Чтобы прояснить его структуру, мы заменим некоторые
части этого отрывка многоточиями:

\begin{verbatim}
# Система kbuild поддерживает сохранение выходных файлов в отдельном
# каталоге.
# Есть два пути воспользоваться этой возможностью. В обоих случаях
# рабочим каталогом должен быть каталог с исходным кодом ядра.
# 1) O=
# Используйте опцию O: "make O=dir/to/store/output/files/"
#
# 2) Определите  KBUILD_OUTPUT
# Определите переменную окружения KBUILD_OUTPUT так, чтобы она
# указывала на каталог, в который следует поместить выходные файлы.
# export KBUILD_OUTPUT=dir/to/store/output/files/
# make
#
# Опция O= имеет более высокий приоритет, чем переменная окружения
# KBUILD_OUTPUT.
# Переменная KBUILD_SRC выставляется в значение OBJ после старта make
# На данный момент не предполагается, что KBUILD_SRC будет
# использоваться пользователями без прав суперпользователя.
ifeq ($(KBUILD_SRC),)
  # Нас вызвали из каталога, в котором распологается исходный код
  # ядра. Требуется ли помещать объектные файлы в отдельный каталог?
  ifdef O
    ifeq ("$(origin O)", "command line")
      KBUILD_OUTPUT := $(O)
    endif
  endif
  ...
  ifneq ($(KBUILD_OUTPUT),)
    ...
    .PHONY: $(MAKECMDGOALS)
    $(filter-out _all,$(MAKECMDGOALS)) _all:
        $(if $(KBUILD_VERBOSE:1=),@)$(MAKE) -C $(KBUILD_OUTPUT)       \
        KBUILD_SRC=$(CURDIR)         KBUILD_VERBOSE=$(KBUILD_VERBOSE) \
        KBUILD_CHECK=$(KBUILD_CHECK) KBUILD_EXTMOD="$(KBUILD_EXTMOD)" \
        -f $(CURDIR)/Makefile $@
    # Поручаем сборку уже вызванному make
    skip-makefile := 1
  endif # ifneq ($(KBUILD_OUTPUT),)
endif # ifeq ($(KBUILD_SRC),)

# Оставшаяся часть makefile обрабатывается только в том случае, если
# текущий вызов make - последний.
ifeq ($(skip-makefile),)
  ...the rest of the makefile here...
endif
# skip-makefile
\end{verbatim}

Вкратце, этот участок кода проверяет, определена ли переменная
\variable{KBUILD\_OUTPUT}. Если определена, в каталоге, имя которого
содержится в \variable{KBUILD\_OUT}, вызывается \GNUmake{} с
определённой переменной \variable{KBUILD\_SRC}, содержащей путь
к каталогу, в котором \GNUmake{} был выполнен в первый раз. При этом
для сборки используется исходный \Makefile{}. Также выставляется флаг
\variable{skip-makefile}, из-за чего оставшаяся часть \makefile{а} не
будет видна \GNUmake{}. Рекурсивный \GNUmake{} прочтёт тот же самый
\Makefile{} ещё раз, только в этот раз переменная
\variable{KBUILD\_SRC} будет определена, поэтому флаг
\variable{skip-makefile} не будет определён, и остаток \makefile{а}
будет прочитан и обработан.

На этом мы закончим рассмотрение опций командной строки. Большая часть
\makefile{а} находится в секции \command{ifeq(\$(skip-makefile),)}.

%---------------------------------------------------------------------
% Configuration Versus Building
%---------------------------------------------------------------------
\subsection{Конфигурация или сборка?}
\Makefile{} содержит цели для конфирурации и сборки. Конфигурационные
цели имеют форму \target{menuconfig}, \target{defconfig}, и
т.д. Вспомогательные цели, такие как \target{clean}, также трактуются
как конфигурационные цели. Другие цели, такие как \target{all},
\target{vmlinux} и \target{modules}, являются целями сборки. Главным
результатом вызова конфигурационных целей являются два файла:
\filename{.config} и \filename{.config.cmd}. Эти два файла включаются
\makefile{ом} для целей сборки и не включаются для конфигурационных
целей (поскольку именно конфигурационные цели создают эти
файлы). Можно смешивать конфигурационные цели и цели сборки в одном
вызове \GNUmake{}:

\begin{verbatim}
\$ make oldconfig all
\end{verbatim}

В этом случае \Makefile{} вызывает \GNUmake{} рекурсивно для
индивидуальной обработки каждой цели, таким образом обрабатывая
конфигурационные цели отдельно от целей сборки.

Ниже приводится начало участка кода, управляющего конфигурацией,
сборкой и смешением целей.

\begin{verbatim}
# Чтобы убедиться в том, что мы не включаем файл .config для
# конфигурационный целей, мы обрабатываем их заранее, передавая
# их scripts/kconfig/Makefile
# При вызове \GNUmake{} разрешается указывать несколько целей, а также
# смешивать конфигурационные цели и цели сборки.
# Пример: 'make oldconfig all'.
# Ситуацию со смешением целей нужно обрабатывать особым образом:
# производить повторный вызов make так, чтобы файл .config не
# включался для конфигурационных целей и в этом случае.

no-dot-config-targets := clean mrproper distclean \
                         cscope TAGS tags help %docs check%

config-targets := 0
mixed-targets  := 0
dot-config     := 1
\end{verbatim}

Переменная \variable{no-dot-config-targets} перечисляет дополнительные
цели, не требующие наличие файла \filename{.config}. Затем
инициализируются переменные \variable{config-targets},
\variable{mixed-targets} и \variable{dot-config}. Переменная
\variable{config-targets} равна единице, если в командной строке
указаны цели, отвечающие за конфигурацию. Переменная
\variable{dot-config} равна единице, если в командной строке указаны
цели, отвечающие за сборку ядра. Наконец, переменная
\variable{mixed-targets} равна 1, если были указаны оба типа целей.

Код определения \variable{dot-config} выглядит следующим образом:

\begin{verbatim}
ifneq ($(filter $(no-dot-config-targets), $(MAKECMDGOALS)),)
  ifeq ($(filter-out $(no-dot-config-targets), $(MAKECMDGOALS)),)
    dot-config := 0
  endif
endif
\end{verbatim}

Выражение \function{filter} будет непустым если значение
\variable{MAKECMDGOALS} содержит конфигурационные цели. Выражение
\directive{ifneq} будет истинным если результат вычисления
\function{filter} будет непустым. Код довольно сложно читать, в
частности, из-за наличия двойного отрицания. Выражение
\directive{ifeq} истинно, если значение \variable{MAKECMDGOALS}
содержит только конфигурационные цели. Таким образом, переменная
\variable{dot-config} будет выставлена в 0 если значение
\variable{MAKECMDGOALS} содержит только конфигурационные цели. Более
многословная реализация может прояснить значение этих двух условий:

\begin{verbatim}
config-target-list := clean mrproper distclean \
                      cscope TAGS tags help %docs check%

config-target-goal := $(filter $(config-target-list), $(MAKECMDGOALS))
build-target-goal := $(filter-out $(config-target-list), $(MAKECMDGOALS))

ifdef config-target-goal
  ifndef build-target-goal
    dot-config := 0
  endif
endif
\end{verbatim}

Использовать \directive{ifdef} вместо \function{ifndef} допустимо,
поскольку переменные с пустым значение трактуются как неопределённые,
однако надо быть аккуратным и убедиться, что значение переменной не
содержит пробелов (что сделает её определённой).

Переменные \variable{config-targets} и \variable{mixed-targets}
выставляются в следующем блоке кода:

\begin{verbatim}
ifeq ($(KBUILD_EXTMOD),)
  ifneq ($(filter config %config,$(MAKECMDGOALS)),)
    config-targets := 1
    ifneq ($(filter-out config %config,$(MAKECMDGOALS)),)
      mixed-targets := 1
    endif
  endif
endif
\end{verbatim}

Значение переменной \variable{KBUILD\_EXTMOD} будет непустым только
если происходит сборка внешних модулей, во время обычных сборок она
не будет определена. Условие в первой директиве \directive{ifneq} будет
истинным, если значение переменной \variable{MAKECMDGOALS} содержит
цель с суффиксом \filename{config}. Условие во второй директиве
\directive{ifneq} будет истинным, если значение переменной
\variable{MAKECMDGOALS} содержит также и конфигурационные цели.

Определённые таким образом переменные используются в цепочке
\directive{if-else} в четырёх условных ветках. Код сокращен и
отформатирован для выделения его структуры:

\begin{verbatim}
ifeq ($(mixed-targets),1)
  # make вызван со смешанным набором целей (конфигурационные и сборочные).
  # Обрабатываем их одну за другой.
  %:: FORCE
      $(Q)$(MAKE) -C $(srctree) KBUILD_SRC= $@
else
  ifeq ($(config-targets),1)
    # Указаны только конфигурационные цели. Убеждаемся, что реквизиты
    # обновлены, и запускаем рекурсивную сборку в scripts/kconfig для
    # сборки конфигурационных целей.
    %config: scripts_basic FORCE
        $(Q)$(MAKE) $(build)=scripts/kconfig $@
  else
    # Указаны только сборочные цели - это включает vmlinux, цели, зависящие
    # от архитектуры, clean и др. Это практически все цели, за исключением
    # целей с суффиксом config.
    ...
    ifeq ($(dot-config),1)
      # В этой секции нам потребуется .config
      # Считываем зависимости ко всем Kconfig-файлам, убеждаемся,
      # что oldconfig запущен при наличии изменений.
      -include .config.cmd
      include .config

      # Если .config требует пересборки, её нужно сделать через зависимость
      # autoconf от .config.
      # Чтобы избежать работы любых неявных правил, определим пустую комманду.
      .config: ;

      # Если .config модифицирован позднее include/linux/autoconf.h, кто-то
      # ковырялся в нём и забыл запустить make oldconfig.
      include/linux/autoconf.h: .config
          $(Q)$(MAKE) -f $(srctree)/Makefile silentoldconfig
    else
      # Цель без тела для использования в качестве реквизита
      include/linux/autoconf.h: ;
    endif
    include $(srctree)/arch/$(ARCH)/Makefile
    ... очень много make-кода ...
  endif #ifeq ($(config-targets),1)
endif #ifeq ($(mixed-targets),1)
\end{verbatim}

Первая ветка, \command{ifeq (\$(mixed-targets),1)}, обрабатывает
случай смешанных целей в списке аргументов. Единственная цель в этой
ветке~--- общее шаблонное правило. Поскольку специфические правила для
обработки целей не определены (они все находятся в других ветках
условных директив), каждая цель вызывает однократное срабатывание
общего шаблонного правила. Таким образом, смешанный набор целей
разделяется на несколько более простых, и для каждой цели рекурсивно
вызывается \GNUmake{}, который снова применяет ту же логику (только в
этот раз командная строка не будет содержать смешанного набора
целей). Вместо \target{.PHONY} используется реквизит \target{FORCE},
поскольку шаблонное правило вида

\begin{verbatim}
%:: FORCE
\end{verbatim}

не может быть объявлено \target{.PHONY}. Поэтому выглядит логичным
использовать \target{FORCE} вместо \target{.PHONY} во всём
\makefile{е}.

Вторая ветка цепочки \directive{if-else}, \command{ifeq
  (\$(config-targets),1)}, вызывается, если в командной строке
присутствуют только конфигурационные цели. Единственным правилом в
этой ветке является шаблонное правило
\command{\%command}. Соответствующая этому правилу команда рекурсивно
вызывает \GNUmake{} в подкаталоге \filename{scripts/kconfig} и
передаёт цель в качестве аргумента. Конструкция \command{\$(build)}
определена в конце \makefile{а}:

\begin{verbatim}
# Сокращение для $(Q)$(MAKE) -f scripts/Makefile.build obj=dir
# Использование:
# $(Q)$(MAKE) $(build)=dir
build := -f $(if $(KBUILD_SRC),$(srctree)/)scripts/Makefile.build obj
\end{verbatim}

Если переменная \variable{KBUILD\_SRC} определена, опция \command{-f}
задаёт абсолютный путь к \makefile{у}, в противном случае используется
относительный путь. При раскрытии макроса переменной \variable{obj}
будет присвоено значение справа от \command{\$(build)=}.

В третьей ветке, \command{ifeq (\$(dot-config),1)}, обрабатывает цели,
требующие включения двух генерируемых конфигурационных файлов,
\filename{.config} и \filename{.config.cmd}. Последняя ветка включает
цель без тела \target{autoconf.h} для использования её в качестве
реквизита, даже если соответсвтующий файл не существует.

Оставшаяся часть \makefile{а} отвечает третьей и четвёртой условной
ветке и содержит код сборки ядра и его модулей.

%---------------------------------------------------------------------
% Managing Command Echo
%---------------------------------------------------------------------
\subsection{Управление командой \command{echo}}
\label{sec:managing_command_echo}
\makefile{ы} ядра используют новаторскую технику управления уровнем
детализации вывода, производимого выполняемыми комадами. Каждая важная
задача представлена в двух вариантах: с тихим и с детальным режимом
вывода. Делальная версия содержит только команду, которую нужно
выполнить, в естественной форме и сохранена в переменной
\variable{cmd\_\ItalicMono{action}}. Тихая версия содержит короткое
сообщение, описывающее выполняемое действие, и хранится в переменной
\variable{quiet\_cmd\_\ItalicMono{action}}. Например, команада, создающая
файл символов для \utility{emacs}, выглядит следующим образом:

\begin{verbatim}
quiet_cmd_TAGS = MAKE $@
cmd_TAGS = $(all-sources) | etags -
\end{verbatim}

Команда может быть выполнена с помощью вызова функции \function{cmd}:

\begin{verbatim}
# Если переменная quiet выставлена, использовать короткую версию команды
cmd = @$(if $($(quiet)cmd_$(1)),\
         echo ' $($(quiet)cmd_$(1))' &&) $(cmd_$(1))
\end{verbatim}

Чтобы вызвать код, формирующий файл символов для \utility{emacs},
\Makefile{} должен содержать следующий код:

\begin{verbatim}
TAGS:
    $(call cmd,TAGS)
\end{verbatim}

Обратите внимание на то, что функция \function{cmd} начинается с символа
\Monospace{@}, поэтому единственный вывод, производимые ей, является
выводом команды \command{echo}. В нормальном режиме переменная
\variable{queit} не определена, и условие
\command{if, \$(\$(quiet)cmd\_\$(1))} возвращает \command{\$(cmd\_TAGS)}.
Поскольку эта переменная определена, результатом всего выражения будет
команда

\begin{verbatim}
echo ' $(all-sources) | etags -' && $(all-sources) | etags -
\end{verbatim}

Если тихий режим вывода более предпочтителен, переменная
\variable{queit} содержит текст \command{queit\_}, и результатом
вычисления функции будет выражение

\begin{verbatim}
echo ' MAKE $@' && $(all-sources) | etags -
\end{verbatim}

Значением переменной также может быть \command{silent\_}. Поскольку команда
\command{silent\_cmd\_TAGS} не определена, вызов функции \command{cmd} ничего
не выводит.

Вывод команд иногда более затруднителен, в частности, если команды содержат
апострофы. В этом случае \Makefile{} содержит следующий код:

\begin{verbatim}
$(if $($(quiet)cmd_$(1)),echo ' $(subst ','\'',$($(quiet)cmd_$(1)))';)
\end{verbatim}

Команда \command{echo} содержит подстановку, которая экранирует апострофы,
благодаря чему они выводятся правильным образом.

Небольшие команды, не требующие определения переменных \command{cmd\_}
и \command{quiet\_cmd\_}, имеют префикс \command{\$(0)}, который может
быть пуст или равен \command{@}:

\begin{verbatim}
ifeq ($(KBUILD_VERBOSE),1)
  quiet =
  Q =
else
  quiet=quiet_
  Q = @
endif

# Если пользователь выполняет команду make -s ("тихий" режим),
# подавить вывод команд

ifneq ($(findstring s,$(MAKEFLAGS)),)
  quiet=silent_
endif
\end{verbatim}

%---------------------------------------------------------------------
% User-Defined Functions
%---------------------------------------------------------------------
\subsection{Функции, опредённые пользователем}

\Makefile{} ядра определяет несколько функций. В этом разделе мы
рассмотрим наиболее интересные из них. Форматирование кода было
изменено для улучшения читабельности.

Функция \function{check\_gcc} используется для выбора опций
командной строки \utility{gcc}.

\begin{verbatim}
# $(call check_gcc,preferred-option,alternate-option)
check_gcc = \
  $(shell if $(CC) $(CFLAGS) $(1) -S -o /dev/null \
             -xc /dev/null > /dev/null 2>&1;      \
          then                                    \
            echo "$(1)";                          \
          else                                    \
            echo "$(2)";                          \
          fi ;)
\end{verbatim}

Функция вызывает \utility{gcc} с пустым списком исходных файлов
с предопределёнными опциями командной строки. Выходной файл,
а также содержимое стандартных потоков вывода и ошибки отбрасываются.
Если выполнение \utility{gcc} завершается успехом, это означает, что
предопределённые опции командной строки допустимы на данной архитектуре,
и функция возвращает эти опции в качестве результата. В противном
случае опции являются недопустимыми, и функция возвращает алтернативный
набор опций. Пример использования этой опции может быть найден в файле
\filename{arch/i386/Makefile}:

\begin{verbatim}
# Запрещаем gcc сохранять 16-байтовое выравнивание сегмента стека
CFLAGS += $(call check_gcc,-mpreferred-stack-boundary=2,)
\end{verbatim}

Функция \function{if\_changed\_dep} генерирует информацию о
зависимостях, используя довольно интересную технику.

\begin{verbatim}
# Выполняет команду и выполняет пост-обработку составленного
# .d файла зависимостей
if_changed_dep =                                         \
    $(if                                                 \
      $(strip $?                                         \
        $(filter-out FORCE $(wildcard $^),$^)            \
        $(filter-out $(cmd_$(1)),$(cmd_$@))              \
        $(filter-out $(cmd_$@),$(cmd_$(1)))),            \
      @set -e;                                           \
      $(if $($(quiet)cmd_$(1)),                          \
        echo ' $(subst ','\'',$($(quiet)cmd_$(1)))';)    \
      $(cmd_$(1));                                       \
      scripts/basic/fixdep                               \
          $(depfile)                                     \
          $@                                             \
          '$(subst $$,$$$$,$(subst ','\'',$(cmd_$(1))))' \
          > $(@D)/.$(@F).tmp;                            \
      rm -f $(depfile);                                  \
      mv -f $(@D)/.$(@F).tmp $(@D)/.$(@F).cmd)
\end{verbatim}

Функция состоит из одного условного выражения. Детали условия
достаточно запутанны, однако, достаточно чётко выделяется
намерение получить непустое значение, если файл с зависимостями
должен быть обновлён. Обычно информация о зависимостях
рассматривается в контексте даты последней модификации файлов.
Система сборки ядра добавляет к этой задаче дополнительные ньюансы.
Сборка ядра требует огромного количества опций компиляции для
контроля сборки и поведения компонентов. Чтобы убедиться, что
опции командной строки учитываются при сборке правильным образом,
\Makefile{} производит перекомпиляцию файла при изменении опций
для соответствующей цели. Перейдём к более детальному рассмотрению
механизма, с помощью которого это реализовано.

Команда, используемая для компиляции каждого файла ядра, сохраняется в
файле с расширением \filename{.cmd}. Когда выполняется повторная
сборка, \GNUmake{} читает \filename{.cmd}-файл и сравнивает текущую
команду компиляции с предыдущей. Если они отличаются, в
\filename{.cmd}-файл записывается новое значение команды, что вызывает
пересборку объектного файла. \filename{.cmd} файл обычно состоит из
двух частей: списка файлов-зависимостей целевого файла и одной
переменной, содержащей список опций компилятора. Например, файл
\filename{arch/i386/cpu/mtrr/if.c} порождает следующий (сокращённый)
\filename{.cmd}-файл:

\begin{verbatim}
cmd_arch/i386/kernel/cpu/mtrr/if.o := gcc -Wp,-MD ...; if.c

deps_arch/i386/kernel/cpu/mtrr/if.o := \
arch/i386/kernel/cpu/mtrr/if.c \
...

arch/i386/kernel/cpu/mtrr/if.o: $(deps_arch/i386/kernel/cpu/mtrr/if.o)
$(deps_arch/i386/kernel/cpu/mtrr/if.o):
\end{verbatim}

Вернёмся к функции \function{if\_changed\_dep}. Первый аргумент
\function{strip}~--- это (возможно, пустой) список реквизитов,
модифицированных позднее, чем цель. Второй аргумент~--- это все
реквизиты, не являющиеся файлами или специальной целью
\target{FORCE}. Предназначение последних двух вызовов
\function{filter-out} определённо требует пояснения:

\begin{verbatim}
$(filter-out $(cmd\_$(1)),$(cmd\_$@))
$(filter-out $(cmd\_$@),$(cmd\_$(1)))
\end{verbatim}

Результат вычисления этих вызовов будет непустой строкой, если
аргументы командной строки изменились. Результатом подстановки макроса
\command{\$(cmd\_\$(1))} является текущая команда, а макроса
\command{\$(cmd\_\$@)}~--- предыдущая команда, например, переменная
\variable{cmd\_arch/i386/kernel/cpu/mtrr/if.o} из предудущего
примера. Если новая команда содержит дополнительные опции, результатом
первого вызова \function{filter-out} будет пустая строка, а
результатом второго~--- новые опции. Если же новая команда содержит
меньше опций, первый результат будет содержать удалённые опции, а
второй будет пустым. Заметим, что поскольку \function{filter-out}
принимает список слов (каждое из которых интерпретируется как
независимый шаблон), случай изменения порядка опций будет обработан
корректно. Довольно изящное решение.

Первая инструкция в теле команды устанавливает опции интерпретатора,
вызывающие немедленное завершение выполнения в случае ошибки. Это
предотвращает повреждение файлов многострочными сценариями в случае
возникновения проблем. В случае простых сценариев альтернативой может
быть соединение инструкций оператором \command{\&\&}, а не точкой с
запятой.

Следующая инструкция~--- это команда \command{echo}, записанная с
использованием техники, описанной в разделе
\nameref{sec:managing_command_echo} текущей главы. Далее следует
непосредственно команда генерации зависимостей, создающая файл
\variable{\$(depfile)}, который затем трансформируется сценарием
\filename{scripts/basic/fixdep}. Вложенные в \command{fixdep} вызовы
\function{subst} экранируют вхождения последовательности \command{\$\$}
(командный интерпретатор сопоставляет ей идентификатор текущего
процесса).

В случае отсутсвия ошибок вспомогательный файл \variable{\$(depfile)}
удаляется, а сгенерированный файл зависимостей (с расширением
\filename{.cmd}) перемещается в соответствующий каталог.

Следующая функция, \function{if\_changed\_rule}, использует для
управления командами ту же технику сравнения, что и
\function{if\_changed\_dep}:

\begin{verbatim}
# Usage: $(call if_changed_rule,foo)
# will check if $(cmd_foo) changed, or any of the prequisites changed,
# and if so will execute $(rule_foo)
if_changed_rule =                                   \
    $(if $(strip $?                                 \
           $(filter-out $(cmd_$(1)),$(cmd_$(@F)))   \
           $(filter-out $(cmd_$(@F)),$(cmd_$(1)))), \
      @$(rule_$(1)))
\end{verbatim}

Эта функция используется внутри макросов в \makefile{е} верхнего
уровня, чтобы слинковаять ядро:

\begin{verbatim}
# Нетривиальный момент: Если мы хотим произвести повторную
# линковку vmlinux, желательно увеличить номер версии, что
# означает перекомпиляцию init/version.o и линковку init/init.o.
# Однако, мы не можем сделать это во время фазы рекурсивной
# сборки (descending-into-subdirs phase), поскольку на этом
# этапе мы не можем знать, потребуется ли повторная линковка
# vmlinux. Поэтому мы снова рекурсивно запускаем make в каталоге
# init/ в рамках правила для vmlinux.

...

quiet_cmd_vmlinux__ = LD $@
define cmd_vmlinux__
  $(LD) $(LDFLAGS) $(LDFLAGS_vmlinux) \
  ...
endef

# set -e заставляет правило завершиться немедлненно
# в случае ошибки

define rule_vmlinux__
  +set -e;                                             \
  $(if $(filter .tmp_kallsyms%,$^),,                   \
    echo ' GEN    .version';                           \
    . $(srctree)/scripts/mkversion > .tmp_version;     \
    mv -f .tmp_version .version;                       \
    $(MAKE) $(build)=init;)                            \
  $(if $($(quiet)cmd_vmlinux__),                       \
    echo ' $($(quiet)cmd_vmlinux__)' &&)               \
  $(cmd_vmlinux__);                                    \
  echo 'cmd_$@ := $(cmd_vmlinux__)' > $(@D)/.$(@F).cmd
endef

define rule_vmlinux
  $(rule_vmlinux__);            \
  $(NM) $@ |                    \
  grep -v '\(compiled\)\|...' | \
  sort > System.map
endef
\end{verbatim}

Функция \function{if\_changed\_rule} используется для вызова правила
\function{rule\_vmlinux}, которое выполняет линковку и собирает
финальный файл \filename{System.map}. Как указано в комментариях к
\makefile{у}, функция \function{rule\_vmlinux\_\_} отвечает за
генерацию версии ядра и повторную линковку \filename{init.o} перед
повторной линковкой \filename{vmlinux} (за это отвечает первый
оператор \function{if}). Второй опрератор \function{if} контролирует
вывод команды линковки,
\variable{\$(cmd\_vmlinux\_\_)}. Непосредственно выполняемая команда
записывается в \filename{.cmd}-файле для возможности сравнения при
следующей сборке.
