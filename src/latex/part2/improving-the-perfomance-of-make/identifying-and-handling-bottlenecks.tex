%%--------------------------------------------------------------------
%% Identifying and handling bottlenecks
%%--------------------------------------------------------------------
\section{Определяем и устраняем узкие места}
Излишние задержки выполнения \makefile{а} могут появляться по одной
из трёх причин: неудачный выбор структуры \makefile{а}, неверный
анализ зависимостей, и неправильное использование функций и переменных
\GNUmake{}. Эти проблемы могут маскироваться функциями \GNUmake{},
подобными \function{shell}, которые вызывают команды, но не печатают
их в терминал, что существенно затрудняет поиск источника задержек.

Анализ зависимостей~--- это палка о двух концах. С одной стороны,
выполнение полного анализа зависимостей может вызвать существенные
задержки. Без специальной поддержки компилятора, предоставляемой, к
примеру, \utility{gcc} и \utility{jikes}, создание файла зависимостей
требует запуска внешней программы, что практически удваивает время
компиляции\footnote{
На практике время компиляции линейно зависит от размера входного
текста и практически всегда определяется скоростью операций
ввода/вывода. Точно так же время вычисления зависимостей с помощью
опции \command{-M} линейно зависит от размера файла и ограничено
скоростью операций ввода/вывода.}. Преимуществом полного анализа
зависимостей является возможность \GNUmake{} осуществлять меньшее
количество компиляций. К сожалению, разработчики часто не верят, что
эта возможность себя оправдает, и пишут \makefile{ы} с неполной
информацией о зависимостях. Этот компромисс почти всегда превращается
в проблему, заставляющую других разработчиков платить за эту скупость
вдвойне, компилируя больше кода, чем потребовалось бы, будь у
\GNUmake{} полная информация о зависимостях.

Чтобы сформулировать стратегию анализа зависимостей, начните с
понимания зависимостей, присущих вашему проекту. Когда все
зависимости осознаны, можно приступать к представлению
этих зависимостей в \makefile{е} (вычисленных или перечисленных
вручную) и выбору сокращённых путей осуществления сборки. Хоть и не
все представленные шаги являются легко осуществимыми, этот метод сам
по себе является наиболее простым.

Когда вы определили структуру \makefile{а} и необходимые зависимости,
эффективность \makefile{а} достигается за счёт обхода некоторых
известных ловушек.

%---------------------------------------------------------------------
% Simple variables versus recursive
%---------------------------------------------------------------------
\subsection{Выбор переменных: простые или рекурсивные}
Одной из наиболее общих проблем, относящихся к производительности,
является использование рекурсивных переменных. Например, поскольку
код, приведённый ниже, использует оператор \command{=} вместо
оператора \command{:=}, при каждом обращении к переменной
\variable{DATE} её значение будет вычисляться заново:

{\footnotesize
\begin{verbatim}
DATE = $(shell date +%F)
\end{verbatim}
}

Опция \command{+\%F} сообщает программе \utility{date}, что дату
требуется возвращать в формате <<гггг-мм-дд>>, таким образом,
большинство пользователей не заметят эффекта от многократного вызова
\utility{date}. Разумеется, разработчики, засидевшиеся в офисе до
полуночи, могут быть приятно удивлены.

Поскольку \GNUmake{} не выводит команды, выполняемые при помощи
функции \function{shell}, идентифицировать, что же именно выполняется,
может быть довольно трудно. Определив переменную \variable{SHELL} как
\command{/bin/sh -x}, вы можете выявить все команды, выполняемые
\GNUmake{}.

Следующий \makefile{} создаёт каталог перед осуществлением прочих
действий. Имя каталога составляется из слова <<out>> и текущей даты:

{\footnotesize
\begin{verbatim}
DATE = $(shell date +%F)
OUTPUT_DIR = out-$(DATE)
make-directories := \
    $(shell [ -d $(OUTPUT_DIR) ] || mkdir -p $(OUTPUT_DIR))
all: ;
\end{verbatim}
}

После запуска \makefile{а} с отладочной опцией интерпретатора мы
увидим следующий вывод:

{\footnotesize
\begin{alltt}
\$ \textbf{make SHELL='/bin/sh -x'}
+ date +\%F
+ date +\%F
+ '[' -d out-2004-03-30 ']'
+ mkdir -p out-2004-03-30
make: all is up to date.
\end{alltt}
}

Теперь отчётливо видно, что команда \utility{date} выполняется дважды.
Если вам часто требуется осуществлять подобного рода отладку, вы
можете упростить её, используя конструкцию следующего вида:

{\footnotesize
\begin{verbatim}
ifdef DEBUG_SHELL
  SHELL = /bin/sh -x
endif
\end{verbatim}
}

%---------------------------------------------------------------------
% Disabling @
%---------------------------------------------------------------------
\subsection{Отключаем @}
Ещё одним способом сокрытия команд является модификатор \command{@}.
Иногда бывает полезным отключить эту возможность. Это легко
осуществить с помощью определения вспомогательной переменной
\variable{QUIET}, содержащей символ \command{@}, и использования этой
переменной в командах:

{\footnotesize
\begin{verbatim}
ifndef VERBOSE
  QUIET := @
endif
...
target:
    $(QUIET) echo Собираю цель target...
\end{verbatim}
}

Когда нужно будет увидеть команды, скрытые при помощи модификатора,
просто определите переменную \variable{VERBOSE} через интерфейс
командной строки:

{\footnotesize
\begin{alltt}
\$ \textbf{make VERBOSE=1}
echo Собираю цель target...
Собираю цель target...
\end{alltt}
}

%---------------------------------------------------------------------
% Lazy initialization
%---------------------------------------------------------------------
\subsection{Ленивая инициализация}
При использовании простых переменных в сочетании с функцией
\function{shell}, \GNUmake{} осуществляет вызовы функции
\function{shell} во время чтения \makefile{а}. Если таких вызовов
много, или если они осуществляют сложные вычисления, выполнение
\GNUmake{} может существенно замедлиться. Время отклика \GNUmake{}
можно измерить, вызвав \GNUmake{} со спецификацией несуществующей
цели:

{\footnotesize
\begin{alltt}
\$ \textbf{time make no-such-target}
make: *** No rule to make target no-such-target. Stop.
real    0m0.058s
user    0m0.062s
sys     0m0.015s
\end{alltt}
}

Приведённый выше код измеряет время, добавляемое \GNUmake{} к каждой
выполняемой команде, даже если эта команда тривиальна или ошибочна.

Поскольку рекурсивные переменные вычисляются заново при каждом
обращении к ним, существует тенденция оформлять результаты сложных
вычислений в виде простых переменных. С другой стороны, такой подход
увеличивает время отклика \GNUmake{} при сборке любой цели. Похоже,
существует необходимость в дополнительном виде переменных, правая
часть которых вычисляется в точности один раз при первом обращении к
переменной.

Пример, иллюстрирующий необходимость подобного рода инициализации, был
приведён в функции \function{find\hyp{}compilation\hyp{}dir} в разделе
<<\nameref{sec:all_in_one_compile}>> главы \ref{chap:java}:

{\footnotesize
\begin{verbatim}
# $(call find-compilation-dirs, root-directory)
find-compilation-dirs =                      \
  $(patsubst %/,%,                           \
    $(sort                                   \
      $(dir                                  \
        $(shell $(FIND) $1 -name '*.java'))))
PACKAGE_DIRS := $(call find-compilation-dirs, $(SOURCE_DIR))
\end{verbatim}
}

В идеале нам хотелось бы осуществлять операцию \command{find} только
один раз при первом обращении к переменной \variable{PACKAGE\_DIR}.
\index{Ленивая инициализация}
Это можно назвать \newword{ленивой инициализацией} (\newword{lazy
initialization}). Мы можем создать подобного рода переменную с помощью
функции \function{eval}:

{\footnotesize
\begin{verbatim}
PACKAGE_DIRS = $(redefine-package-dirs) $(PACKAGE_DIRS)
redefine-package-dirs =                                \
  $(eval PACKAGE_DIRS := $(call find-compilation-dirs, \
                           $(SOURCE_DIR)))
\end{verbatim}
}

Этот подход заключается в определении \variable{PACKAGE\_DIR} как
изначально рекурсивной переменной. При первом обращении к переменной
вычисляется ресурсоёмкая функция, в данном случае
\function{find\hyp{}compilation\hyp{}dir}, и переменная
переопределяется как простая. Наконец, значение переменной (теперь уже
простой) возвращается как результат обращения к первоначально
рекурсивной переменной.

Давайте рассмотрим этот пример более детально:
\begin{enumerate}
%---------------------------------------------------------------------
\item Когда \GNUmake{} считывает эти переменные, он просто сохраняет
правые части их определений, так как обе переменные являются
рекурсивными.
%---------------------------------------------------------------------
\item При первом обращении к переменной \variable{PACKAGE\_DIRS}
\GNUmake{} извлекает соответствующую правую часть и производит
вычисление переменной \variable{redefine\hyp{}package\hyp{}dirs}.
%---------------------------------------------------------------------
\item Значением переменной \variable{redefine\hyp{}package\hyp{}dirs}
является единственный вызов функции \function{eval}.
%---------------------------------------------------------------------
\item Тело функции \function{eval} переопределяет переменную
\variable{PACKAGE\_DIRS} как простую переменную, присваивая ей
результат вычисления функции
\function{find\hyp{}compilation\hyp{}dirs}. Теперь
\variable{PACKAGE\_DIRS} инициализирована списком каталогов.
%---------------------------------------------------------------------
\item Результатом вычисления функции
\function{redefine\hyp{}package\hyp{}dir} является пустая строка
(поскольку результатом вычисления функции \function{eval} также
является пустая строка).
%---------------------------------------------------------------------
\item \GNUmake{} продолжает вычислять изначальное значение переменной
\variable{PACKAGE\_DIRS}. Остаётся только подставить значение
переменной \variable{PACKAGE\_DIRS}. \GNUmake{} производит поиск
переменной, находит простую переменную и возвращает её значение.
%---------------------------------------------------------------------
\end{enumerate}

Единственным по-настоящему тонким моментом в этом коде является
предположение, согласно которому \GNUmake{} вычисляет правую часть
определения переменной слева направо. Если, к примеру, \GNUmake{}
решит вычислить выражение \command{\$(PACKAGE\_DIRS)} раньше выражения
\command{\$(redefine\hyp{}package\hyp{}dirs)}, этот код не будет
работать.

Процедура, описанная мной выше, может быть преобразована в функцию
\function{lazy-init}:

{\footnotesize
\begin{verbatim}
# $(call lazy-init,variable-name,value)
define lazy-init
  $1 = $$(redefine-$1) $$($1)
  redefine-$1 = $$(eval $1 := $2)
endef

# PACKAGE_DIRS - ленивое вычисление списка каталогов
$(eval                           \
  $(call lazy-init,PACKAGE_DIRS, \
    $$(call find-compilation-dirs,$(SOURCE_DIRS))))
\end{verbatim}
}
