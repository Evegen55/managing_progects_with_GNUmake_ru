%%--------------------------------------------------------------------
%% Enterprise JavaBeans
%%--------------------------------------------------------------------
\section{Enterprise JavaBeans}

\Java{}\hyp{}компоненты уровня предприятия (Enterprise
Java\-Beans\trademark{}, EJB)~--- это мощная техника инкапсуляции и
повторного использования бизнес\hyp{}логики, каркасом которой является
механизм удалённых вызовов методов (Remote Method Invocation, RMI).
EJB определяет \Java{}\hyp{}классы, используемые для реализации API
сервера, используемого, в конечном счёте, удалёнными клиентами. Эти
объекты и службы настраиваются при помощи специальных файлов в формате
XML.  После написания \Java{}\hyp{}класса и соответствующего ему
конфигурационного XML\hyp{}файла эти файлы нужно упаковать вместе в
\Java{}\hyp{}архив. Затем вызывается специальный EJB\hyp{}компилятор,
создающий код заглушек и связок, реализующих поддержку RPC.

Следующий код может быть добавлен в код универсального \Makefile{}'а
для предоставления поддержки EJB:

{\footnotesize
\begin{verbatim}
EJB_TMP_JAR = $(EJB_TMP_DIR)/temp.jar
META_INF    = $(EJB_TMP_DIR)/META-INF

# $(call compile-bean, jar-name,
#        bean-files-wildcard, manifest-name-opt)
define compile-bean
  $(eval EJB_TMP_DIR := $(shell mktemp -d \
                          $(TMPDIR)/compile-bean.XXXXXXXX))
  $(MKDIR) $(META_INF)
  $(if $(filter %.xml, $2),cp $(filter %.xml, $2) $(META_INF))
  cd $(OUTPUT_DIR) &&                     \
  $(JAR) -cf0 $(EJB_TMP_JAR)              \
         $(call jar-file-arg,$(META_INF)) \
         $(filter-out %.xml, $2)
  $(JVM) weblogic.ejbc $(EJB_TMP_JAR) $1
  $(call add-manifest,$(if $3,$3,$1),,)
  $(RM) $(EJB_TMP_DIR)
endef

# $(call jar-file-arg, jar-file)
jar-file-arg = -C "$(patsubst %/,%,$(dir $1))" $(notdir $1)
\end{verbatim}
}

Функция \function{compile\hyp{}bean} принимает три параметра: имя
\Java{}\hyp{}архива, который требуется создать, список файлов,
входящих в архив, и необязательный файл манифеста. Сначала при помощи
программы \utility{mktemp} создаётся пустой временный каталог, имя
каталога сохраняется в переменной \variable{EJB\_TMP\_DIR}. Поместив
присваивание этой переменной в функцию \function{eval}, мы получаем
гарантию того, что значение \variable{EJB\_TMP\_DIR} будет указывать
на новый временный каталог при каждом вычислении функции
\function{compile\hyp{}bean}. Поскольку функция
\function{compile\hyp{}bean} используется в командном сценарии,
она будет вычисляться только при выполнении сценария. Затем функция
осуществляет копирование всех XML файлов из списка
\variable{bean\hyp{}files\hyp{}wild\-card} в каталог
\filename{META\hyp{}INF}. Именно в этом каталоге хранятся
конфигурационные файлы EJB. После этого функция создаёт временный
\Java{}\hyp{}архив, используемый в качестве входа для
EJB\hyp{}компилятора. Функция \function{jar\hyp{}file\hyp{}arg}
преобразует имена вида \filename{dir1/dir2/dir3} к виду
\filename{-C dir1/dir2 dir3}, поэтому относительные имена файлов
архива корректны. Этот наиболее подходящий формат для передачи команде
\utility{jar} пути к каталогу \filename{META\hyp{}INF}. Поскольку
XML\hyp{}файлы, содержавшиеся в списке, уже скопированы в каталог
\filename{META\hyp{}INF}, мы отсеиваем их из списка аргументов команды
\utility{jar} при помощи функции \function{filter\hyp{}out}. После
сборки временного архива вызывается EJB\hyp{}компилятор Web\-Lo\-gic,
создающий результирующий архив. Затем к составленному архиву
добавляется файл манифеста. Последним действием является удаление
временного архива.

Способ использования новой функции очевиден:

{\footnotesize
\begin{verbatim}
bean_files = com/company/bean/FooInterface.class      \
             com/company/bean/FooHome.class           \
             src/com/company/bean/ejb-jar.xml         \
             src/com/company/bean/weblogic-ejb-jar.xml

.PHONY: ejb_jar $(EJB_JAR)
ejb_jar: $(EJB_JAR)
$(EJB_JAR):
    $(call compile-bean, $@, $(bean_files), weblogic.mf)
\end{verbatim}
}

Список \variable{bean\_files} немного необычен. Пути к файлам классов,
входящих в этот список, указаны относительно каталога
\filename{classes}, в то время как пути к XML\hyp{}файлам будут
вычисляться относительно каталога, в котором располагается
\Makefile{}.

Это всё замечательно, но что если ваш архив содержит много файлов?
Существует ли способ составить список файлов автоматически?
Разумеется:

{\footnotesize
\begin{verbatim}
src_dirs := $(SOURCE_DIR)/com/company/...

bean_files =                                          \
  $(patsubst $(SOURCE_DIR)/%,%,                       \
    $(addsuffix /*.class,                             \
      $(sort                                          \
        $(dir                                         \
          $(wildcard                                  \
            $(addsuffix /*Home.java,$(src_dirs)))))))

.PHONY: ejb_jar $(EJB_JAR)
ejb_jar: $(EJB_JAR)
$(EJB_JAR):
    $(call compile-bean, $@, $(bean_files), weblogic.mf)
\end{verbatim}
}

Этот код подразумевает, что список каталогов с исходными файлами
хранится в переменной \variable{src\_dirs} (в списке могут находится и
каталоги, не содержащие кода EJB\hyp{}компонентов), и что все файлы,
оканчивающиеся строкой \emph{Home.java}, идентифицируют пакеты,
содержащие код EJB\hyp{}компонентов. Выражение для определения
переменной \variable{bean\_files} сначала добавляет суффикс шаблона к
имени каждого каталога в списке, а затем вызывает функцию
\function{wild\-card} для нахождения всех файлов, имя которых
оканчивается строкой \emph{Home.java}. Имена файлов отбрасываются,
полученный список каталогов сортируется, дублирующиеся элементы
удаляются из списка. К каждому каталогу добавляется суффикс
\command{/*.class}, в результате командный интерпретатор заменит
шаблон списком соответствующих файлов классов. Наконец, от каждого
элемента списка отсекается префикс, содержащий имя каталога с
исходными файлами (поскольку такого подкаталога каталога
\filename{classes} не существует). Причиной использования шаблонов
командного интерпретатора вместо функции \function{wild\-card}
является тот факт, что \GNUmake{} не сможет гарантированно выполнить
поиск файлов, соответствующих шаблону, \emph{после} компиляции и
генерации файлов классов. Если \GNUmake{} вычислит функцию
\function{wild\-card} слишком рано, файлы не будут обнаружены, а кэш
содержимого каталогов помешает найти эти файлы позже. Применение же
функции \function{wild\-card} в каталоге с исходными файлами
совершенно безопасно, поскольку мы подразумеваем, что исходные файлы
не будут добавляться во время работы \GNUmake{}.

Предыдущий код будет работать в том случае, если у нас имеется
небольшое число архивов компонентов. Другой стиль разработки
подразумевает помещение каждого EJB\hyp{}компонента в собственный
\Java{}\hyp{}архив. Большие проекты могут содержать десятки архивов.
Для того, чтобы осуществлять автоматическую обработку этой ситуации,
нам нужно составить явное правило для каждого EJB\hyp{}архива. В нашем
примере исходный код EJB\hyp{}компонентов самодостаточен: каждый
компонент располагается в отдельном каталоге вместе с ассоциированным
XML\hyp{}файлом. Определить каталоги, содержащие EJB\hyp{}компоненты,
можно по наличию файлов, оканчивающихся строкой \emph{Session.java}.

Основной подход заключается в поиске EJB\hyp{}компонентов в каталогах
с исходным кодом, построении явного правила для каждого компонента и
записи этих правил в файл. Затем файл с правилами для
EJB\hyp{}компонентов включается в наш \Makefile{}. Создание файла с
правилами для компонентов вызывается через механизм управления
включаемыми файлами \GNUmake{}.

{\footnotesize
\begin{verbatim}
# session_jars - архивы EJB, адресованные относительным путём.
session_jars =
  $(subst .java,.jar,                       \
    $(wildcard                              \
      $(addsuffix /*Session.java, $(COMPILATION_DIRS))))

# EJBS - список всех EJB-архивов.
EJBS = $(addprefix $(TMP_DIR)/,$(notdir $(session_jars)))

# ejbs - Create all EJB jar files.
.PHONY: ejbs
ejbs: $(EJBS)
$(EJBS):
    $(call compile-bean,$@,$^,)
\end{verbatim}
}

С помощью вызова функции \function{wild\-card} со списком всех
каталогов с исходным кодом в качестве аргумента мы находим все файлы,
имя которых оканчивается на \emph{Session.java}. В нашем примере имя
архива образуется из имени найденного исходного файла с добавлением
расширения \filename{.jar}. Архивы будут помещаться во временный
каталог. Переменная \variable{EJBS} содержит список архивов,
адресованных относительным путём от корня дерева бинарных файлов.
Эти архивы являются целью, которую мы хотим обновить. Командным
сценарием является вызов функции \function{compile\hyp{}bean},
реализованной нами ранее. Фокус заключается в том, что список файлов
указан в качестве реквизита каждого архива. Давайте посмотрим, как
они будут создаваться.

{\footnotesize
\begin{verbatim}
-include $(OUTPUT_DIR)/ejb.d

# $(call ejb-rule, ejb-name)
ejb-rule = $(TMP_DIR)/$(notdir $1):            \
             $(addprefix $(OUTPUT_DIR)/,       \
               $(subst .java,.class,           \
                 $(wildcard $(dir $1)*.java))) \
             $(wildcard $(dir $1)*.xml)

# ejb.d - файл зависимостей EJB
$(OUTPUT_DIR)/ejb.d: Makefile
    @echo Вычисляю зависимости ejb...
    @for f in $(session_jars);       \
    do                               \
      echo "\$$(call ejb-rule,$$f)"; \
    done > $@
\end{verbatim}
}

Зависимости для каждого EJB\hyp{}архива записываются в файл
\filename{ejb.d}, включаемый в \Makefile{}. Когда \GNUmake{} первый
раз производит поиск этого файла, файл ещё не существует. Поэтому
\GNUmake{} вызывает правило для обновления включаемого файла. Это
правило записывает по одной строке, подобной следующей, для каждого
EJB\hyp{}архива:

{\footnotesize
\begin{verbatim}
$(call ejb-rule,src/com/company/foo/FooSession.jar)
\end{verbatim}
}

Результатом вычисления функции \function{ejb\hyp{}rule} является
имя целевого архива и списка реквизитов, как показано ниже:

{\footnotesize
\begin{verbatim}
classes/lib/FooSession.jar:                  \
    classes/com/company/foo/FooHome.jar      \
    classes/com/company/foo/FooInterface.jar \
    classes/com/company/foo/FooSession.jar   \
    src/com/company/foo/ejb-jar.xml          \
    src/com/company/foo/ejb-weblogic-jar.xml
\end{verbatim}
}

Таким образом, \GNUmake{} предоставляет возможность управлять довольно
большим количеством архивов без необходимости ручной поддержки набора
явных правил.
