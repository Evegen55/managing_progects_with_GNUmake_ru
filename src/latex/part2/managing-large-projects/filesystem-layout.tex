%%--------------------------------------------------------------------
%% Filesystem layout
%%--------------------------------------------------------------------
\section{Структура файловой системы}
\label{sec:filesystem_layout}

Как только вы решите поддерживать несколько деревьев каталогов,
содержащих бинарные файлы, встаёт вопрос о структуре файловой системы.
В средах, требующих использования нескольких деревьев каталогов, часто
содержится \emph{много} таких деревьев. Чтобы найти способ
поддержания порядка в таких средах требуется немного подумать.

Наиболее общим способом структурирования этих данных является
выделение большого жёсткого диска как хранилища деревьев каталогов с
бинарными файлами. Корневой (или близкий к корню) каталог содержит
один подкаталог для каждого дерева. Одним из разумных способов
идетнификации этих деревьев является включение в имя каждого каталога
именования поставщика, платформы, операционной системы и параметров
сборки бинарного дерева:

{\footnotesize
\begin{alltt}
\$ \textbf{ls}
hp-386-windows-optimized
hp-386-windows-debug
sgi-irix-optimized
sgi-irix-debug
sun-solaris8-profiled
sun-solaris8-debug
\end{alltt}
}

Если требуется хранить множество сборок, произведённых в разные
моменты времени, для их идентификации обычно используются временные
метки, включенные в имя каталога. Из-за удобства сортировки часто
используются форматы \texttt{гг-мм-дд} и \texttt{гг-мм-дд-чч-мм}:

{\footnotesize
\begin{alltt}
\$ \textbf{ls}
hp-386-windows-optimized-040123
hp-386-windows-debug-040123
sgi-irix-optimzed-040127
sgi-irix-debug-040127
sun-solaris8-profiled-040127
sun-solaris8-debug-040127
\end{alltt}
}

Конечно, способ упорядочивания имён компонентов целиком зависит от
ваших потребностей. Каталог верхнего уровня этих деревьев хорошо
подходит для хранения \Makefile{}'а и отчётов о результатах тестов.

Предыдущая структура хорошо подходит для хранения множества сборок,
осуществляемых разработчиками параллельно. Если команда разработчиков
выпускает <<релизы>>, возможно, для внутренних потребителей, вам стоит
рассмотреть возможность добавления хранилища релизов,
структурированное как множество продуктов, каждый из которых может
иметь номер ревизии и временную метку, как показано на
рисунке~\ref{fig:release_tree_layout}.

\begin{figure}
{\footnotesize
\begin{verbatim}
release
|
|--product1
|  |--1.0
|  |  |--040101
|  |  `--040112
|  |
|  `--1.4
|     `--040121
|
`--product1
   `--1.4
      `--031212
\end{verbatim}
}
\caption{Пример структуры дерева каталогов релиза}
\label{fig:release_tree_layout}
\end{figure}

Продукты могут быть библиотеками, производимыми командой разработчиков
для нужд других разработчиков. Конечно, это могут быть и продукты в
привычном их понимании.

Каковы бы ни были структура файловой системы и среда разработки,
реализацией управляет множество однотипных критериев. Каждое дерево
должно легко идентифицироваться. Освобождение ресурсов должно быть
быстрым и ясным. Полезно иметь возможность перемещать и архивировать
деревья. В добавок ко всему, структура файловой системы должна быть
близка структуре процесса разработки организации. Это позволит
перемещаться по хранилищу непрограммистам, таким, как менеджеры,
инженеры по качеству и составители технической документации. 
