%%--------------------------------------------------------------------
%% Recursive make
%%--------------------------------------------------------------------
\section{Рекурсивный \GNUmake{}}
\label{sec:recursive_make}

\index{Рекурсивный \GNUmake{}} Мотивация использования рекурсивного
\GNUmake{} довольно проста: \GNUmake{} отлично работает в рамках
одного каталога (или небольшого набора каталогов), однако его
использование заметно усложняется с ростом числа каталогов. Таким
образом, мы можем использовать \GNUmake{} для сборки большого проекта,
написав для каждого каталога свой простой самодостаточный \Makefile{},
а затем выполнив полученные \Makefile{}'ы по очереди. Мы могли бы
использовать для этой цели сценарий, однако наиболее эффективным
подходом является использование \GNUmake{}, поскольку между
компонентами обычно существуют зависимости более высокого уровня.

Предположим, что мы ведём разработку приложения для воспроизведения
mp3 файлов. Логически его можно разделить на несколько компонентов:
пользовательский интерфейс, кодеки и система управления базой
данных. Эти компоненты могут быть представлены трёмя библиотеками:
\filename{libui.a}, \filename{libcodec.a} и \filename{libdb.a}. Само
приложение является <<клеем>>, связывающим эти три части
воедино. Наиболее простое отображение этих компонентов в структуру
каталогов представлено на рисунке~\ref{fig:file_layout_mp3}.

\begin{figure}
{\footnotesize
\begin{verbatim}
.
|
|--makefile
|
|--include
|  |--db
|  |--codec
|  `--ui
|
|--lib
|  |--db
|  |--codec
|  `--ui
|
|--app
|  `--player
|
`--doc
\end{verbatim}
}
\caption{Структура каталогов проекта mp3 плеера}
\label{fig:file_layout_mp3}
\end{figure}

Более традиционная структура каталогов подразумевает помещение функции
main и <<клея>> в корневой каталог, а не в подкаталог
\filename{app/player}. Я предпочитаю помещать код приложения в
собсвенный каталог, поскольку это делает структуру корневого каталога
более ясной и позволяет легко добавлять в систему новые
модули. Например, если мы решим добавить отдельное приложение для
управления музыкальными каталогами, мы можем аккуратно поместить его в
\filename{app/catalog}.

Если каждый каталог из \filename{lib/db}, \filename{lib/codec},
\filename{lib/ui} и \filename{app/player} содержит собственный
\Makefile{}, то работой головного \Makefile{}'а станет их
последовательный вызов:

{\footnotesize
\begin{verbatim}
lib_codec := lib/codec
lib_db := lib/db
lib_ui := lib/ui
libraries := $(lib_ui) $(lib_db) $(lib_codec)
player := app/player

.PHONY: all $(player) $(libraries)
all: $(player)

$(player) $(libraries):
    $(MAKE) --directory=$@

$(player): $(libraries)
$(lib_ui): $(lib_db) $(lib_codec)
\end{verbatim}
}

Главный \Makefile{} вызывает \GNUmake{} в каждом подкаталоге в рамках
правила, перечисляющего все подкаталоги как цели и выполняющего вызов
\GNUmake{}:

{\footnotesize
\begin{verbatim}
$(player) $(libraries):
    $(MAKE) --directory=$@
\end{verbatim}
}

Переменная \variable{MAKE} должна использоваться всегда при вызове
\GNUmake{} из \Makefile{}'а. \GNUmake{} распознаёт эту переменную и
подставляет на её место реальный путь к исполняемому файлу \GNUmake{},
чтобы все рекурсивные вызовы \GNUmake{} использовали один исполняемый
файл. К тому же, строки, содержащие переменную \variable{MAKE},
обрабатываются особым образом, если используются опции \command{-{}-touch}
(\command{-t}), \command{-{}-just\hyp{}print} (\command{-n}) или
\command{-{}-question} (\command{-q}). Мы обсудим эти детали в
разделе <<\nameref{sec:command_line_options}>> далее в этой главе.

Целевые каталоги помечены как \variable{.PHONY}, поэтому правила
выполняются даже в том случае, когда пересборка целей не
\index{Опции!directory@\command{-{}-directory (-C)}}
требуется. Опция \command{-{}-di\-rec\-to\-ry} (\command{-C})
используется для того, чтобы заставить \GNUmake{} поменять текущий
каталог перед чтением \Makefile{}'а.

Это правило, также довольно тонкое, помогает избежать нескольких
проблем, возникающих при использовании более <<очевидного>> командного
сценария:

{\footnotesize
\begin{verbatim}
all:
    for d in $(player) $(libraries); \
    do                               \ 
        $(MAKE) --directory=$$d;     \
    done
\end{verbatim}
}

Этот командный сценарий не сможет правильно передать ошибки
родительскому \GNUmake{}. Он также не позволит \GNUmake{} выполнять
сборки в разных подкаталогах параллельно. Мы обсудим эту возможность
\GNUmake{} в главе~\ref{chap:improving_the_performance}.

Когда \GNUmake{} планирует выполнение графа зависимостей, реквизиты
цели выглядят для него независимыми. В добавок к этому, две
цели, не связанные зависимостью от третьей цели, также
независимы. Например, библиотеки не  имеют непосредственной
зависимости от цели \target{app/player} или друг от друга. Это
позволяет \GNUmake{} выполнять \Makefile{} для \filename{app/player}
перед сборкой библиотек. Естественно, это вызовет ошибку сборки, так
как компоновка приложения требует наличия библиотек. Для решения этой
проблемы мы добавили дополнительную информацию о зависимостях:

{\footnotesize
\begin{verbatim}
$(player): $(libraries)
$(lib_ui): $(lib_db) $(lib_codec)
\end{verbatim}
}

Этот отрывок сообщает \GNUmake{}, что \Makefile{}'ы в подкаталогах
библиотек должны быть выполнены раньше \Makefile{}'а в каталоге
\filename{player}. Точно так же код библиотеки \filename{lib/ui}
требует, чтобы библиотеки \filename{lib/db} и \filename{lib/codec}
были уже собраны. Это позволяет быть уверенным, что любой код,
требующий генерации (например, исходные файлы на yacc/lex), будет
сгенерирован до того, как начнётся компиляция кода \filename{ui}.

Существует также одна тонкость в отношении порядка сборки
реквизитов. Как и в случае остальных зависимостей, порядок сборки
определяется на основании анализа графа зависимостей, однако когда
реквизиты цели перечисляются в одной строке, GNU \GNUmake{} иногда
собирает их слева направо. Рассмотрим пример:

{\footnotesize
\begin{verbatim}
all: a b c
all: d e f
\end{verbatim}
}

Если нет других зависимостей, требующих рассмотрения, шесть реквизитов
могут быть собраны в любом порядке (например, <<d b a c e f>>), однако
\GNUmake{} в рамках одной строки использует порядок слева направо,
порождая один из следующих результатов: <<a b c d e f>> \emph{или} <<d
e f a b c>>. Несмотря на то, что этот порядок является случайностью
реализации, порядок выполнения будет выглядеть правильным. Легко
забыть, что правильный порядок сборки является счастливой
случайностью, и не предоставить \GNUmake{} полную информацию о
зависимостях компонентов. Рано или поздно анализ зависимостей породит
другой порядок сборки, став причиной ошибок. Таким образом, если набор
целей должен быть собран в определённом порядке, укажите этот порядок
явно при помощи соответствующих реквизитов.

Когда будет выполнен головной \Makefile{}, мы увидим следующий вывод:

{\footnotesize
\begin{verbatim}
make --directory=lib/db
make[1]: Entering directory `/test/lib/db'
Update db library...
make[1]: Leaving directory `/test/lib/db'
make --directory=lib/codec
make[1]: Entering directory `/test/lib/codec'
Update codec library...
make[1]: Leaving directory `/test/lib/codec'
make --directory=lib/ui
make[1]: Entering directory `/test/lib/ui'
Update ui library...
make[1]: Leaving directory `/test/lib/ui'
make --directory=app/player
make[1]: Entering directory `/test/app/player'
Update player application...
make[1]: Leaving directory `/test/app/player'
\end{verbatim}
}

Когда \GNUmake{} определяет, что происходит рекурсивный вызов
\index{Опции!print-directory@\command{-{}-print-directory (-w)}}
\GNUmake{}, он автоматически включает опцию
\command{-{}-print\hyp{}directory} (\command{-w}), руководствуясь
которой, \GNUmake{} печатает сообщения при входе в каталог или выходе
из него. Эта опция также автоматически включается при использовании
опции \command{-{}-directory} (\command{-C}). В добавок ко всему на
каждой строке в квадратных скобках печатается значение переменной
\variable{MAKELEVEL}. В нашем простом примере \Makefile{} каждого
компонента печатает только сообщение о сборке соответствующего
компонента.

%%--------------------------------------------------------------------
%% Command line options
%%--------------------------------------------------------------------
\subsection{Опции командной строки}
\label{sec:command_line_options}

Рекурсивный \GNUmake{}~--- это простая идея, которая очень быстро
становится сложной. Идеальная реализация рекурсивного \GNUmake{} ведёт
себя так, будто множество \Makefile{}'ов системы является одним целым.
Такой уровень координации практически не достижим, поэтому в
реальности всегда приходится идти на компромисы. Тонкие проблемы
станут яснее, когда мы рассмотрим, как должны обрабатываться опции
командной строки.

Предположим, что мы добавили комментарии в заголовочный файл нашего
mp3 плеера. Вместо перекомпиляции всего исходного кода, зависящего от
модифицированного заголовочного файла, мы можем выполнить команду
\index{Опции!touch@\command{-{}-touch (-t)}}
\command{make -{}-touch}, чтобы обновить время модификации всех
файлов. Выполнив эту команду в каталоге с главным \Makefile{}'ом, мы
хотели бы, чтобы \GNUmake{} обновил временные метки всех файлов,
управляемыми дочерними экземплярами \GNUmake{}. Посмотрим, как это
работает.

Когда используется опция \command{-{}-touch}, обычно нормальный
процесс выполнения правил отменяется. Вместо этого \GNUmake{}
производит обход графа зависимостей, обновляя дату модификацию всех
запрошенных неабстракных целей и их реквизитов при помощи команды
\utility{touch}.  Поскольку все наши каталоги помечены как
\variable{.PHONY}, при нормальном ходе событий они будут
проигнорированы (поскольку обновление даты модификации для них смысла
не имеет). Однако мы не хотим, чтобы эти цели игнорировались, нам
требуется выполнение ассоциированных с ними правил. Чтобы обеспечить
правильное поведение, \GNUmake{} автоматически помечает все строки в
сценариях, содержащие переменную \variable{MAKE}, модификатором
\command{+}, в результате чего \GNUmake{} запускает дочерние процессы
\GNUmake{}, несмотря на опцию \command{-{}-touch}.

Когда \GNUmake{} запускает дочерние процессы \GNUmake{}, он должен
позаботиться о передаче им флага \command{-{}-touch}. Это достигается при
помощи переменной \variable{MAKEFLAGS}. Когда \GNUmake{} стартует,
происходит автоматическое добавление большей части опций к переменной
\variable{MAKEFLAGS}. Исключениями являются опции
\command{-{}-directory} (\command{-C}), \command{-{}-file}
(\command{-f}), \command{-{}-old\hyp{}file} (\command{-o}) и
\command{-{}-new\hyp{}file} (\command{-w}). Переменная
\variable{MAKEFLAGS} экпортируется в окружение и считывается дочерними
процессами \GNUmake{} при старте.

Благодаря этой функцональности дочерние процессы \GNUmake{} по
большей части ведут себя так, как вы ожидаете. Рекурсивное выполнение
\variable{\$(MAKE)} и специальная обработка переменной
\variable{MAKEFLAGS}, применяемая к опции \command{-{}-touch}, также
применяется к опциям \command{-{}-just\hyp{}print} (\command{-n}) и
\command{-{}-question} (\command{-q}).


%%--------------------------------------------------------------------
%% Passing variables
%%--------------------------------------------------------------------
\subsection{Передача переменных}

Как уже было замечено, переменные передаются в дочерние процессы
\GNUmake{} через окружение и контролируются при помощи директив
\index{Директивы!export@\directive{export}}
\index{Директивы!unexport@\directive{unexport}}
\directive{export} и \directive{unexport}. Значения переменных, переданные
через окружение, принимаются как значения по умалчанию, однако любое
присваивание изменит их значение. Для того, чтобы разрешить переменным
окружения переопределять локальные присваивания, используйте опцию
\index{Опции!environment-overrides@\command{-{}-environment\hyp{}overrides (-e)}}
\command{-{}-en\-vi\-ron\-ment\hyp{}overrides} (\command{-e}). Вы можете явно
переопределить переменную окружения (даже при включённой опции
\index{Директивы!override@\directive{override}}
\command{-{}-en\-vi\-ron\-ment\hyp{}overrides}) при помощи директивы
\directive{override}:

{\footnotesize
\begin{verbatim}
override TMPDIR = ~/tmp
\end{verbatim}
}

Переменные, определённые в командной строке, автоматически
экспортируются в окружение, если их имена удовлетворяют синтаксису
командного интерпретатора, то есть содержат только буквы, цифры и
подчёркивания. Присваивания переменных в командной строке сохраняются
в переменной \variable{MAKEFLAGS} наряду с другими опциями.

%%--------------------------------------------------------------------
%% Error handling
%%--------------------------------------------------------------------
\subsection{Обработка ошибок}

Что происходит, когда рекурсивный вызов \GNUmake{} обнаруживает
ошибку? На самом деле ничего особенного. Процесс \GNUmake{},
обнаруживший ошибку, завершается с кодом возврата 2. После этого
происходит выход из родительского процесса \GNUmake{}, и ошибка
передаётся вверх по дереву рекурсивных вызовов. Если первый вызов
\GNUmake{} содержал опцию \command{-{}-keep\hyp{}going}
(\command{-k}), она передаётся в дочерние процессы. В этом случае
дочерний процесс \GNUmake{} продолжает нормальное выполнение,
отбрасывает текущую цель и переходит к следующей, не используя цель,
вызвавшую ошибку, в качестве реквизита.

Например, если во время сборки нашего mp3 плеера обнаружится ошибка
компиляции в компоненте \filename{lib/db}, \GNUmake{} закончит
выполнение, вернув код ошибки 2 родительскому процессу. Если мы
\index{Опции!keep-going@\command{-{}-keep\hyp{}going (-k)}}
использовали опцию \command{-{}-keep\hyp{}going} (\command{-k}),
главный процесс \GNUmake{} начнёт обработку следующей независимой
цели, \filename{lib/codec}. Когда сборка этой цели будет закончена,
\GNUmake{} завершит выполнение с кодом возврата 2, поскольку сборка
остальных целей не может быть осуществлена по причине ошибки в
\filename{lib/db}.

\index{Опции!question@\command{-{}-question (-q)}}
Опция \command{-{}-question} (\command{-q}) приводит к похожему
поведению. При включении этой опции \GNUmake{} возвращает код ошибки 1
в случае, если какая-то цель требует повторной сборки, и 0 в противном
случае. Если применить эту опцию к дереву \Makefile{}'ов, \GNUmake{}
будет рекурсивно выполнять \Makefile{}'ы, пока не определит, требует
ли проект сборки. Как только обнаружится файл, требующий сборки,
\GNUmake{} завершит выполняемый в данный момент процесс \GNUmake{} и
<<размотает>> рекурсию.

%%--------------------------------------------------------------------
%% Building other targets
%%--------------------------------------------------------------------
\subsection{Сборка других целей}

Базовые цели для сборки естественны для большинства систем сборок,
однако нам нужны и другие вспомогательные цели, от которых мы зависим,
такие как \target{clean}, \target{install}, \target{print} и так
далее. Поскольку это абстрактные цели, описанная выше техника работает
не очень хорошо.

Например, ниже представлены несколько неработающих подходов:

{\footnotesize
\begin{verbatim}
clean: $(player) $(libraries)
    $(MAKE) --directory=$@ clean
\end{verbatim}
}
или:
{\footnotesize
\begin{verbatim}
$(player) $(libraries):
    $(MAKE) --directory=$@ clean
\end{verbatim}
}

Первый пример не работает потому, что реквизиты цели \target{clean}
вызовут сборку целей по умолчанию в \Makefile{}'ах
\variable{\$(player)} и \variable{\$(libraries)}, а не сборку цели
\target{clean}. Второй пример неверен потому, что для этих целей уже
определён другой командный сценарий.

Один из рабочих подходов основывается на использование цикла
\texttt{for}:

{\footnotesize
\begin{verbatim}
clean:
    for d in $(player) $(libraries); \
    do                               \
      $(MAKE) --directory=$$f clean; \
    done
\end{verbatim}
}

Цикл \texttt{for} не очень хорошо отвечает всем доводам, приведённым
ранее, однако он (вместе с предыдущим неверным примером) приводит нас
к следующему решению:

{\footnotesize
\begin{verbatim}
$(player) $(libraries):
    $(MAKE) --directory=$@ $(TARGET)
\end{verbatim}
}

Добавив к строке с рекурсивным вызовом \GNUmake{} переменную
\variable{TARGET} и выставляя значение этой переменной через командную
стоку, мы можем собирать в дочерних процессах \GNUmake{} произвольные
цели:

{\footnotesize
\begin{alltt}
\$ \textbf{make TARGET=clean}
\end{alltt}
}

К сожалению, это не приведёт к сборке цели \variable{\$(TARGET)} в
головном \Makefile{}'е. Часто это неважно, поскольку головной
\Makefile{} не делает ничего, однако в случае необходимости мы можем
добавить ещё один вызов \GNUmake{}, защищённый функцией \function{if}:

{\footnotesize
\begin{verbatim}
$(player) $(libraries):
    $(MAKE) --directory=$@ $(TARGET)
    $(if $(TARGET), $(MAKE) $(TARGET))
\end{verbatim}
}

Теперь мы можем собрать цель \target{clean} (или любую другую), просто
присвоив соответствующее значение переменной \variable{TARGET} в
командной строке.

%%--------------------------------------------------------------------
%% Cross-Makefile dependencies
%%--------------------------------------------------------------------
\subsection{Общие зависимости}

Специальная поддержка \GNUmake{} переменных командной строки и
коммуникация через переменные окружения подразумевают, что механизм
рекурсивного \GNUmake{} хорошо отлажен. Так в чём же заключаются
упомянутые ранее сложности?

Разделённые \Makefile{}'ы, соединяемые воедино командами
\variable{\$(MAKE)} описывают только наиболее поверхностные
высокоуровневые связи. К сожалению, часто бывают более тонкие
зависимости, скрытые в некоторых каталогах.

Предположим для примера, что модуль \filename{db} включает анализатор,
основанный на \utility{yacc}, для импорта и экспорта мызукальных
данных. Если модуль \filename{ui}, \filename{ui.c}, включает
сгенерированный \utility{yacc} заголовочный файл, на лицо связи между
этими двумя модулями. Если зависимости смоделированы правильно,
\GNUmake{} должен знать, что модуль \filename{ui} требует пересборки в
случае изменения заголовочного файла грамматики. Это нетрудно
организовать, используя технику автоматической генерации зависимостей,
описанную ранее. Однако что если исполняемый файл \utility{yacc} также
изменился? В этом случае после запуска \Makefile{}'а модуля
\filename{ui} корректный \Makefile{} определит, что сначала должна
быть выполнена команда \utility{yacc} для генерации анализатора и
заголовочного файла, и только после этого должна быть осуществлена
компиляция \filename{ui.c}. При нашей декомпозиции этого не случится,
потому что правила для запуска \utility{yacc} находятся в
\Makefile{}'е \filename{db}, а не \filename{ui}.

В этом случае лучшее, что мы можем сделать~--- это убедиться в том,
что \Makefile{} модуля \filename{db} запускается всегда раньше
\Makefile{}'а модуля \filename{ui}. Эта высокоуровневая зависимость
должна быть указана вручную. Мы были достаточно проницательны, чтобы
указать эту зависимость в первой версии нашего \Makefile{}'а, однако в
целом это может стать серьёзной проблемой при поддержке. Поскольку код
добавляется и модифицируется, головной \Makefile{} в какой-то момент
будет неправильно описывать зависимости между модулями.

В продолжение примера предположим, что грамматика \utility{yacc} в
модуле \filename{db} была изменена, и \Makefile{} модуля \filename{ui}
был выполнен до \Makefile{}'а модуля \filename{db} (вручную в обход
головного \Makefile{}'а). \Makefile{} модуля \filename{ui} не содержит
информации о неудовлетворённой зависимости в \Makefile{}'е модуля
\filename{db} и о необходимости запуска программы \utility{yacc} для
изменения головного файла. Вместо этого \Makefile{} модуля
\filename{ui} компилирует программу с устаревшим заголовочным
файлом. Если при модификации были добавлены новые символы, будет
обнаружена ошибка компиляции. Поэтому рекурсивный подход изначально
более хрупок по сравнению с монолитным \Makefile{}'ом.

Ситуация ухудшается с повышением интенсивности использования
генераторов исходного кода. Предположим, в реализации модуля
\filename{ui} был использован генератор заглушек RPC\footnote{
RPC (remote procedure call, вызов удалённых процедур)~--- класс
технологий, позволяющий программному обеспечению вызывать функции,
находящиеся в другом адресном пространстве (прим. переводчика).
},
заголовочные файлы которых используются в модуле
\filename{db}. Теперь нам придётся бороться с перекрёстными ссылками
между модулями. Для решения этой проблемы нам придётся сначала
посетить модуль \filename{db} и сгенерировать заголовочные файлы
\utility{yacc}, затем посетить модуль \filename{ui} и сгенерировать
заглушки RPC, затем вернуться в \filename{db} и произвести компиляцию,
и, наконец, посетить \filename{ui} и завершить процесс компиляции. Число
проходов, требуемое для создания и компиляции исходного кода проекта
зависит от структуры кода и инструментов, при помощи которых он
создаётся. Такой вид перекрёстных зависимостей встречается в сложных
системах довольно часто.

Стандартные решения в настоящих \Makefile{}'ах как правило являются
уловками. Для того, чтобы убедиться, что обновлены все файлы, каждый
\Makefile{} выполняется по команде головного \Makefile{}'а. Заметьте,
что это именно тот подход, который мы использовали в примере с mp3
плеером. Когда происходит запуск головного \Makefile{}'а, каждый из
четырёх дочерних \Makefile{}'ов запускается по очереди. В более
сложных случаях для проверки того, что весь код сначала сгенерирован,
и только затем скомпилирован, дочерние \Makefile{}'ы запускаются по
несколько раз. Чаще всего такие итерации являются напрасной тратой
времени, однако иногда они действительно необходимы.

%%--------------------------------------------------------------------
%% Avoiding duplicate code
%%--------------------------------------------------------------------
\subsection{Избегаем дублирования кода}

Структура каталогов нашего приложения включает три
библиотеки. \Makefile{}'ы этих библиотек очень похожи. Несмотря на то,
что эти библиотеки служат разным целям, все они собираются похожими
командами. Этот тип декомпозиции типичен для больших проектов и ведёт
к большому количеству похожих \Makefile{}'ов и дублированию сценариев.

Дублирование кода~--- это плохо, даже если оно происходит в
\Makefile{}'е. Оно увеличивает стоимость поддержки программного
обеспечения и ведёт к росту количества ошибок. Оно также затрудняет
понимание алгоритмов и определение небольших их вариаций. Поэтому
желательно избежать дублирования кода \Makefile{}'ов, настолько это
возможно. Легче всего достигнуть этого выносом общих частей в
отдельный включаемый файл.

Например, \Makefile{} модуля \filename{codec} содержит следущее:

{\footnotesize
\begin{verbatim}
lib_codec := libcodec.a
sources := codec.c
objects := $(subst .c,.o,$(sources))
dependencies := $(subst .c,.d,$(sources))

include_dirs := .. ../../include
CPPFLAGS     += $(addprefix -I ,$(include_dirs))
vpath %.h $(include_dirs)

all: $(lib_codec)

$(lib_codec): $(objects)
    $(AR) $(ARFLAGS) $@ $^

.PHONY: clean
clean:
    $(RM) $(lib_codec) $(objects) $(dependencies)

ifneq "$(MAKECMDGOALS)" "clean"
  include $(dependencies)
endif

%.d: %.c
    $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $< | \
    sed 's,\($*\.o\) *:,\1 $@: ,' > $@.tmp
    mv $@.tmp $@
\end{verbatim}
}

Почти весь этот код дублицируется в \Makefile{}'ах модулей
\filename{db} и \filename{ui}. Единственное, что изменяется~--- это
имя библиотеки и исходные файлы. После того, как весь дублированный
код вынесен в файл \filename{common.mk}, мы можем сократить предыдущий
\Makefile{} следующим образом:

{\footnotesize
\begin{verbatim}
library := libcodec.a
sources := codec.c

include ../../common.mk
\end{verbatim}
}

Посмотрим, что вынесено в единственный общий включаемый файл:

{\footnotesize
\begin{verbatim}
MV := mv -f
RM := rm -f
SED := sed

objects      := $(subst .c,.o,$(sources))
dependencies := $(subst .c,.d,$(sources))
include_dirs := .. ../../include
CPPFLAGS     += $(addprefix -I ,$(include_dirs))

vpath %.h $(include_dirs)

.PHONY: library
library: $(library)

$(library): $(objects)
    $(AR) $(ARFLAGS) $@ $^

.PHONY: clean
clean:
    $(RM) $(objects) $(program) $(library) \
          $(dependencies) $(extra_clean)

ifneq "$(MAKECMDGOALS)" "clean"
  -include $(dependencies)
endif

%.c %.h: %.y
    $(YACC.y) --defines $<
    $(MV) y.tab.c $*.c
    $(MV) y.tab.h $*.h

%.d: %.c
    $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $< | \
    $(SED) 's,\($*\.o\) *:,\1 $@: ,' > $@.tmp
    $(MV) $@.tmp $@
\end{verbatim}
}

Переменная \variable{include\_dirs}, которая раньше была разной для
каждого \Makefile{}'а, теперь одинакова во всех \Makefile{}'ах. Это
достигнуто благодаря переработке пути, используемого для поиска
заголовочных файлов при компиляции: теперь все библиотеки используют
один и тот же путь.

Файл \filename{common.mk} включает также цель по умолчанию для файлов
библиотек. Исходные \Makefile{}'ы использовали в качестве цели по
умолчанию \target{all}. Это вызвало бы проблемы в \Makefile{}'ах
программ, которым требуется указать различные наборы реквизитов для
своих целей по умолчанию. Поэтому включаемая версия кода использует
цель по умолчанию \target{library}.

Заметим, что поскольку общий файл содержит цели, в \Makefile{}'ы
программ он должен включаться \emph{после} цели по умолчанию. Заметим
также, что команда сценария \target{clean} содержит ссылки на
переменные \variable{program}, \variable{library} и
\variable{extra\_clean}. Для \Makefile{}'ов библиотек переменная
\variable{program} содержит пустую строку, в \Makefile{}'ах программ
пустую строку содержит переменная \variable{library}. Переменная
\variable{extra\_clean} добавлена специально для \Makefile{}'а модуля
\filename{db}. Этот \Makefile{} использует переменную для обозначения
кода, сгенерированного программой \utility{yacc}. Код \Makefile{}'а
представлен ниже:

{\footnotesize
\begin{verbatim}
library := libdb.a
sources := scanner.c playlist.c
extra_clean := $(sources) playlist.h

.SECONDARY: playlist.c playlist.h scanner.c

include ../../common.mk
\end{verbatim}
}

При использовании этой техники дублирование кода может быть сведено к
минимуму. Поскольку б\'{о}льшая часть кода вынесена во включаемый
\Makefile{}, со временем он эволюционирует в общий \Makefile{} всего
проекта. Для настройки используются переменные \GNUmake{} и функции,
определяемые пользователем, позволяющие модифицировать общий
\Makefile{} для каждого конкретного каталога.
