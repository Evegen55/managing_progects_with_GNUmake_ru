%%--------------------------------------------------------------------
%% Managing programs and files
%%--------------------------------------------------------------------
\section{Управление программами и файлами}

Наиболее общий способ управления программами заключается в
использовании переменных для имён программ или путей, которые могут
измениться. Переменные могут быть определены в простом блоке, как мы
уже видели прежде:
{\footnotesize
\begin{verbatim}
MV ?= mv -f
RM ?= rm -f
\end{verbatim}
}
{\flushleft или же в условном блоке:}
{\footnotesize
\begin{verbatim}
ifdef COMSPEC
  MV ?= move
  RM ?= del
else
  MV ?= mv -f
  RM ?= rm -f
endif
\end{verbatim}
}

Если используется простой блок, значения переменных могут измениться
при использовании аргументов командной строки, при редактировании
\Makefile{}'а или (именно для этого случая мы использовали оператор
условного присваивания \texttt{?=}) при наличии соответствующей
переменной окружения. Как уже было ранее замечено, одним из способов
определения текущей платформы является проверка существования
переменной \variable{COMSPEC}, используемой всеми версиями
операционной системы Windows. Иногда в коррекции нуждаются только
пути:

{\footnotesize
\begin{verbatim}
ifdef COMSPEC
  OUTPUT_ROOT := d:
  GCC_HOME    := c:/gnu/usr/bin
else
  OUTPUT_ROOT := $(HOME)
  GCC_HOME    := /usr/bin
endif

OUTPUT_DIR := $(OUTPUT_ROOT)/work/binaries
CC := $(GCC_HOME)/gcc
\end{verbatim}
}

Этот стиль приводит к \Makefile{}'ам, в которых б\'{о}льшая часть
программ вызывается при помощи переменных \GNUmake{}. Пока вы не
привыкните к этому, читать такие \Makefile{}'ы будет немного сложнее.
Однако использовать переменные в любом случае разумнее, поскольку их
имена могут быть значительно короче, чем имена программ, в частности,
если используются абсолютные пути.

Та же техника может быть использована для управления опциями командной
строки. Например, встроенные правила содержат переменную
\variable{TARGET\_ARCH}, которая может быть использована для указания
опций, зависящих от платформы:

{\footnotesize
\begin{verbatim}
ifeq "$(MACHINE)" "hpux-hppa"
  TARGET_ARCH := -mdisable-fpregs
endif
\end{verbatim}
}

При определении собственных программных переменных можно использовать
подобный подход:

{\footnotesize
\begin{verbatim}
MV := mv $(MV_FLAGS)

ifeq "$(MACHINE)" "solaris-sparc"
  MV_FLAGS := -f
endif
\end{verbatim}
}

Если вы переносите продукт на несколько платформ, цепочки секций
условной обработки могут стать неуклюжими и трудными в поддержке.
Вместо использования директивы \directive{ifdef} поместите каждый
набор переменных, зависящих от платформы, в собственный файл, имя
которого содержит название платформы. Например, если вы определяете
платформу по параметрам команды \utility{uname}, можете выбрать
соответствующий файл для включения следующим образом:

{\footnotesize
\begin{verbatim}
MACHINE := $(shell uname -smo | sed 's/ /-/g')
include $(MACHINE)-defines.mk
\end{verbatim}
}

Имена файлов, содержащие пробелы, являются особенно раздражающей
проблемой при использовании \GNUmake{}. Предположение о том, что
пробелы используются для разделения символов при синтаксическом
разборе, является для \GNUmake{} фундаментальным. Множество встроенных
функций, таких как \function{word}, \function{filter} и
\function{wildcard}, предполагают, что их аргументами является список
слов, разделённых пробелами. Тем не менее, есть несколько приёмов,
которые могут немного помочь в этом вопросе.  Первый приём, описанный
в разделе~\nameref{sec:supporting_multiple_binary_trees}
главы~\ref{chap:c_and_cpp}, заключается в замене пробелов другими
символами при помощи функции \function{subst}:

{\footnotesize
\begin{verbatim}
space = $(empty) $(empty)
# $(call space-to-question,file-name)
space-to-question = $(subst $(space),?,$1)
\end{verbatim}
}

Функция \function{space-to-question} заменяет все пробелы символом
вопросительного знака, используемым командным интерпретатором при
определении шаблонов. Теперь мы можем реализовать функции
\function{wildcard} и \function{file-exists}, умеющие правильно
работать с пробелами:

{\footnotesize
\begin{verbatim}
# $(call wildcard-spaces,file-name)
wildcard-spaces = $(wildcard $(call space-to-question,$1))

# $(call file-exists,file-name)
file-exists = $(strip                                \
                $(if $1,,$(warning $1 has no value)) \
                $(call wildcard-spaces,$1))
\end{verbatim}
}

Функция \function{wildcard-spaces} использует
\function{space-to-question} для осуществления операции поиска по
шаблону, содержащему пробелы. Можно использовать функцию
\function{wildcard-spaces} для реализации функции
\function{file-exists}. Разумеется, использование символа знака
вопроса может привести к тому, что функция \function{wildcard-spaces}
будет возвращать файлы, не соответствующие первоначальному шаблону
поиска (например, <<my documents.doc>> и <<my-documents.doc>>), однако
вряд ли можно найти что-то получше.

Функцию \function{space-to-question} можно использовать для
преобразования имён файлов, содержащих пробелы, в спецификациях целей
и реквизитов, поскольку они допускают использование шаблонов:

{\footnotesize
\begin{verbatim}
space := $(empty) $(empty)

# $(call space-to-question,file-name)
space-to-question = $(subst $(space),?,$1)

# $(call question-to-space,file-name)
question-to-space = $(subst ?,$(space),$1)
$(call space-to-question,foo bar): $(call space-to-question,bar baz)
       touch "$(call question-to-space,$@)"
\end{verbatim}
}

Если файл <<\filename{bar baz}>> существует, при первом выполнении
\Makefile{}'а реквизит будет найден, поскольку существующий файл
соответствует шаблону. Однако поиск файла по шаблону, соответствующего
цели, закончится неудачей, поскольку файл цели не существует. В
результате переменная \variable{\$@} примет значение \texttt{foo?bar}.
После этого командный сценарий вызовет функцию
\function{question-to-space}, чтобы преобразовать значение переменной
\variable{\$@} обратно в имя файла, содержащее пробел. При следующем
запуске файл цели, содержащий в имени пробел, будет найден по шаблону.
Этот приём выглядит немного неуклюже, однако я нашёл ему применение в
реальных \Makefile{}'ах.

%---------------------------------------------------------------------
% Source tree layout
%---------------------------------------------------------------------
\subsection*{Структура каталогов исходного кода}

Другим аспектом переносимости является возможность предоставления
разработчикам свободы в управлении средой разработки по собственному
усмотрению. Если система сборки будет требовать от них, к примеру,
помещать исходный код, бинарные файлы, библиотеки и инструменты
разработки в один и тот же каталог или диск Windows, рано или поздно
возникнут проблемы. В конце концов, разработчики, ограниченные в
дисковом пространстве, будут вынуждены разделить эти файлы.

Вместо этого имеет смысл реализовать \Makefile{} с использованием
переменных для хранения коллекций файлов и инициализировать эти
переменные разумными значениями по умолчанию. Для доступа к каждой
используемой библиотеке или инструменту может быть использована
соответствующая переменная, это позволит разработчикам настраивать
местоположение файлов по собственному усмотрению. Используйте оператор
условного присваивания при определении таких переменных, это даст
разработчикам простой способ переопределения их значений через
переменные окружения.

К тому же, возможность простой поддержки нескольких копий дерева
каталогов с исходными и бинарными файлами является благом для
разработчиков. Даже если им не приходится поддерживать несколько
платформ или использовать различные опции компиляции, разработчикам
часто приходится работать с несколькими рабочими копиями исходного
кода в целях отладки или при параллельной работе в нескольких
проектах. Мы уже рассмотрели два возможных пути реализации этой
возможности: использование высокоуровневых переменных окружения для
идентификации корневого каталога дерева исходных и бинарных файлов,
либо использование каталога, в котором находится \Makefile{}, в
совокупности с фиксированным относительным путём для определения
корневого каталога дерева бинарных файлов. Любой из этих подходов
предоставляет разработчикам механизм для поддержки нескольких деревьев
каталогов.
