%%--------------------------------------------------------------------
%% Working with nonportable tools
%%--------------------------------------------------------------------
\section{Работа с непереносимыми инструментами}

Как уже было замечено, одной из альтернатив написания \Makefile{}'ов
по принципу наименьшего общего знаменателя является адаптация
стандартного набора инструментов. Разумеется, цель этого подхода~---
убедиться в том, что стандартный набор инструментов по меньшей мере
так же переносим, как и ваше приложение. Очевидным выбором переносимых
инструментов является набор программ проекта GNU, однако существует
довольно много проектов переносимых инструментов. Два других
инструмента, приходящие на ум~--- Perl и Python.

При отсутствии переносимых инструментов хорошей альтернативой является
инкапсуляция непереносимых инструментов в функции \GNUmake{}.
Например, для поддержки различных компиляторов Enterprise JavaBeans
(каждый из которых имеет собственный синтаксис вызова), мы можем
написать функцию для компиляции архива EJB и параметризовать её для
возможности подключения другого компилятора.

{\footnotesize
\begin{verbatim}
EJB_TMP_JAR = $(TMPDIR)/temp.jar
# $(call compile-generic-bean, bean-type, jar-name,
#        bean-files-wildcard, manifest-name-opt )
define compile-generic-bean
  $(RM) $(dir $(META_INF))
  $(MKDIR) $(META_INF)
  $(if $(filter %.xml %.xmi, $3),             \
    cp $(filter %.xml %.xmi, $3) $(META_INF))
  $(call compile-$1-bean-hook,$2)
  cd $(OUTPUT_DIR) &&                         \
  $(JAR) -cf0 $(EJB_TMP_JAR)                  \
         $(call jar-file-arg,$(META_INF))     \
         $(call bean-classes,$3)
  $(call $1-compile-command,$2)
  $(call create-manifest,$(if $4,$4,$2),,)
endef
\end{verbatim}
}

Первым аргументом этой общей функции компиляции EJB~--- это тип
компилятора компонентов, такого как Weblogic, Websphere и т.д.
Остальными аргументами являются имя архива, список файлов архива
(включая конфигурационные файлы) и необязательный файл манифеста.
Сначала шаблонная функция создаёт пустой временный каталог, удаляя и
создавая заново предыдущий временный каталог. Затем функция производит
копирование \filename{xml} и \filename{xmi} файлов, указанных в
качестве реквизитов каталога \variable{\$(META\_INF)}. На данном этапе
нам может понадобиться осуществление вспомогательных действий, будь то
очистка каталога \filename{META-INF} или подготовка \filename{.class}
файлов. Для поддержки этих операций мы включили функцию-триггер,
\function{compile-\$1-bean-hook}, которую пользователь может
реализовать по собственному усмотрению. Например, если компилятор
Websphere требует дополнительный контрольный файл, например,
\filename{xsl} файл, мы можем реализовать триггер следующим образом:

{\footnotesize
\begin{verbatim}
# $(call compile-websphere-bean-hook, file-list)
define compile-websphere-bean-hook
  cp $(filter %.xsl, $1) $(META_INF)
endef
\end{verbatim}
}

Просто определив эту функцию, мы убеждаемся в том, что вызов
\function{call} в функции \function{compile-generic-bean} будет
осуществлён успешно. Если не будем писать триггер, соответствующий
вызов в \function{compile-generic-bean} вычислится в пустую строку.

Затем наша функция создаёт jar архив. Вспомогательная функция
\function{jar\hyp{}file\hyp{}arg} производит преобразование обычного
пути к файлу в конкатенацию опции \texttt{-C} и относительного пути:

{\footnotesize
\begin{verbatim}
# $(call jar-file-arg, file-name)
define jar-file-arg
  -C "$(patsubst %/,%,$(dir $1))" $(notdir $1)
endef
\end{verbatim}
}

Вспомогательная функция \function{bean\hyp{}classes} извлекает
подходящий class файл из списка исходных файлов (в jar архив нужно
включать только интерфейсы и home классы):

{\footnotesize
\begin{verbatim}
# $(call bean-classes, bean-files-list)
define bean-classes
  $(subst $(SOURCE_DIR)/,,                 \
    $(filter %Interface.class %Home.class, \
      $(subst .java,.class,$1)))
endef
\end{verbatim}
}

Затем общая функция вызывает соответствующую команду компиляции
\texttt{\$(call \$1\hyp{}compile\hyp{}command,\$2)}:

{\footnotesize
\begin{verbatim}
define weblogic-compile-command
  cd $(TMPDIR) && \
  $(JVM) weblogic.ejbc -compiler $(EJB_JAVAC) $(EJB_TMP_JAR) $1
endef
\end{verbatim}
}

Наконец, общая функция добавляет файл манифеста.

После определения функции \function{compile-generic-bean} мы можем
обернуть её вызов в специальную функцию для каждого компилятора,
который мы хотим поддерживать.

{\footnotesize
\begin{verbatim}
# $(call compile-weblogic-bean, jar-name,
#        bean-files-wildcard, manifest-name-opt )
define compile-weblogic-bean
  $(call compile-generic-bean,weblogic,$1,$2,$3)
endef
\end{verbatim}
}

%---------------------------------------------------------------------
% A standard shell
%---------------------------------------------------------------------
\subsection*{Стандартный интерпретатор}

Следует ещё раз подчеркнуть, что одним из самых досадных источников
непереносимости при переходе на другую систему являются возможности
интерпретатора \filename{/bin/sh}, используемого \GNUmake{} по
умолчанию. Если вам приходится настраивать командные сценарии вашего
\Makefile{}'а, рассмотрите возможность стандартизации вашего
интерпретатора. Разумеется, это не очень подходит для типичных
проектов с открытым исходным кодом, \Makefile{}'ы которых выполняются
в неконтролируемой среде. Однако в случае, если вы управляете средой и
контролируете число машин, которые нужно настроить, такой подход
вполне разумен.

Многие интерпретаторы предоставляют возможности, которые могут
исключить использование большого числа небольших программ. Например,
\utility{bash} включает расширенные возможности работы с переменными,
такие как \texttt{\%\%} и \texttt{\#\#}, которые могут помочь избежать
использования инструментов, таких как \utility{sed} и \utility{expr}.
